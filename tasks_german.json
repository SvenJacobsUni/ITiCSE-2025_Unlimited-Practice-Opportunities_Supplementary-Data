[
  {
    "id": 1,
    "programming_concept": "For-Schleifen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Highscore-Liste im modernen Gaming\n\nSchreibe eine Funktion namens `highscore_liste(scores)`, die eine Liste von Spielergebnissen (Scores) als Argument erhält. Die Funktion soll die Spielergebnisse in absteigender Reihenfolge sortieren und die Top 5 Ergebnisse zurückgeben. Falls weniger als 5 Ergebnisse vorhanden sind, sollen alle vorhandenen Ergebnisse zurückgegeben werden.\n\nBeispielaufruf:\n```python\nhighscore_liste([1500, 3000, 2500, 5000, 1000, 2000])\n```\n\nErwartete Rückgabe:\n```python\n[5000, 3000, 2500, 2000, 1500]\n```",
    "code_skeleton": "def highscore_liste(scores):\n    ## Hier Code einfügen",
    "model_solution": "def highscore_liste(scores):\n    return sorted(scores, reverse=True)[:5]\n\nprint(highscore_liste([1500, 3000, 2500, 5000, 1000, 2000]))",
    "unit_tests": "import unittest\nfrom main import highscore_liste\n\nclass TestHighscoreListe(unittest.TestCase):\n    def test_mehr_als_fuenf_scores(self):\n        self.assertEqual(highscore_liste([1500, 3000, 2500, 5000, 1000, 2000]), [5000, 3000, 2500, 2000, 1500])\n\n    def test_genau_fuenf_scores(self):\n        self.assertEqual(highscore_liste([1500, 3000, 2500, 5000, 1000]), [5000, 3000, 2500, 1500, 1000])\n\n    def test_weniger_als_fuenf_scores(self):\n        self.assertEqual(highscore_liste([1500, 3000, 2500]), [3000, 2500, 1500])\n\n    def test_leere_liste(self):\n        self.assertEqual(highscore_liste([]), [])\n\n    def test_alle_scores_gleich(self):\n        self.assertEqual(highscore_liste([1000, 1000, 1000, 1000, 1000, 1000]), [1000, 1000, 1000, 1000, 1000])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 2,
    "programming_concept": "While-Schleifen",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Film-Watchlist\n\nSchreibe eine Funktion namens `film_watchlist(filme)`, die eine Liste von Filmen als Argument erhält. Die Funktion soll eine While-Schleife verwenden, um durch die Liste zu iterieren und jeden Film auszugeben. Wenn die Liste leer ist, soll die Funktion \"Keine Filme in der Watchlist.\" ausgeben.\n\nBeispielaufruf:\n```python\nfilm_watchlist([\"Inception\", \"The Matrix\", \"Interstellar\"])\n```\n\nErwartete Ausgabe:\n```\nInception\nThe Matrix\nInterstellar\n```\n\nBeispielaufruf:\n```python\nfilm_watchlist([])\n```\n\nErwartete Ausgabe:\n```\nKeine Filme in der Watchlist.\n```",
    "code_skeleton": "def film_watchlist(filme):\n    ## Hier Code einfügen",
    "model_solution": "def film_watchlist(filme):\n    if not filme:\n        print(\"Keine Filme in der Watchlist.\")\n    while filme:\n        print(filme.pop(0))\n\nfilm_watchlist([\"Inception\", \"The Matrix\", \"Interstellar\"])\nfilm_watchlist([])",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import film_watchlist\n\nclass TestFilmWatchlist(unittest.TestCase):\n    def test_watchlist_with_films(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        film_watchlist([\"Inception\", \"The Matrix\", \"Interstellar\"])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Inception\\nThe Matrix\\nInterstellar\")\n\n    def test_empty_watchlist(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        film_watchlist([])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Keine Filme in der Watchlist.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 3,
    "programming_concept": "For-Schleifen",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungen und For-Schleifen\n\nSchreibe eine Funktion namens `beziehungsstatus(liste)`, die eine Liste von Namen als Argument erhält. Die Funktion soll für jeden Namen in der Liste eine Nachricht ausgeben, die den Beziehungsstatus der Person beschreibt. Verwende eine For-Schleife, um durch die Liste zu iterieren und die Nachrichten zu generieren.\n\nBeispielaufruf:\n```python\nbeziehungsstatus([\"Anna\", \"Ben\", \"Clara\"])\n```\n\nBeispielausgabe:\n```\nAnna ist Single.\nBen ist in einer Beziehung.\nClara ist verheiratet.\n```\n\nHinweis: Die Nachrichten können für jeden Namen gleich sein, es geht darum, die For-Schleife zu üben.",
    "code_skeleton": "def beziehungsstatus(liste):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(liste):\n    for name in liste:\n        print(f\"{name} ist Single.\")\n\nbeziehungsstatus([\"Anna\", \"Ben\", \"Clara\"])",
    "unit_tests": "import unittest\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(beziehungsstatus([]), [])\n\n    def test_ein_name(self):\n        self.assertEqual(beziehungsstatus([\"Anna\"]), [\"Anna ist Single.\"])\n\n    def test_mehrere_namen(self):\n        self.assertEqual(beziehungsstatus([\"Anna\", \"Ben\", \"Clara\"]), [\"Anna ist Single.\", \"Ben ist Single.\", \"Clara ist Single.\"])\n\n    def test_namen_mit_leerzeichen(self):\n        self.assertEqual(beziehungsstatus([\" Anna \", \" Ben \", \" Clara \"]), [\" Anna  ist Single.\", \" Ben  ist Single.\", \" Clara  ist Single.\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 4,
    "programming_concept": "String",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustierbeschreibung\n\nSchreibe eine Funktion namens `haustier_beschreibung(tierart, name)`, die eine Beschreibung eines Haustiers erstellt. Die Funktion soll zwei Parameter entgegennehmen: `tierart` (z.B. \"Hund\", \"Katze\") und `name` (z.B. \"Bello\", \"Minka\"). Die Funktion soll einen String zurückgeben, der das Haustier beschreibt.\n\nBeispielaufruf: \n```python\nhaustier_beschreibung(\"Hund\", \"Bello\")\n```\n\nErwartete Ausgabe:\n```python\n\"Bello ist ein Hund.\"\n```\n\nBeispielaufruf:\n```python\nhaustier_beschreibung(\"Katze\", \"Minka\")\n```\n\nErwartete Ausgabe:\n```python\n\"Minka ist eine Katze.\"\n```",
    "code_skeleton": "def haustier_beschreibung(tierart, name):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_beschreibung(tierart, name):\n    return f\"{name} ist ein{'' if tierart.lower() in ['hund', 'vogel'] else 'e'} {tierart}.\"\n\nprint(haustier_beschreibung(\"Hund\", \"Bello\"))\nprint(haustier_beschreibung(\"Katze\", \"Minka\"))",
    "unit_tests": "import unittest\nfrom main import haustier_beschreibung\n\nclass TestHaustierBeschreibung(unittest.TestCase):\n    def test_hund(self):\n        self.assertEqual(haustier_beschreibung(\"Hund\", \"Bello\"), \"Bello ist ein Hund.\")\n\n    def test_katze(self):\n        self.assertEqual(haustier_beschreibung(\"Katze\", \"Minka\"), \"Minka ist eine Katze.\")\n\n    def test_vogel(self):\n        self.assertEqual(haustier_beschreibung(\"Vogel\", \"Tweety\"), \"Tweety ist ein Vogel.\")\n\n    def test_fisch(self):\n        self.assertEqual(haustier_beschreibung(\"Fisch\", \"Nemo\"), \"Nemo ist ein Fisch.\")\n\n    def test_leerer_name(self):\n        self.assertEqual(haustier_beschreibung(\"Hund\", \"\"), \" ist ein Hund.\")\n\n    def test_leere_tierart(self):\n        self.assertEqual(haustier_beschreibung(\"\", \"Bello\"), \"Bello ist ein .\")\n\n    def test_leere_parameter(self):\n        self.assertEqual(haustier_beschreibung(\"\", \"\"), \" ist ein .\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 5,
    "programming_concept": "Rekursion",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rekursive Rezeptanweisungen\n\nSchreibe eine rekursive Funktion namens `koch_rezept(schritte, index)`, die eine Liste von Kochschritten und einen Index als Argumente erhält. Die Funktion soll die Kochschritte nacheinander ausgeben, beginnend beim angegebenen Index, und dabei rekursiv vorgehen. Wenn der Index das Ende der Liste erreicht, soll die Funktion aufhören.\n\nBeispielaufruf:\n```python\nkochschritte = [\"Schneide die Zwiebeln.\", \"Erhitze das Öl in der Pfanne.\", \"Brate die Zwiebeln an.\", \"Füge die Tomaten hinzu.\", \"Lasse alles 10 Minuten köcheln.\"]\nkoch_rezept(kochschritte, 0)\n```\n\nErwartete Ausgabe:\n```\nSchneide die Zwiebeln.\nErhitze das Öl in der Pfanne.\nBrate die Zwiebeln an.\nFüge die Tomaten hinzu.\nLasse alles 10 Minuten köcheln.\n```",
    "code_skeleton": "def koch_rezept(schritte, index):\n    ## Hier Code einfügen",
    "model_solution": "def koch_rezept(schritte, index):\n    if index < len(schritte):\n        print(schritte[index])\n        koch_rezept(schritte, index + 1)\n\nkochschritte = [\"Schneide die Zwiebeln.\", \"Erhitze das Öl in der Pfanne.\", \"Brate die Zwiebeln an.\", \"Füge die Tomaten hinzu.\", \"Lasse alles 10 Minuten köcheln.\"]\nkoch_rezept(kochschritte, 0)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import koch_rezept\n\nclass TestKochRezept(unittest.TestCase):\n    def setUp(self):\n        self.kochschritte = [\"Schneide die Zwiebeln.\", \"Erhitze das Öl in der Pfanne.\", \"Brate die Zwiebeln an.\", \"Füge die Tomaten hinzu.\", \"Lasse alles 10 Minuten köcheln.\"]\n        self.saved_stdout = sys.stdout\n        self.output = StringIO()\n        sys.stdout = self.output\n\n    def tearDown(self):\n        sys.stdout = self.saved_stdout\n\n    def test_koch_rezept_vollstaendig(self):\n        koch_rezept(self.kochschritte, 0)\n        self.assertEqual(self.output.getvalue().strip(), \"\\n\".join(self.kochschritte))\n\n    def test_koch_rezept_ab_mitte(self):\n        koch_rezept(self.kochschritte, 2)\n        self.assertEqual(self.output.getvalue().strip(), \"\\n\".join(self.kochschritte[2:]))\n\n    def test_koch_rezept_letzter_schritt(self):\n        koch_rezept(self.kochschritte, 4)\n        self.assertEqual(self.output.getvalue().strip(), self.kochschritte[4])\n\n    def test_koch_rezept_ueber_index(self):\n        koch_rezept(self.kochschritte, 5)\n        self.assertEqual(self.output.getvalue().strip(), \"\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 6,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tierklassifikation\n\nSchreibe eine Funktion namens `tier_klassifikation(tier)`, die eine Nachricht basierend auf dem übergebenen Tier zurückgibt. Die Funktion soll die folgenden Tiere erkennen und entsprechende Nachrichten zurückgeben:\n\n- Bei \"Hund\" soll die Nachricht \"Das ist ein treuer Begleiter!\" zurückgegeben werden.\n- Bei \"Katze\" soll die Nachricht \"Das ist ein unabhängiger Freund!\" zurückgegeben werden.\n- Bei \"Vogel\" soll die Nachricht \"Das ist ein gefiederter Freund!\" zurückgegeben werden.\n- Bei allen anderen Tieren soll die Nachricht \"Das ist ein interessantes Tier!\" zurückgegeben werden.\n\nBeispielaufrufe:\n\n```python\nprint(tier_klassifikation(\"Hund\"))  # Ausgabe: Das ist ein treuer Begleiter!\nprint(tier_klassifikation(\"Katze\"))  # Ausgabe: Das ist ein unabhängiger Freund!\nprint(tier_klassifikation(\"Vogel\"))  # Ausgabe: Das ist ein gefiederter Freund!\nprint(tier_klassifikation(\"Fisch\"))  # Ausgabe: Das ist ein interessantes Tier!\n```",
    "code_skeleton": "def tier_klassifikation(tier):\n    ## Hier Code einfügen",
    "model_solution": "def tier_klassifikation(tier):\n    if tier == \"Hund\":\n        return \"Das ist ein treuer Begleiter!\"\n    elif tier == \"Katze\":\n        return \"Das ist ein unabhängiger Freund!\"\n    elif tier == \"Vogel\":\n        return \"Das ist ein gefiederter Freund!\"\n    else:\n        return \"Das ist ein interessantes Tier!\"\n\nprint(tier_klassifikation(\"Hund\"))\nprint(tier_klassifikation(\"Katze\"))\nprint(tier_klassifikation(\"Vogel\"))\nprint(tier_klassifikation(\"Fisch\"))",
    "unit_tests": "import unittest\nfrom main import tier_klassifikation\n\nclass TestTierKlassifikation(unittest.TestCase):\n    def test_hund(self):\n        self.assertEqual(tier_klassifikation(\"Hund\"), \"Das ist ein treuer Begleiter!\")\n\n    def test_katze(self):\n        self.assertEqual(tier_klassifikation(\"Katze\"), \"Das ist ein unabhängiger Freund!\")\n\n    def test_vogel(self):\n        self.assertEqual(tier_klassifikation(\"Vogel\"), \"Das ist ein gefiederter Freund!\")\n\n    def test_unbekanntes_tier(self):\n        self.assertEqual(tier_klassifikation(\"Fisch\"), \"Das ist ein interessantes Tier!\")\n\n    def test_leerer_string(self):\n        self.assertEqual(tier_klassifikation(\"\"), \"Das ist ein interessantes Tier!\")\n\n    def test_none(self):\n        self.assertEqual(tier_klassifikation(None), \"Das ist ein interessantes Tier!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 7,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Spielerbewertung\n\nSchreibe eine Funktion namens `bewerte_spieler(punkte)`, die die Leistung eines Basketballspielers basierend auf der Anzahl der erzielten Punkte bewertet. Die Funktion soll eine entsprechende Nachricht mit `return` zurückgeben.\n\n- Wenn der Spieler 30 oder mehr Punkte erzielt hat, soll die Nachricht \"Hervorragende Leistung!\" zurückgegeben werden.\n- Wenn der Spieler zwischen 20 und 29 Punkte erzielt hat, soll die Nachricht \"Gute Leistung!\" zurückgegeben werden.\n- Wenn der Spieler zwischen 10 und 19 Punkte erzielt hat, soll die Nachricht \"Durchschnittliche Leistung.\" zurückgegeben werden.\n- Wenn der Spieler weniger als 10 Punkte erzielt hat, soll die Nachricht \"Verbesserungswürdig.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `bewerte_spieler(35)` gibt \"Hervorragende Leistung!\" zurück.\n- `bewerte_spieler(25)` gibt \"Gute Leistung!\" zurück.\n- `bewerte_spieler(15)` gibt \"Durchschnittliche Leistung.\" zurück.\n- `bewerte_spieler(5)` gibt \"Verbesserungswürdig.\" zurück.",
    "code_skeleton": "def bewerte_spieler(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(punkte):\n    if punkte >= 30:\n        return \"Hervorragende Leistung!\"\n    elif punkte >= 20:\n        return \"Gute Leistung!\"\n    elif punkte >= 10:\n        return \"Durchschnittliche Leistung.\"\n    else:\n        return \"Verbesserungswürdig.\"\n\n# Beispielaufrufe\nprint(bewerte_spieler(35))\nprint(bewerte_spieler(25))\nprint(bewerte_spieler(15))\nprint(bewerte_spieler(5))",
    "unit_tests": "import unittest\n\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler(35), \"Hervorragende Leistung!\")\n        self.assertEqual(bewerte_spieler(30), \"Hervorragende Leistung!\")\n\n    def test_gute_leistung(self):\n        self.assertEqual(bewerte_spieler(25), \"Gute Leistung!\")\n        self.assertEqual(bewerte_spieler(20), \"Gute Leistung!\")\n\n    def test_durchschnittliche_leistung(self):\n        self.assertEqual(bewerte_spieler(15), \"Durchschnittliche Leistung.\")\n        self.assertEqual(bewerte_spieler(10), \"Durchschnittliche Leistung.\")\n\n    def test_verbesserungswuerdig(self):\n        self.assertEqual(bewerte_spieler(5), \"Verbesserungswürdig.\")\n        self.assertEqual(bewerte_spieler(0), \"Verbesserungswürdig.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 8,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musikgenre-Empfehlung\n\nSchreibe eine Funktion namens `musik_empfehlung(genre)`, die basierend auf dem übergebenen Musikgenre eine entsprechende Nachricht zurückgibt. Die Funktion soll die folgenden Genres berücksichtigen:\n\n- Bei \"Rock\" soll die Nachricht \"Du magst es laut und energiegeladen!\" zurückgegeben werden.\n- Bei \"Pop\" soll die Nachricht \"Du liebst eingängige Melodien und Rhythmen!\" zurückgegeben werden.\n- Bei \"Jazz\" soll die Nachricht \"Du schätzt komplexe Harmonien und Improvisation!\" zurückgegeben werden.\n- Bei \"Klassik\" soll die Nachricht \"Du genießt zeitlose Meisterwerke und Orchesterklänge!\" zurückgegeben werden.\n\nFalls ein anderes Genre übergeben wird, soll die Nachricht \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `musik_empfehlung(\"Rock\")` gibt \"Du magst es laut und energiegeladen!\" zurück.\n- `musik_empfehlung(\"Hip-Hop\")` gibt \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\" zurück.",
    "code_skeleton": "def musik_empfehlung(genre):\n    ## Hier Code einfügen",
    "model_solution": "def musik_empfehlung(genre):\n    if genre == \"Rock\":\n        return \"Du magst es laut und energiegeladen!\"\n    elif genre == \"Pop\":\n        return \"Du liebst eingängige Melodien und Rhythmen!\"\n    elif genre == \"Jazz\":\n        return \"Du schätzt komplexe Harmonien und Improvisation!\"\n    elif genre == \"Klassik\":\n        return \"Du genießt zeitlose Meisterwerke und Orchesterklänge!\"\n    else:\n        return \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\"\n\n# Beispielaufrufe\nprint(musik_empfehlung(\"Rock\"))\nprint(musik_empfehlung(\"Hip-Hop\"))",
    "unit_tests": "import unittest\nfrom main import musik_empfehlung\n\nclass TestMusikEmpfehlung(unittest.TestCase):\n    def test_rock(self):\n        self.assertEqual(musik_empfehlung(\"Rock\"), \"Du magst es laut und energiegeladen!\")\n\n    def test_pop(self):\n        self.assertEqual(musik_empfehlung(\"Pop\"), \"Du liebst eingängige Melodien und Rhythmen!\")\n\n    def test_jazz(self):\n        self.assertEqual(musik_empfehlung(\"Jazz\"), \"Du schätzt komplexe Harmonien und Improvisation!\")\n\n    def test_klassik(self):\n        self.assertEqual(musik_empfehlung(\"Klassik\"), \"Du genießt zeitlose Meisterwerke und Orchesterklänge!\")\n\n    def test_unbekanntes_genre(self):\n        self.assertEqual(musik_empfehlung(\"Hip-Hop\"), \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\")\n\n    def test_leeres_genre(self):\n        self.assertEqual(musik_empfehlung(\"\"), \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\")\n\n    def test_none_genre(self):\n        self.assertEqual(musik_empfehlung(None), \"Genre nicht erkannt. Probiere es mit Rock, Pop, Jazz oder Klassik.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 9,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Kontext von Streaming-Diensten\n\nSchreibe eine Funktion `filter_filme(filme, kriterium)`, die eine Liste von Filmen und eine Funktion als Kriterium entgegennimmt. Die Funktion soll eine neue Liste zurückgeben, die nur die Filme enthält, die das Kriterium erfüllen.\n\nEin Film wird durch ein Dictionary repräsentiert, das mindestens die Schlüssel `titel` und `bewertung` enthält. Die Funktion `kriterium` nimmt ein Filmdictionary als Argument und gibt einen Boolean-Wert zurück.\n\nBeispielaufruf:\n```python\nfilme = [\n    {\"titel\": \"Film A\", \"bewertung\": 8.5},\n    {\"titel\": \"Film B\", \"bewertung\": 7.0},\n    {\"titel\": \"Film C\", \"bewertung\": 9.0}\n]\n\ndef hohe_bewertung(film):\n    return film[\"bewertung\"] > 8.0\n\ngefilterte_filme = filter_filme(filme, hohe_bewertung)\n# gefilterte_filme sollte [{\"titel\": \"Film A\", \"bewertung\": 8.5}, {\"titel\": \"Film C\", \"bewertung\": 9.0}] enthalten\n```\n\nImplementiere die Funktion `filter_filme(filme, kriterium)`.",
    "code_skeleton": "def filter_filme(filme, kriterium):\n    ## Hier Code einfügen",
    "model_solution": "def filter_filme(filme, kriterium):\n    return [film for film in filme if kriterium(film)]\n\nfilme = [\n    {\"titel\": \"Film A\", \"bewertung\": 8.5},\n    {\"titel\": \"Film B\", \"bewertung\": 7.0},\n    {\"titel\": \"Film C\", \"bewertung\": 9.0}\n]\n\ndef hohe_bewertung(film):\n    return film[\"bewertung\"] > 8.0\n\ngefilterte_filme = filter_filme(filme, hohe_bewertung)\nprint(gefilterte_filme)",
    "unit_tests": "import unittest\nfrom main import filter_filme\n\nclass TestFilterFilme(unittest.TestCase):\n    def test_hohe_bewertung(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 8.5},\n            {\"titel\": \"Film B\", \"bewertung\": 7.0},\n            {\"titel\": \"Film C\", \"bewertung\": 9.0}\n        ]\n        def hohe_bewertung(film):\n            return film[\"bewertung\"] > 8.0\n        self.assertEqual(filter_filme(filme, hohe_bewertung), [\n            {\"titel\": \"Film A\", \"bewertung\": 8.5},\n            {\"titel\": \"Film C\", \"bewertung\": 9.0}\n        ])\n\n    def test_niedrige_bewertung(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 8.5},\n            {\"titel\": \"Film B\", \"bewertung\": 7.0},\n            {\"titel\": \"Film C\", \"bewertung\": 9.0}\n        ]\n        def niedrige_bewertung(film):\n            return film[\"bewertung\"] < 8.0\n        self.assertEqual(filter_filme(filme, niedrige_bewertung), [\n            {\"titel\": \"Film B\", \"bewertung\": 7.0}\n        ])\n\n    def test_leere_liste(self):\n        filme = []\n        def hohe_bewertung(film):\n            return film[\"bewertung\"] > 8.0\n        self.assertEqual(filter_filme(filme, hohe_bewertung), [])\n\n    def test_alle_filme(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 8.5},\n            {\"titel\": \"Film B\", \"bewertung\": 7.0},\n            {\"titel\": \"Film C\", \"bewertung\": 9.0}\n        ]\n        def alle_filme(film):\n            return True\n        self.assertEqual(filter_filme(filme, alle_filme), filme)\n\n    def test_keine_filme(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 8.5},\n            {\"titel\": \"Film B\", \"bewertung\": 7.0},\n            {\"titel\": \"Film C\", \"bewertung\": 9.0}\n        ]\n        def keine_filme(film):\n            return False\n        self.assertEqual(filter_filme(filme, keine_filme), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 10,
    "programming_concept": "Funktionen als Variablen",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen in der Virtuellen Realität\n\nIn der virtuellen Realität (VR) können verschiedene Aktionen durch Funktionen repräsentiert werden. Schreibe eine Funktion `ausfuehren_aktion(aktion)`, die eine Aktion als Parameter entgegennimmt und diese Aktion ausführt. Die Aktion wird durch eine Funktion repräsentiert, die keine Parameter hat und eine Nachricht zurückgibt.\n\nDefiniere zwei Beispielaktionen:\n1. `start_vr()`: Gibt die Nachricht \"VR gestartet!\" zurück.\n2. `beenden_vr()`: Gibt die Nachricht \"VR beendet!\" zurück.\n\nDie Funktion `ausfuehren_aktion(aktion)` soll die übergebene Aktion ausführen und die entsprechende Nachricht zurückgeben.\n\nBeispielaufrufe:\n```python\nprint(ausfuehren_aktion(start_vr))  # Ausgabe: \"VR gestartet!\"\nprint(ausfuehren_aktion(beenden_vr))  # Ausgabe: \"VR beendet!\"\n```",
    "code_skeleton": "def ausfuehren_aktion(aktion):\n    ## Hier Code einfügen\n\ndef start_vr():\n    ## Hier Code einfügen\n\ndef beenden_vr():\n    ## Hier Code einfügen",
    "model_solution": "def ausfuehren_aktion(aktion):\n    return aktion()\n\ndef start_vr():\n    return \"VR gestartet!\"\n\ndef beenden_vr():\n    return \"VR beendet!\"\n\nprint(ausfuehren_aktion(start_vr))\nprint(ausfuehren_aktion(beenden_vr))",
    "unit_tests": "import unittest\nfrom main import ausfuehren_aktion, start_vr, beenden_vr\n\nclass TestAusfuehrenAktion(unittest.TestCase):\n    def test_start_vr(self):\n        self.assertEqual(ausfuehren_aktion(start_vr), \"VR gestartet!\")\n\n    def test_beenden_vr(self):\n        self.assertEqual(ausfuehren_aktion(beenden_vr), \"VR beendet!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 11,
    "programming_concept": "Rekursion",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Rekursion im Aquarium\n\nSchreibe eine rekursive Funktion namens `fische_zaehlen(aquarium)`, die die Anzahl der Fische in einem verschachtelten Aquarium zählt. Ein Aquarium kann entweder leer sein, eine Liste von Fischen enthalten oder eine Liste von weiteren Aquarien (die wiederum Fische oder weitere Aquarien enthalten können).\n\nEin Beispielaufruf könnte so aussehen:\n```python\naquarium = [[], [\"Fisch1\", \"Fisch2\"], [[\"Fisch3\"], []], \"Fisch4\"]\nprint(fische_zaehlen(aquarium))  # Ausgabe: 4\n```\n\nImplementiere die Funktion `fische_zaehlen(aquarium)`, die die Gesamtzahl der Fische im gesamten verschachtelten Aquarium zurückgibt.",
    "code_skeleton": "def fische_zaehlen(aquarium):\n    ## Hier Code einfügen",
    "model_solution": "def fische_zaehlen(aquarium):\n    if not isinstance(aquarium, list):\n        return 1\n    return sum(fische_zaehlen(item) for item in aquarium)\n\naquarium = [[], [\"Fisch1\", \"Fisch2\"], [[\"Fisch3\"], []], \"Fisch4\"]\nprint(fische_zaehlen(aquarium))  # Ausgabe: 4",
    "unit_tests": "import unittest\nfrom main import fische_zaehlen\n\nclass TestFischeZaehlen(unittest.TestCase):\n    def test_leeres_aquarium(self):\n        self.assertEqual(fische_zaehlen([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(fische_zaehlen([\"Fisch1\"]), 1)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(fische_zaehlen([\"Fisch1\", \"Fisch2\", \"Fisch3\"]), 3)\n\n    def test_verschachteltes_aquarium(self):\n        self.assertEqual(fische_zaehlen([[], [\"Fisch1\", \"Fisch2\"], [[\"Fisch3\"], []], \"Fisch4\"]), 4)\n\n    def test_tief_verschachteltes_aquarium(self):\n        self.assertEqual(fische_zaehlen([[[[[[\"Fisch1\"]]]]]]), 1)\n\n    def test_aquarium_mit_leeren_und_vollen_unteraquarien(self):\n        self.assertEqual(fische_zaehlen([[], [\"Fisch1\"], [], [\"Fisch2\", [\"Fisch3\"]], []]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 12,
    "programming_concept": "While-Schleifen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Wiederholungen\n\nSchreibe eine Funktion namens `trainingsplan(wiederholungen)`, die eine While-Schleife verwendet, um eine bestimmte Anzahl von Wiederholungen einer Übung zu zählen und auszugeben. Die Funktion soll die Anzahl der Wiederholungen als Argument entgegennehmen und für jede Wiederholung eine Nachricht in der Form \"Wiederholung X\" ausgeben, wobei X die aktuelle Wiederholungsnummer ist.\n\nBeispielaufruf: `trainingsplan(5)` soll die folgenden Ausgaben erzeugen:\n```\nWiederholung 1\nWiederholung 2\nWiederholung 3\nWiederholung 4\nWiederholung 5\n```",
    "code_skeleton": "def trainingsplan(wiederholungen):\n    ## Hier Code einfügen",
    "model_solution": "def trainingsplan(wiederholungen):\n    i = 1\n    while i <= wiederholungen:\n        print(f\"Wiederholung {i}\")\n        i += 1\n\ntrainingsplan(5)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import trainingsplan\n\nclass TestTrainingsplan(unittest.TestCase):\n    def test_fuenf_wiederholungen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        trainingsplan(5)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Wiederholung 1\\nWiederholung 2\\nWiederholung 3\\nWiederholung 4\\nWiederholung 5\")\n\n    def test_keine_wiederholungen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        trainingsplan(0)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"\")\n\n    def test_eine_wiederholung(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        trainingsplan(1)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Wiederholung 1\")\n\n    def test_zehn_wiederholungen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        trainingsplan(10)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Wiederholung 1\\nWiederholung 2\\nWiederholung 3\\nWiederholung 4\\nWiederholung 5\\nWiederholung 6\\nWiederholung 7\\nWiederholung 8\\nWiederholung 9\\nWiederholung 10\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 13,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Rugby-Kontext\n\nSchreibe eine Funktion `punkte_berechnen(spieler_punkte, berechnungs_funktion)`, die eine Liste von Punkten, die von verschiedenen Rugby-Spielern erzielt wurden, und eine Funktion als Argumente entgegennimmt. Die Funktion `punkte_berechnen` soll die übergebene Berechnungsfunktion auf die Liste der Spielerpunkte anwenden und das Ergebnis zurückgeben.\n\nBeispiel:\n- `spieler_punkte` ist eine Liste von Punkten, z.B. `[5, 3, 7, 2]`.\n- `berechnungs_funktion` könnte eine Funktion sein, die die Summe der Punkte berechnet.\n\nBeispielaufruf:\n```python\ndef summe_punkte(punkte):\n    return sum(punkte)\n\npunkte = [5, 3, 7, 2]\nergebnis = punkte_berechnen(punkte, summe_punkte)\nprint(ergebnis)  # Ausgabe: 17\n```\n\nImplementiere die Funktion `punkte_berechnen` und teste sie mit verschiedenen Berechnungsfunktionen.",
    "code_skeleton": "def punkte_berechnen(spieler_punkte, berechnungs_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def punkte_berechnen(spieler_punkte, berechnungs_funktion):\n    return berechnungs_funktion(spieler_punkte)\n\ndef summe_punkte(punkte):\n    return sum(punkte)\n\npunkte = [5, 3, 7, 2]\nergebnis = punkte_berechnen(punkte, summe_punkte)\nprint(ergebnis)  # Ausgabe: 17",
    "unit_tests": "import unittest\nfrom main import punkte_berechnen\n\ndef summe_punkte(punkte):\n    return sum(punkte)\n\ndef max_punkte(punkte):\n    return max(punkte)\n\ndef min_punkte(punkte):\n    return min(punkte)\n\nclass TestPunkteBerechnen(unittest.TestCase):\n    def test_summe_punkte(self):\n        self.assertEqual(punkte_berechnen([5, 3, 7, 2], summe_punkte), 17)\n\n    def test_max_punkte(self):\n        self.assertEqual(punkte_berechnen([5, 3, 7, 2], max_punkte), 7)\n\n    def test_min_punkte(self):\n        self.assertEqual(punkte_berechnen([5, 3, 7, 2], min_punkte), 2)\n\n    def test_leere_liste_summe(self):\n        self.assertEqual(punkte_berechnen([], summe_punkte), 0)\n\n    def test_leere_liste_max(self):\n        with self.assertRaises(ValueError):\n            punkte_berechnen([], max_punkte)\n\n    def test_leere_liste_min(self):\n        with self.assertRaises(ValueError):\n            punkte_berechnen([], min_punkte)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 14,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Kontext psychischer Gesundheit\n\nSchreibe eine Funktion `filter_positive_affirmations(affirmations, filter_function)`, die eine Liste von Affirmationen (positive Aussagen) und eine Filterfunktion als Argumente erhält. Die Funktion soll die Affirmationen basierend auf der übergebenen Filterfunktion filtern und die gefilterte Liste zurückgeben.\n\nBeispielaufruf:\n```python\naffirmations = [\n    \"Ich bin stark.\",\n    \"Ich bin wertvoll.\",\n    \"Ich kann alles schaffen.\",\n    \"Ich bin geliebt.\",\n    \"Ich bin genug.\"\n]\n\ndef contains_word_ich(affirmation):\n    return \"Ich\" in affirmation\n\npositive_affirmations = filter_positive_affirmations(affirmations, contains_word_ich)\nprint(positive_affirmations)\n```\n\nErwartete Ausgabe:\n```\n[\"Ich bin stark.\", \"Ich bin wertvoll.\", \"Ich kann alles schaffen.\", \"Ich bin geliebt.\", \"Ich bin genug.\"]\n```\n\nImplementiere die Funktion `filter_positive_affirmations` und teste sie mit verschiedenen Filterfunktionen.",
    "code_skeleton": "def filter_positive_affirmations(affirmations, filter_function):\n    ## Hier Code einfügen",
    "model_solution": "def filter_positive_affirmations(affirmations, filter_function):\n    return list(filter(filter_function, affirmations))\n\naffirmations = [\n    \"Ich bin stark.\",\n    \"Ich bin wertvoll.\",\n    \"Ich kann alles schaffen.\",\n    \"Ich bin geliebt.\",\n    \"Ich bin genug.\"\n]\n\ndef contains_word_ich(affirmation):\n    return \"Ich\" in affirmation\n\npositive_affirmations = filter_positive_affirmations(affirmations, contains_word_ich)\nprint(positive_affirmations)",
    "unit_tests": "import unittest\nfrom main import filter_positive_affirmations\n\nclass TestFilterPositiveAffirmations(unittest.TestCase):\n    def test_contains_word_ich(self):\n        affirmations = [\n            \"Ich bin stark.\",\n            \"Ich bin wertvoll.\",\n            \"Ich kann alles schaffen.\",\n            \"Ich bin geliebt.\",\n            \"Ich bin genug.\"\n        ]\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        expected = [\n            \"Ich bin stark.\",\n            \"Ich bin wertvoll.\",\n            \"Ich kann alles schaffen.\",\n            \"Ich bin geliebt.\",\n            \"Ich bin genug.\"\n        ]\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), expected)\n\n    def test_contains_word_bin(self):\n        affirmations = [\n            \"Ich bin stark.\",\n            \"Ich bin wertvoll.\",\n            \"Ich kann alles schaffen.\",\n            \"Ich bin geliebt.\",\n            \"Ich bin genug.\"\n        ]\n        def contains_word_bin(affirmation):\n            return \"bin\" in affirmation\n        expected = [\n            \"Ich bin stark.\",\n            \"Ich bin wertvoll.\",\n            \"Ich bin geliebt.\",\n            \"Ich bin genug.\"\n        ]\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_bin), expected)\n\n    def test_no_match(self):\n        affirmations = [\n            \"Ich bin stark.\",\n            \"Ich bin wertvoll.\",\n            \"Ich kann alles schaffen.\",\n            \"Ich bin geliebt.\",\n            \"Ich bin genug.\"\n        ]\n        def contains_word_xyz(affirmation):\n            return \"xyz\" in affirmation\n        expected = []\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_xyz), expected)\n\n    def test_empty_list(self):\n        affirmations = []\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        expected = []\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 15,
    "programming_concept": "Listen",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustierliste\n\nSchreibe eine Funktion namens `haustier_liste(haustiere)`, die eine Liste von Haustiernamen als Argument erhält. Die Funktion soll die Anzahl der Haustiere in der Liste zählen und eine Nachricht zurückgeben, die die Anzahl der Haustiere angibt. Wenn die Liste leer ist, soll die Nachricht \"Keine Haustiere gefunden.\" zurückgegeben werden.\n\nBeispielaufrufe:\n\n- `haustier_liste([\"Bella\", \"Charlie\", \"Luna\"])` gibt \"Du hast 3 Haustiere.\" zurück.\n- `haustier_liste([])` gibt \"Keine Haustiere gefunden.\" zurück.",
    "code_skeleton": "def haustier_liste(haustiere):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_liste(haustiere):\n    if not haustiere:\n        print(\"Keine Haustiere gefunden.\")\n    else:\n        print(f\"Du hast {len(haustiere)} Haustiere.\")\n\nhaustier_liste([\"Bella\", \"Charlie\", \"Luna\"])\nhaustier_liste([])",
    "unit_tests": "import unittest\nfrom main import haustier_liste\n\nclass TestHaustierListe(unittest.TestCase):\n    def test_mehrere_haustiere(self):\n        self.assertEqual(haustier_liste([\"Bella\", \"Charlie\", \"Luna\"]), \"Du hast 3 Haustiere.\")\n\n    def test_keine_haustiere(self):\n        self.assertEqual(haustier_liste([]), \"Keine Haustiere gefunden.\")\n\n    def test_ein_haustier(self):\n        self.assertEqual(haustier_liste([\"Bella\"]), \"Du hast 1 Haustier.\")\n\n    def test_zwei_haustiere(self):\n        self.assertEqual(haustier_liste([\"Bella\", \"Charlie\"]), \"Du hast 2 Haustiere.\")\n\n    def test_viele_haustiere(self):\n        self.assertEqual(haustier_liste([\"Bella\", \"Charlie\", \"Luna\", \"Max\", \"Lucy\", \"Daisy\", \"Bailey\", \"Molly\", \"Coco\", \"Buddy\"]), \"Du hast 10 Haustiere.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 16,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tierklassifikation\n\nSchreibe eine Funktion namens `tier_klassifikation(tier)`, die den Typ eines Tieres basierend auf dem übergebenen String klassifiziert. Die Funktion soll eine entsprechende Nachricht mit `return` zurückgeben.\n\n- Wenn das Tier ein \"Hund\" ist, soll die Nachricht \"Das ist ein Säugetier.\" zurückgegeben werden.\n- Wenn das Tier ein \"Adler\" ist, soll die Nachricht \"Das ist ein Vogel.\" zurückgegeben werden.\n- Wenn das Tier ein \"Hai\" ist, soll die Nachricht \"Das ist ein Fisch.\" zurückgegeben werden.\n- Für alle anderen Tiere soll die Nachricht \"Unbekannte Tierklasse.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `tier_klassifikation(\"Hund\")` gibt \"Das ist ein Säugetier.\" zurück.\n- `tier_klassifikation(\"Adler\")` gibt \"Das ist ein Vogel.\" zurück.\n- `tier_klassifikation(\"Hai\")` gibt \"Das ist ein Fisch.\" zurück.\n- `tier_klassifikation(\"Krokodil\")` gibt \"Unbekannte Tierklasse.\" zurück.",
    "code_skeleton": "def tier_klassifikation(tier):\n    ## Hier Code einfügen",
    "model_solution": "def tier_klassifikation(tier):\n    if tier == \"Hund\":\n        return \"Das ist ein Säugetier.\"\n    elif tier == \"Adler\":\n        return \"Das ist ein Vogel.\"\n    elif tier == \"Hai\":\n        return \"Das ist ein Fisch.\"\n    else:\n        return \"Unbekannte Tierklasse.\"\n\n# Beispielaufrufe\nprint(tier_klassifikation(\"Hund\"))\nprint(tier_klassifikation(\"Adler\"))\nprint(tier_klassifikation(\"Hai\"))\nprint(tier_klassifikation(\"Krokodil\"))",
    "unit_tests": "import unittest\n\nfrom main import tier_klassifikation\n\nclass TestTierKlassifikation(unittest.TestCase):\n    def test_hund(self):\n        self.assertEqual(tier_klassifikation(\"Hund\"), \"Das ist ein Säugetier.\")\n\n    def test_adler(self):\n        self.assertEqual(tier_klassifikation(\"Adler\"), \"Das ist ein Vogel.\")\n\n    def test_hai(self):\n        self.assertEqual(tier_klassifikation(\"Hai\"), \"Das ist ein Fisch.\")\n\n    def test_unbekanntes_tier(self):\n        self.assertEqual(tier_klassifikation(\"Krokodil\"), \"Unbekannte Tierklasse.\")\n\n    def test_leerer_string(self):\n        self.assertEqual(tier_klassifikation(\"\"), \"Unbekannte Tierklasse.\")\n\n    def test_none(self):\n        self.assertEqual(tier_klassifikation(None), \"Unbekannte Tierklasse.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 17,
    "programming_concept": "Float",
    "context": "Modernes Gaming",
    "task_description": "```markdown\n### Übungsaufgabe: Berechnung der Spielerpunktzahl\n\nIn modernen Videospielen ist es wichtig, die Punktzahl eines Spielers präzise zu berechnen, insbesondere wenn es um Highscores geht. Schreibe eine Funktion namens `berechne_punktzahl(kills, assists, deaths)`, die die Punktzahl eines Spielers basierend auf den folgenden Kriterien berechnet:\n\n- Jeder Kill gibt 10.5 Punkte.\n- Jeder Assist gibt 5.25 Punkte.\n- Jeder Death zieht 2.75 Punkte ab.\n\nDie Funktion soll die berechnete Punktzahl als Float-Wert zurückgeben.\n\nBeispielaufruf:\n```python\nberechne_punktzahl(10, 5, 2)\n```\nDieser Aufruf sollte die Punktzahl für einen Spieler berechnen, der 10 Kills, 5 Assists und 2 Deaths hat.\n```",
    "code_skeleton": "def berechne_punktzahl(kills, assists, deaths):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punktzahl(kills, assists, deaths):\n    return kills * 10.5 + assists * 5.25 - deaths * 2.75\n\n# Beispielaufruf\nprint(berechne_punktzahl(10, 5, 2))",
    "unit_tests": "import unittest\nfrom main import berechne_punktzahl\n\nclass TestBerechnePunktzahl(unittest.TestCase):\n    def test_positive_values(self):\n        self.assertAlmostEqual(berechne_punktzahl(10, 5, 2), 123.75)\n\n    def test_zero_values(self):\n        self.assertAlmostEqual(berechne_punktzahl(0, 0, 0), 0.0)\n\n    def test_negative_values(self):\n        self.assertAlmostEqual(berechne_punktzahl(-10, -5, -2), -123.75)\n\n    def test_mixed_values(self):\n        self.assertAlmostEqual(berechne_punktzahl(10, 0, 5), 89.75)\n\n    def test_large_values(self):\n        self.assertAlmostEqual(berechne_punktzahl(1000, 500, 200), 12375.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 18,
    "programming_concept": "Integer",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Fische im Aquarium zählen\n\nSchreibe eine Funktion namens `zaehle_fische(anzahl_fische)`, die die Anzahl der Fische in einem Aquarium zählt und eine entsprechende Nachricht zurückgibt. Die Funktion soll einen Integer-Wert `anzahl_fische` als Parameter nehmen und eine Nachricht in der Form \"Es gibt [anzahl_fische] Fische im Aquarium.\" zurückgeben.\n\nBeispielaufruf:\n```python\nprint(zaehle_fische(10))\n```\n\nErwartete Ausgabe:\n```\nEs gibt 10 Fische im Aquarium.\n```",
    "code_skeleton": "def zaehle_fische(anzahl_fische):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(anzahl_fische):\n    return f\"Es gibt {anzahl_fische} Fische im Aquarium.\"\n\nprint(zaehle_fische(10))",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_zehn_fische(self):\n        self.assertEqual(zaehle_fische(10), \"Es gibt 10 Fische im Aquarium.\")\n\n    def test_null_fische(self):\n        self.assertEqual(zaehle_fische(0), \"Es gibt 0 Fische im Aquarium.\")\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische(1), \"Es gibt 1 Fisch im Aquarium.\")\n\n    def test_negativ_fische(self):\n        self.assertEqual(zaehle_fische(-5), \"Es gibt -5 Fische im Aquarium.\")\n\n    def test_grosse_anzahl_fische(self):\n        self.assertEqual(zaehle_fische(1000), \"Es gibt 1000 Fische im Aquarium.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 19,
    "programming_concept": "For-Schleifen",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Vergnügungspark - Besucherzählung\n\nSchreibe eine Funktion namens `besucher_zaehlen(besucher_liste)`, die eine Liste von Besuchernamen als Argument erhält. Die Funktion soll die Anzahl der Besucher im Vergnügungspark zählen und zurückgeben. Verwende eine For-Schleife, um durch die Liste zu iterieren und die Anzahl der Besucher zu ermitteln.\n\nBeispielaufruf:\n```python\nbesucher_liste = [\"Anna\", \"Ben\", \"Clara\", \"David\", \"Eva\"]\nanzahl_besucher = besucher_zaehlen(besucher_liste)\nprint(anzahl_besucher)  # Ausgabe: 5\n```\n\nIn diesem Beispiel enthält die Liste `besucher_liste` fünf Namen, daher sollte die Funktion `besucher_zaehlen` den Wert `5` zurückgeben.",
    "code_skeleton": "def besucher_zaehlen(besucher_liste):\n    ## Hier Code einfügen",
    "model_solution": "def besucher_zaehlen(besucher_liste):\n    return len(besucher_liste)\n\nbesucher_liste = [\"Anna\", \"Ben\", \"Clara\", \"David\", \"Eva\"]\nanzahl_besucher = besucher_zaehlen(besucher_liste)\nprint(anzahl_besucher)  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import besucher_zaehlen\n\nclass TestBesucherZaehlen(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(besucher_zaehlen([]), 0)\n\n    def test_ein_besucher(self):\n        self.assertEqual(besucher_zaehlen([\"Anna\"]), 1)\n\n    def test_mehrere_besucher(self):\n        self.assertEqual(besucher_zaehlen([\"Anna\", \"Ben\", \"Clara\", \"David\", \"Eva\"]), 5)\n\n    def test_doppelte_besucher(self):\n        self.assertEqual(besucher_zaehlen([\"Anna\", \"Anna\", \"Ben\", \"Ben\"]), 4)\n\n    def test_gemischte_besucher(self):\n        self.assertEqual(besucher_zaehlen([\"Anna\", \"Ben\", \"Clara\", \"David\", \"Eva\", \"Anna\", \"Ben\"]), 7)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 20,
    "programming_concept": "Tupel",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Film-Tupel\n\nSchreibe eine Funktion namens `film_info(film)`, die ein Tupel als Argument erhält. Das Tupel enthält Informationen über einen Film in der folgenden Reihenfolge: Titel (String), Erscheinungsjahr (Integer), Regisseur (String) und Bewertung (Float).\n\nDie Funktion soll eine formatierte Zeichenkette zurückgeben, die die Informationen des Films in einem lesbaren Format darstellt.\n\nBeispielaufruf:\n```python\nfilm = (\"Inception\", 2010, \"Christopher Nolan\", 8.8)\nprint(film_info(film))\n```\n\nErwartete Ausgabe:\n```\nTitel: Inception\nErscheinungsjahr: 2010\nRegisseur: Christopher Nolan\nBewertung: 8.8\n```",
    "code_skeleton": "def film_info(film):\n    ## Hier Code einfügen",
    "model_solution": "def film_info(film):\n    return f\"Titel: {film[0]}\\nErscheinungsjahr: {film[1]}\\nRegisseur: {film[2]}\\nBewertung: {film[3]}\"\n\nfilm = (\"Inception\", 2010, \"Christopher Nolan\", 8.8)\nprint(film_info(film))",
    "unit_tests": "import unittest\nfrom main import film_info\n\nclass TestFilmInfo(unittest.TestCase):\n    def test_standard_film(self):\n        film = (\"Inception\", 2010, \"Christopher Nolan\", 8.8)\n        expected = \"Titel: Inception\\nErscheinungsjahr: 2010\\nRegisseur: Christopher Nolan\\nBewertung: 8.8\"\n        self.assertEqual(film_info(film), expected)\n\n    def test_film_mit_komma_in_titel(self):\n        film = (\"Spider-Man: No Way Home\", 2021, \"Jon Watts\", 8.4)\n        expected = \"Titel: Spider-Man: No Way Home\\nErscheinungsjahr: 2021\\nRegisseur: Jon Watts\\nBewertung: 8.4\"\n        self.assertEqual(film_info(film), expected)\n\n    def test_film_mit_niedriger_bewertung(self):\n        film = (\"The Room\", 2003, \"Tommy Wiseau\", 3.7)\n        expected = \"Titel: The Room\\nErscheinungsjahr: 2003\\nRegisseur: Tommy Wiseau\\nBewertung: 3.7\"\n        self.assertEqual(film_info(film), expected)\n\n    def test_film_mit_hoher_bewertung(self):\n        film = (\"The Godfather\", 1972, \"Francis Ford Coppola\", 9.2)\n        expected = \"Titel: The Godfather\\nErscheinungsjahr: 1972\\nRegisseur: Francis Ford Coppola\\nBewertung: 9.2\"\n        self.assertEqual(film_info(film), expected)\n\n    def test_film_mit_ganzzahliger_bewertung(self):\n        film = (\"A Beautiful Mind\", 2001, \"Ron Howard\", 8.0)\n        expected = \"Titel: A Beautiful Mind\\nErscheinungsjahr: 2001\\nRegisseur: Ron Howard\\nBewertung: 8.0\"\n        self.assertEqual(film_info(film), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 21,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Rugby-Kontext\n\nSchreibe eine Funktion `filter_spieler(spieler_liste, kriterium_funktion)`, die eine Liste von Rugby-Spielern und eine Kriterium-Funktion als Argumente erhält. Die Funktion soll eine neue Liste zurückgeben, die nur die Spieler enthält, die das Kriterium erfüllen.\n\nJeder Spieler wird durch ein Dictionary repräsentiert, das mindestens die folgenden Schlüssel enthält:\n- `name`: Der Name des Spielers (String)\n- `position`: Die Position des Spielers (String)\n- `punkte`: Die Anzahl der erzielten Punkte (Integer)\n\nBeispiel:\n```python\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n]\n\ndef kriterium(spieler):\n    return spieler[\"punkte\"] > 10\n\nresultat = filter_spieler(spieler_liste, kriterium)\n# resultat sollte [{\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15}, {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}] sein\n```\n\nImplementiere die Funktion `filter_spieler(spieler_liste, kriterium_funktion)`.",
    "code_skeleton": "def filter_spieler(spieler_liste, kriterium_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def filter_spieler(spieler_liste, kriterium_funktion):\n    return [spieler for spieler in spieler_liste, if kriterium_funktion(spieler)]\n\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n]\n\ndef kriterium(spieler):\n    return spieler[\"punkte\"] > 10\n\nresultat = filter_spieler(spieler_liste, kriterium)\nprint(resultat)",
    "unit_tests": "import unittest\nfrom main import filter_spieler\n\nclass TestFilterSpieler(unittest.TestCase):\n    def test_alle_spieler_erfüllen_kriterium(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), spieler_liste)\n\n    def test_keiner_erfüllt_kriterium(self):\n        spieler_liste = [\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n            {\"name\": \"Jim\", \"position\": \"Verteidiger\", \"punkte\": 3}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), [])\n\n    def test_einige_erfüllen_kriterium(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        expected_result = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected_result)\n\n    def test_leere_liste(self):\n        spieler_liste = []\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), [])\n\n    def test_kriterium_ist_immer_wahr(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return True\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), spieler_liste)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 22,
    "programming_concept": "Rekursion",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Rekursive Berechnung der VR-Welten\n\nIn der virtuellen Realität (VR) können Welten ineinander verschachtelt sein, ähnlich wie bei einem Fraktal. Jede VR-Welt kann eine bestimmte Anzahl von Unterwelten enthalten, und jede dieser Unterwelten kann wiederum weitere Unterwelten enthalten.\n\nSchreibe eine rekursive Funktion `anzahl_unterwelten(welt)`, die die Gesamtanzahl der Unterwelten in einer gegebenen VR-Welt berechnet. Die VR-Welt wird als ein Dictionary dargestellt, wobei der Schlüssel `\"unterwelten\"` eine Liste von weiteren VR-Welten (ebenfalls Dictionaries) enthält.\n\nBeispiel:\n\n```python\nvr_welt = {\n    \"name\": \"Hauptwelt\",\n    \"unterwelten\": [\n        {\n            \"name\": \"Unterwelt 1\",\n            \"unterwelten\": []\n        },\n        {\n            \"name\": \"Unterwelt 2\",\n            \"unterwelten\": [\n                {\n                    \"name\": \"Unterwelt 2.1\",\n                    \"unterwelten\": []\n                }\n            ]\n        }\n    ]\n}\n```\n\nIn diesem Beispiel hat die Hauptwelt zwei direkte Unterwelten und eine weitere Unterwelt in der zweiten Unterwelt, also insgesamt drei Unterwelten.\n\nImplementiere die Funktion `anzahl_unterwelten(welt)`, die die Gesamtanzahl der Unterwelten in der gegebenen VR-Welt berechnet und zurückgibt.\n\nBeispielaufruf:\n\n```python\nprint(anzahl_unterwelten(vr_welt))  # Ausgabe: 3\n```",
    "code_skeleton": "def anzahl_unterwelten(welt):\n    ## Hier Code einfügen",
    "model_solution": "def anzahl_unterwelten(welt):\n    return len(welt[\"unterwelten\"]) + sum(anzahl_unterwelten(uw) for uw in welt[\"unterwelten\"])\n\nvr_welt = {\n    \"name\": \"Hauptwelt\",\n    \"unterwelten\": [\n        {\n            \"name\": \"Unterwelt 1\",\n            \"unterwelten\": []\n        },\n        {\n            \"name\": \"Unterwelt 2\",\n            \"unterwelten\": [\n                {\n                    \"name\": \"Unterwelt 2.1\",\n                    \"unterwelten\": []\n                }\n            ]\n        }\n    ]\n}\n\nprint(anzahl_unterwelten(vr_welt))  # Ausgabe: 3",
    "unit_tests": "import unittest\nfrom main import anzahl_unterwelten\n\nclass TestAnzahlUnterwelten(unittest.TestCase):\n    def test_einfache_welt(self):\n        welt = {\n            \"name\": \"Hauptwelt\",\n            \"unterwelten\": []\n        }\n        self.assertEqual(anzahl_unterwelten(welt), 0)\n\n    def test_welt_mit_einer_unterwelt(self):\n        welt = {\n            \"name\": \"Hauptwelt\",\n            \"unterwelten\": [\n                {\n                    \"name\": \"Unterwelt 1\",\n                    \"unterwelten\": []\n                }\n            ]\n        }\n        self.assertEqual(anzahl_unterwelten(welt), 1)\n\n    def test_welt_mit_mehreren_unterwelten(self):\n        welt = {\n            \"name\": \"Hauptwelt\",\n            \"unterwelten\": [\n                {\n                    \"name\": \"Unterwelt 1\",\n                    \"unterwelten\": []\n                },\n                {\n                    \"name\": \"Unterwelt 2\",\n                    \"unterwelten\": [\n                        {\n                            \"name\": \"Unterwelt 2.1\",\n                            \"unterwelten\": []\n                        }\n                    ]\n                }\n            ]\n        }\n        self.assertEqual(anzahl_unterwelten(welt), 3)\n\n    def test_tief_verschachtelte_welt(self):\n        welt = {\n            \"name\": \"Hauptwelt\",\n            \"unterwelten\": [\n                {\n                    \"name\": \"Unterwelt 1\",\n                    \"unterwelten\": [\n                        {\n                            \"name\": \"Unterwelt 1.1\",\n                            \"unterwelten\": [\n                                {\n                                    \"name\": \"Unterwelt 1.1.1\",\n                                    \"unterwelten\": []\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n        self.assertEqual(anzahl_unterwelten(welt), 3)\n\n    def test_leere_welt(self):\n        welt = {}\n        self.assertEqual(anzahl_unterwelten(welt), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 23,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Rugby-Kontext\n\nSchreibe eine Funktion `filter_spieler(spieler_liste, kriterium_funktion)`, die eine Liste von Rugby-Spielern und eine Kriterium-Funktion als Argumente nimmt. Die Funktion soll eine neue Liste zurückgeben, die nur die Spieler enthält, die das Kriterium erfüllen.\n\nJeder Spieler ist durch ein Dictionary repräsentiert, das mindestens die folgenden Schlüssel enthält:\n- `name`: Der Name des Spielers (String)\n- `position`: Die Position des Spielers (String)\n- `punkte`: Die Anzahl der erzielten Punkte (Integer)\n\nBeispiel:\n```python\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n]\n\ndef kriterium(spieler):\n    return spieler[\"punkte\"] > 10\n\nresultat = filter_spieler(spieler_liste, kriterium)\n# resultat sollte [{\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15}, {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}] sein\n```\n\nImplementiere die Funktion `filter_spieler(spieler_liste, kriterium_funktion)`.",
    "code_skeleton": "def filter_spieler(spieler_liste, kriterium_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def filter_spieler(spieler_liste, kriterium_funktion):\n    return [spieler for spieler in spieler_liste, if kriterium_funktion(spieler)]\n\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n]\n\ndef kriterium(spieler):\n    return spieler[\"punkte\"] > 10\n\nresultat = filter_spieler(spieler_liste, kriterium)\nprint(resultat)",
    "unit_tests": "import unittest\nfrom main import filter_spieler\n\nclass TestFilterSpieler(unittest.TestCase):\n    def test_punkte_groesser_als_10(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        expected = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected)\n\n    def test_position_stuermer(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 5},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return spieler[\"position\"] == \"Stürmer\"\n        expected = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected)\n\n    def test_leere_liste(self):\n        spieler_liste = []\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        expected = []\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected)\n\n    def test_alle_spieler_erfuellen_kriterium(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 12},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        expected = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 15},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 12},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 20}\n        ]\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected)\n\n    def test_keiner_erfuellt_kriterium(self):\n        spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\", \"punkte\": 5},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\", \"punkte\": 3},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\", \"punkte\": 2}\n        ]\n        def kriterium(spieler):\n            return spieler[\"punkte\"] > 10\n        expected = []\n        self.assertEqual(filter_spieler(spieler_liste, kriterium), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 24,
    "programming_concept": "Tupel",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Angeln mit Tupeln\n\nSchreibe eine Funktion namens `fisch_fangen(fische)`, die ein Tupel von Fischarten als Argument erhält. Die Funktion soll die Anzahl der verschiedenen Fischarten im Tupel zählen und ein neues Tupel zurückgeben, das die Fischarten und ihre jeweiligen Häufigkeiten enthält.\n\nBeispielaufruf:\n```python\nfische = (\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\")\nprint(fisch_fangen(fische))\n```\n\nErwartete Ausgabe:\n```python\n((\"Hecht\", 3), (\"Karpfen\", 2), (\"Forelle\", 1))\n```",
    "code_skeleton": "def fisch_fangen(fische):\n    ## Hier Code einfügen",
    "model_solution": "def fisch_fangen(fische):\n    return tuple((fisch, fische.count(fisch)) for fisch in set(fische))\n\nfische = (\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\")\nprint(fisch_fangen(fische))",
    "unit_tests": "import unittest\nfrom main import fisch_fangen\n\nclass TestFischFangen(unittest.TestCase):\n    def test_einfacher_fall(self):\n        fische = (\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\")\n        erwartet = ((\"Hecht\", 3), (\"Karpfen\", 2), (\"Forelle\", 1))\n        self.assertEqual(fisch_fangen(fische), erwartet)\n\n    def test_leeres_tupel(self):\n        fische = ()\n        erwartet = ()\n        self.assertEqual(fisch_fangen(fische), erwartet)\n\n    def test_ein_fisch(self):\n        fische = (\"Hecht\",)\n        erwartet = ((\"Hecht\", 1),)\n        self.assertEqual(fisch_fangen(fische), erwartet)\n\n    def test_alle_unterschiedlich(self):\n        fische = (\"Hecht\", \"Karpfen\", \"Forelle\")\n        erwartet = ((\"Hecht\", 1), (\"Karpfen\", 1), (\"Forelle\", 1))\n        self.assertEqual(fisch_fangen(fische), erwartet)\n\n    def test_gleiche_fische(self):\n        fische = (\"Hecht\", \"Hecht\", \"Hecht\")\n        erwartet = ((\"Hecht\", 3),)\n        self.assertEqual(fisch_fangen(fische), erwartet)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 25,
    "programming_concept": "While-Schleifen",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Gartenarbeit mit While-Schleifen\n\nSchreibe eine Funktion namens `pflanze_giessen(pflanzen)`, die eine Liste von Pflanzen als Argument erhält. Jede Pflanze in der Liste hat einen Wasserstand, der durch eine Zahl dargestellt wird. Die Funktion soll jede Pflanze so lange gießen, bis ihr Wasserstand mindestens 5 erreicht. Der Wasserstand jeder Pflanze erhöht sich bei jedem Gießen um 1. Die Funktion soll die Anzahl der Gießvorgänge für jede Pflanze zurückgeben.\n\nBeispielaufruf:\n```python\npflanzen = [2, 4, 1]\nprint(pflanze_giessen(pflanzen))  # Ausgabe: [3, 1, 4]\n```\n\nIn diesem Beispiel benötigt die erste Pflanze 3 Gießvorgänge, die zweite Pflanze 1 Gießvorgang und die dritte Pflanze 4 Gießvorgänge, um den Wasserstand von mindestens 5 zu erreichen.",
    "code_skeleton": "def pflanze_giessen(pflanzen):\n    ## Hier Code einfügen",
    "model_solution": "def pflanze_giessen(pflanzen):\n    return [max(0, 5 - p) for p in pflanzen]\n\npflanzen = [2, 4, 1]\nprint(pflanze_giessen(pflanzen))",
    "unit_tests": "import unittest\nfrom main import pflanze_giessen\n\nclass TestPflanzeGiessen(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(pflanze_giessen([2, 4, 1]), [3, 1, 4])\n\n    def test_alle_pflanzen_bereits_ausreichend_gegossen(self):\n        self.assertEqual(pflanze_giessen([5, 6, 7]), [0, 0, 0])\n\n    def test_alle_pflanzen_müssen_gegossen_werden(self):\n        self.assertEqual(pflanze_giessen([0, 0, 0]), [5, 5, 5])\n\n    def test_leere_liste(self):\n        self.assertEqual(pflanze_giessen([]), [])\n\n    def test_randbedingungen(self):\n        self.assertEqual(pflanze_giessen([4, 5, 6]), [1, 0, 0])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 26,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerauswahl\n\nSchreibe eine Funktion namens `spielerauswahl(level)`, die basierend auf dem übergebenen Level des Spielers eine entsprechende Nachricht zurückgibt. Die Funktion soll die folgenden Bedingungen berücksichtigen:\n\n- Wenn der Spielerlevel kleiner als 10 ist, soll die Nachricht \"Anfänger: Willkommen in der Welt des Gamings!\" zurückgegeben werden.\n- Wenn der Spielerlevel zwischen 10 und 20 liegt (einschließlich), soll die Nachricht \"Fortgeschrittener: Du machst Fortschritte!\" zurückgegeben werden.\n- Wenn der Spielerlevel größer als 20 ist, soll die Nachricht \"Profi: Du bist ein echter Gamer!\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `spielerauswahl(5)` gibt \"Anfänger: Willkommen in der Welt des Gamings!\" zurück.\n- `spielerauswahl(15)` gibt \"Fortgeschrittener: Du machst Fortschritte!\" zurück.\n- `spielerauswahl(25)` gibt \"Profi: Du bist ein echter Gamer!\" zurück.",
    "code_skeleton": "def spielerauswahl(level):\n    ## Hier Code einfügen",
    "model_solution": "def spielerauswahl(level):\n    if level < 10:\n        return \"Anfänger: Willkommen in der Welt des Gamings!\"\n    elif 10 <= level <= 20:\n        return \"Fortgeschrittener: Du machst Fortschritte!\"\n    else:\n        return \"Profi: Du bist ein echter Gamer!\"\n\n# Beispielaufrufe\nprint(spielerauswahl(5))\nprint(spielerauswahl(15))\nprint(spielerauswahl(25))",
    "unit_tests": "import unittest\nfrom main import spielerauswahl\n\nclass TestSpielerauswahl(unittest.TestCase):\n    def test_anfaenger(self):\n        self.assertEqual(spielerauswahl(5), \"Anfänger: Willkommen in der Welt des Gamings!\")\n\n    def test_fortgeschrittener(self):\n        self.assertEqual(spielerauswahl(15), \"Fortgeschrittener: Du machst Fortschritte!\")\n\n    def test_profi(self):\n        self.assertEqual(spielerauswahl(25), \"Profi: Du bist ein echter Gamer!\")\n\n    def test_grenze_anfaenger(self):\n        self.assertEqual(spielerauswahl(9), \"Anfänger: Willkommen in der Welt des Gamings!\")\n\n    def test_grenze_fortgeschrittener_unter(self):\n        self.assertEqual(spielerauswahl(10), \"Fortgeschrittener: Du machst Fortschritte!\")\n\n    def test_grenze_fortgeschrittener_ober(self):\n        self.assertEqual(spielerauswahl(20), \"Fortgeschrittener: Du machst Fortschritte!\")\n\n    def test_grenze_profi(self):\n        self.assertEqual(spielerauswahl(21), \"Profi: Du bist ein echter Gamer!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 27,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Kontrollstrukturen beim Angeln\n\nSchreibe eine Funktion namens `fisch_fangen(gewicht, laenge)`, die überprüft, ob ein gefangener Fisch die Mindestanforderungen für das Behalten erfüllt. Die Mindestanforderungen sind:\n\n- Das Gewicht des Fisches muss mindestens 1.5 Kilogramm betragen.\n- Die Länge des Fisches muss mindestens 30 Zentimeter betragen.\n\nDie Funktion soll `True` zurückgeben, wenn beide Bedingungen erfüllt sind, und `False`, wenn eine oder beide Bedingungen nicht erfüllt sind.\n\nBeispielaufrufe:\n- `fisch_fangen(2.0, 35)` gibt `True` zurück.\n- `fisch_fangen(1.0, 40)` gibt `False` zurück.\n- `fisch_fangen(1.5, 25)` gibt `False` zurück.",
    "code_skeleton": "def fisch_fangen(gewicht, laenge):\n    ## Hier Code einfügen",
    "model_solution": "def fisch_fangen(gewicht, laenge):\n    return gewicht >= 1.5 and laenge >= 30\n\n# Beispielaufrufe\nprint(fisch_fangen(2.0, 35))  # True\nprint(fisch_fangen(1.0, 40))  # False\nprint(fisch_fangen(1.5, 25))  # False",
    "unit_tests": "import unittest\nfrom main import fisch_fangen\n\nclass TestFischFangen(unittest.TestCase):\n    def test_beide_bedingungen_erfuellt(self):\n        self.assertTrue(fisch_fangen(2.0, 35))\n\n    def test_gewicht_unter_mindestanforderung(self):\n        self.assertFalse(fisch_fangen(1.0, 40))\n\n    def test_laenge_unter_mindestanforderung(self):\n        self.assertFalse(fisch_fangen(1.5, 25))\n\n    def test_beide_bedingungen_nicht_erfuellt(self):\n        self.assertFalse(fisch_fangen(1.0, 20))\n\n    def test_grenzwert_gewicht(self):\n        self.assertTrue(fisch_fangen(1.5, 30))\n\n    def test_grenzwert_laenge(self):\n        self.assertTrue(fisch_fangen(2.0, 30))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 28,
    "programming_concept": "While-Schleifen",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Follower-Zähler\n\nSchreibe eine Funktion namens `follower_zaehler(start_follower, ziel_follower)`, die die Anzahl der Tage berechnet, die benötigt werden, um eine bestimmte Anzahl von Followern auf einer Social-Media-Plattform zu erreichen. \n\n- `start_follower` ist die Anzahl der Follower, die du zu Beginn hast.\n- `ziel_follower` ist die Anzahl der Follower, die du erreichen möchtest.\n\nJeden Tag gewinnst du 10 neue Follower. Die Funktion soll die Anzahl der Tage zurückgeben, die benötigt werden, um die `ziel_follower` zu erreichen oder zu überschreiten.\n\nBeispielaufruf: `follower_zaehler(100, 150)` gibt `5` zurück.",
    "code_skeleton": "def follower_zaehler(start_follower, ziel_follower):\n    ## Hier Code einfügen",
    "model_solution": "def follower_zaehler(start_follower, ziel_follower):\n    return (ziel_follower - start_follower + 9) // 10\n\nprint(follower_zaehler(100, 150))",
    "unit_tests": "import unittest\nfrom main import follower_zaehler\n\nclass TestFollowerZaehler(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(follower_zaehler(100, 150), 5)\n\n    def test_keine_zunahme_noetig(self):\n        self.assertEqual(follower_zaehler(100, 100), 0)\n\n    def test_ein_tag_noetig(self):\n        self.assertEqual(follower_zaehler(100, 109), 1)\n\n    def test_mehrere_tage_noetig(self):\n        self.assertEqual(follower_zaehler(100, 200), 10)\n\n    def test_grosse_zunahme(self):\n        self.assertEqual(follower_zaehler(100, 1000), 90)\n\n    def test_start_und_ziel_gleich(self):\n        self.assertEqual(follower_zaehler(0, 0), 0)\n\n    def test_start_groesser_als_ziel(self):\n        self.assertEqual(follower_zaehler(150, 100), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 29,
    "programming_concept": "Rekursion",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Rekursive Fischzählung\n\nSchreibe eine rekursive Funktion namens `zaehle_fische(see)`, die die Anzahl der Fische in einem See zählt. Der See wird als verschachtelte Liste dargestellt, wobei jede Liste entweder eine Zahl (die Anzahl der Fische in diesem Teil des Sees) oder eine weitere Liste (ein tieferer Teil des Sees) enthält.\n\nBeispiel:\n```python\nsee = [2, [3, [1, 4], 5], [6, 7], 8]\n```\n\nIn diesem Beispiel enthält der See insgesamt 36 Fische.\n\nImplementiere die Funktion `zaehle_fische(see)`, die die Gesamtanzahl der Fische im See zurückgibt.\n\nBeispielaufruf:\n```python\nprint(zaehle_fische(see))  # Ausgabe: 36\n```",
    "code_skeleton": "def zaehle_fische(see):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(see):\n    if isinstance(see, int):\n        return see\n    return sum(zaehle_fische(teil) for teil in see)\n\nsee = [2, [3, [1, 4], 5], [6, 7], 8]\nprint(zaehle_fische(see))  # Ausgabe: 36",
    "unit_tests": "import unittest\n\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_einfacher_see(self):\n        self.assertEqual(zaehle_fische([1, 2, 3]), 6)\n\n    def test_leerer_see(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische([1]), 1)\n\n    def test_verschachtelter_see(self):\n        self.assertEqual(zaehle_fische([1, [2, [3, 4]], 5]), 15)\n\n    def test_tief_verschachtelter_see(self):\n        self.assertEqual(zaehle_fische([1, [2, [3, [4, [5]]]]]), 15)\n\n    def test_gemischter_see(self):\n        self.assertEqual(zaehle_fische([2, [3, [1, 4], 5], [6, 7], 8]), 36)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 30,
    "programming_concept": "Listen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutatenliste für ein Rezept\n\nSchreibe eine Funktion namens `zutaten_hinzufuegen(zutatenliste, neue_zutat)`, die eine Liste von Zutaten und eine neue Zutat als Parameter erhält. Die Funktion soll die neue Zutat zur Zutatenliste hinzufügen und die aktualisierte Liste zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\nneue_zutat = \"Milch\"\nprint(zutaten_hinzufuegen(zutaten, neue_zutat))\n```\n\nErwartete Ausgabe:\n```\n[\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\n```",
    "code_skeleton": "def zutaten_hinzufuegen(zutatenliste, neue_zutat):\n    ## Hier Code einfügen",
    "model_solution": "def zutaten_hinzufuegen(zutatenliste, neue_zutat):\n    zutatenliste.append(neue_zutat)\n    return zutatenliste\n\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\nneue_zutat = \"Milch\"\nprint(zutaten_hinzufuegen(zutaten, neue_zutat))",
    "unit_tests": "import unittest\nfrom main import zutaten_hinzufuegen\n\nclass TestZutatenHinzufuegen(unittest.TestCase):\n    def test_einfache_zutat(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"])\n\n    def test_leere_liste(self):\n        self.assertEqual(zutaten_hinzufuegen([], \"Milch\"), [\"Milch\"])\n\n    def test_mehrere_zutaten(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\"], \"Zucker\"), [\"Mehl\", \"Zucker\"])\n\n    def test_doppelte_zutat(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\"], \"Zucker\"), [\"Mehl\", \"Zucker\", \"Eier\", \"Zucker\"])\n\n    def test_zutat_als_zahl(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\"], 123), [\"Mehl\", \"Zucker\", \"Eier\", 123])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 31,
    "programming_concept": "Listen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutatenliste für ein Rezept\n\nSchreibe eine Funktion namens `zutaten_hinzufuegen(zutaten_liste, neue_zutat)`, die eine Liste von Zutaten und eine neue Zutat als Parameter erhält. Die Funktion soll die neue Zutat zur Zutatenliste hinzufügen und die aktualisierte Liste zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\nneue_zutat = \"Milch\"\naktualisierte_liste = zutaten_hinzufuegen(zutaten, neue_zutat)\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\n```\n\nErstelle außerdem eine Funktion `zutaten_entfernen(zutaten_liste, zu_entfernende_zutat)`, die eine Liste von Zutaten und eine zu entfernende Zutat als Parameter erhält. Die Funktion soll die zu entfernende Zutat aus der Zutatenliste entfernen und die aktualisierte Liste zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\nzu_entfernende_zutat = \"Zucker\"\naktualisierte_liste = zutaten_entfernen(zutaten, zu_entfernende_zutat)\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Eier\", \"Milch\"]\n```\n\nImplementiere beide Funktionen in Python.",
    "code_skeleton": "def zutaten_hinzufuegen(zutaten_liste, neue_zutat):\n    ## Hier Code einfügen\n\ndef zutaten_entfernen(zutaten_liste, zu_entfernende_zutat):\n    ## Hier Code einfügen",
    "model_solution": "def zutaten_hinzufuegen(zutaten_liste, neue_zutat):\n    zutaten_liste.append(neue_zutat)\n    return zutaten_liste\n\ndef zutaten_entfernen(zutaten_liste, zu_entfernende_zutat):\n    zutaten_liste.remove(zu_entfernende_zutat)\n    return zutaten_liste\n\n# Beispielaufrufe\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\nneue_zutat = \"Milch\"\naktualisierte_liste = zutaten_hinzufuegen(zutaten, neue_zutat)\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\n\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\nzu_entfernende_zutat = \"Zucker\"\naktualisierte_liste = zutaten_entfernen(zutaten, zu_entfernende_zutat)\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Eier\", \"Milch\"]",
    "unit_tests": "import unittest\nfrom main import zutaten_hinzufuegen, zutaten_entfernen\n\nclass TestZutaten(unittest.TestCase):\n    def test_zutaten_hinzufuegen_einfach(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"])\n\n    def test_zutaten_hinzufuegen_leere_liste(self):\n        self.assertEqual(zutaten_hinzufuegen([], \"Milch\"), [\"Milch\"])\n\n    def test_zutaten_hinzufuegen_doppelt(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\", \"Milch\"])\n\n    def test_zutaten_entfernen_einfach(self):\n        self.assertEqual(zutaten_entfernen([\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"], \"Zucker\"), [\"Mehl\", \"Eier\", \"Milch\"])\n\n    def test_zutaten_entfernen_letztes_element(self):\n        self.assertEqual(zutaten_entfernen([\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\"])\n\n    def test_zutaten_entfernen_nicht_vorhanden(self):\n        with self.assertRaises(ValueError):\n            zutaten_entfernen([\"Mehl\", \"Zucker\", \"Eier\"], \"Milch\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 32,
    "programming_concept": "Tupel",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Vergnügungspark-Tickets\n\nSchreibe eine Funktion namens `ticket_preise(tickets)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel repräsentiert ein Ticket und enthält zwei Elemente: den Namen des Fahrgeschäfts (als String) und den Preis des Tickets (als Float).\n\nDie Funktion soll die Gesamtkosten aller Tickets berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\ntickets = [(\"Achterbahn\", 5.50), (\"Riesenrad\", 3.75), (\"Geisterbahn\", 4.00)]\nprint(ticket_preise(tickets))  # Ausgabe: 13.25\n```\n\nImplementiere die Funktion `ticket_preise(tickets)`, die die Gesamtkosten der übergebenen Tickets berechnet und zurückgibt.",
    "code_skeleton": "def ticket_preise(tickets):\n    ## Hier Code einfügen",
    "model_solution": "def ticket_preise(tickets):\n    return sum(preis for _, preis in tickets)\n\ntickets = [(\"Achterbahn\", 5.50), (\"Riesenrad\", 3.75), (\"Geisterbahn\", 4.00)]\nprint(ticket_preise(tickets))",
    "unit_tests": "import unittest\nfrom main import ticket_preise\n\nclass TestTicketPreise(unittest.TestCase):\n    def test_einfacher_fall(self):\n        tickets = [(\"Achterbahn\", 5.50), (\"Riesenrad\", 3.75), (\"Geisterbahn\", 4.00)]\n        self.assertEqual(ticket_preise(tickets), 13.25)\n\n    def test_leere_liste(self):\n        tickets = []\n        self.assertEqual(ticket_preise(tickets), 0.0)\n\n    def test_ein_ticket(self):\n        tickets = [(\"Achterbahn\", 5.50)]\n        self.assertEqual(ticket_preise(tickets), 5.50)\n\n    def test_gemischte_preise(self):\n        tickets = [(\"Achterbahn\", 5.50), (\"Riesenrad\", 3.75), (\"Geisterbahn\", 4.00), (\"Karussell\", 2.25)]\n        self.assertEqual(ticket_preise(tickets), 15.50)\n\n    def test_negative_preise(self):\n        tickets = [(\"Achterbahn\", -5.50), (\"Riesenrad\", 3.75)]\n        self.assertEqual(ticket_preise(tickets), -1.75)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 33,
    "programming_concept": "Tupel",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurant-Menü\n\nSchreibe eine Funktion namens `erstelle_menü()`, die ein Tupel mit den Namen von drei verschiedenen Gerichten aus einem Restaurant-Menü zurückgibt. Jedes Gericht soll als String im Tupel enthalten sein. Beispielaufruf: `erstelle_menü()` könnte ein Tupel wie `(\"Pizza Margherita\", \"Spaghetti Carbonara\", \"Tiramisu\")` zurückgeben.\n\n```python\ndef erstelle_menü():\n    # Deine Implementierung hier\n    pass\n```\n\nErstelle außerdem eine Funktion `drucke_menü(menü)`, die das übergebene Menü-Tupel durchläuft und jedes Gericht in einer neuen Zeile ausgibt. Beispielaufruf: `drucke_menü((\"Pizza Margherita\", \"Spaghetti Carbonara\", \"Tiramisu\"))` sollte die Gerichte jeweils in einer neuen Zeile ausgeben.\n\n```python\ndef drucke_menü(menü):\n    # Deine Implementierung hier\n    pass\n```\n\nVerwende die Funktion `erstelle_menü()` und übergebe das zurückgegebene Tupel an die Funktion `drucke_menü()`, um das Menü auf der Konsole auszugeben.",
    "code_skeleton": "def erstelle_menü():\n    ## Hier Code einfügen\n    pass\n\ndef drucke_menü(menü):\n    ## Hier Code einfügen\n    pass",
    "model_solution": "def erstelle_menü():\n    return (\"Pizza Margherita\", \"Spaghetti Carbonara\", \"Tiramisu\")\n\ndef drucke_menü(menü):\n    for gericht in menü:\n        print(gericht)\n\nmenü = erstelle_menü()\ndrucke_menü(menü)",
    "unit_tests": "import unittest\nfrom main import erstelle_menü, drucke_menü\nfrom io import StringIO\nimport sys\n\nclass TestRestaurantMenü(unittest.TestCase):\n    def test_erstelle_menü(self):\n        menü = erstelle_menü()\n        self.assertIsInstance(menü, tuple)\n        self.assertEqual(len(menü), 3)\n        for gericht in menü:\n            self.assertIsInstance(gericht, str)\n\n    def test_drucke_menü(self):\n        menü = (\"Pizza Margherita\", \"Spaghetti Carbonara\", \"Tiramisu\")\n        expected_output = \"Pizza Margherita\\nSpaghetti Carbonara\\nTiramisu\\n\"\n        \n        captured_output = StringIO()\n        sys.stdout = captured_output\n        drucke_menü(menü)\n        sys.stdout = sys.__stdout__\n        \n        self.assertEqual(captured_output.getvalue(), expected_output)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 34,
    "programming_concept": "String",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportarten filtern\n\nSchreibe eine Funktion namens `filter_sportarten(sportarten_liste, filter_buchstabe)`, die eine Liste von Sportarten und einen Buchstaben als Parameter erhält. Die Funktion soll eine neue Liste zurückgeben, die nur die Sportarten enthält, die mit dem angegebenen Buchstaben beginnen.\n\nBeispielaufruf:\n```python\nsportarten = [\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"]\nresultat = filter_sportarten(sportarten, \"B\")\nprint(resultat)  # Ausgabe: [\"Basketball\", \"Baseball\", \"Badminton\"]\n```\n\nImplementiere die Funktion so, dass sie die gewünschten Ergebnisse liefert.",
    "code_skeleton": "def filter_sportarten(sportarten_liste, filter_buchstabe):\n    ## Hier Code einfügen",
    "model_solution": "def filter_sportarten(sportarten_liste, filter_buchstabe):\n    return [sport for sport in sportarten_liste if sport.startswith(filter_buchstabe)]\n\nsportarten = [\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"]\nresultat = filter_sportarten(sportarten, \"B\")\nprint(resultat)  # Ausgabe: [\"Basketball\", \"Baseball\", \"Badminton\"]",
    "unit_tests": "import unittest\nfrom main import filter_sportarten\n\nclass TestFilterSportarten(unittest.TestCase):\n    def test_filter_b(self):\n        self.assertEqual(filter_sportarten([\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"], \"B\"), [\"Basketball\", \"Baseball\", \"Badminton\"])\n\n    def test_filter_f(self):\n        self.assertEqual(filter_sportarten([\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"], \"F\"), [\"Fußball\"])\n\n    def test_filter_t(self):\n        self.assertEqual(filter_sportarten([\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"], \"T\"), [\"Tennis\"])\n\n    def test_filter_no_match(self):\n        self.assertEqual(filter_sportarten([\"Basketball\", \"Baseball\", \"Fußball\", \"Tennis\", \"Badminton\"], \"X\"), [])\n\n    def test_empty_list(self):\n        self.assertEqual(filter_sportarten([], \"B\"), [])\n\n    def test_case_sensitivity(self):\n        self.assertEqual(filter_sportarten([\"Basketball\", \"baseball\", \"Fußball\", \"Tennis\", \"badminton\"], \"b\"), [\"baseball\", \"badminton\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 35,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillenvergleich\n\nSchreibe eine Funktion namens `vergleiche_medaillen(land1_gold, land1_silber, land1_bronze, land2_gold, land2_silber, land2_bronze)`, die die Anzahl der gewonnenen Medaillen von zwei Ländern bei den Olympischen Spielen vergleicht und eine entsprechende Nachricht zurückgibt.\n\nDie Funktion soll die Anzahl der Gold-, Silber- und Bronzemedaillen der beiden Länder als Argumente entgegennehmen und folgende Vergleiche durchführen:\n\n1. Wenn ein Land mehr Goldmedaillen hat als das andere, soll die Funktion eine Nachricht zurückgeben, die besagt, welches Land mehr Goldmedaillen gewonnen hat.\n2. Wenn beide Länder gleich viele Goldmedaillen haben, soll die Funktion die Anzahl der Silbermedaillen vergleichen und eine entsprechende Nachricht zurückgeben.\n3. Wenn auch die Anzahl der Silbermedaillen gleich ist, soll die Funktion die Anzahl der Bronzemedaillen vergleichen und eine entsprechende Nachricht zurückgeben.\n4. Wenn beide Länder in allen Medaillenkategorien gleich viele Medaillen haben, soll die Funktion eine Nachricht zurückgeben, die besagt, dass beide Länder gleich viele Medaillen gewonnen haben.\n\nBeispielaufruf:\n```python\nvergleiche_medaillen(10, 5, 3, 8, 7, 2)\n```\n\nErwartete Ausgabe:\n```\nLand 1 hat mehr Goldmedaillen gewonnen.\n```",
    "code_skeleton": "def vergleiche_medaillen(land1_gold, land1_silber, land1_bronze, land2_gold, land2_silber, land2_bronze):\n    ## Hier Code einfügen",
    "model_solution": "def vergleiche_medaillen(land1_gold, land1_silber, land1_bronze, land2_gold, land2_silber, land2_bronze):\n    if land1_gold > land2_gold:\n        print(\"Land 1 hat mehr Goldmedaillen gewonnen.\")\n    elif land1_gold < land2_gold:\n        print(\"Land 2 hat mehr Goldmedaillen gewonnen.\")\n    elif land1_silber > land2_silber:\n        print(\"Land 1 hat mehr Silbermedaillen gewonnen.\")\n    elif land1_silber < land2_silber:\n        print(\"Land 2 hat mehr Silbermedaillen gewonnen.\")\n    elif land1_bronze > land2_bronze:\n        print(\"Land 1 hat mehr Bronzemedaillen gewonnen.\")\n    elif land1_bronze < land2_bronze:\n        print(\"Land 2 hat mehr Bronzemedaillen gewonnen.\")\n    else:\n        print(\"Beide Länder haben gleich viele Medaillen gewonnen.\")\n\nvergleiche_medaillen(10, 5, 3, 8, 7, 2)",
    "unit_tests": "import unittest\n\nfrom main import vergleiche_medaillen\n\nclass TestVergleicheMedaillen(unittest.TestCase):\n    def test_land1_mehr_gold(self):\n        self.assertEqual(vergleiche_medaillen(10, 5, 3, 8, 7, 2), \"Land 1 hat mehr Goldmedaillen gewonnen.\")\n\n    def test_land2_mehr_gold(self):\n        self.assertEqual(vergleiche_medaillen(8, 5, 3, 10, 7, 2), \"Land 2 hat mehr Goldmedaillen gewonnen.\")\n\n    def test_land1_mehr_silber(self):\n        self.assertEqual(vergleiche_medaillen(10, 7, 3, 10, 5, 2), \"Land 1 hat mehr Silbermedaillen gewonnen.\")\n\n    def test_land2_mehr_silber(self):\n        self.assertEqual(vergleiche_medaillen(10, 5, 3, 10, 7, 2), \"Land 2 hat mehr Silbermedaillen gewonnen.\")\n\n    def test_land1_mehr_bronze(self):\n        self.assertEqual(vergleiche_medaillen(10, 5, 4, 10, 5, 3), \"Land 1 hat mehr Bronzemedaillen gewonnen.\")\n\n    def test_land2_mehr_bronze(self):\n        self.assertEqual(vergleiche_medaillen(10, 5, 3, 10, 5, 4), \"Land 2 hat mehr Bronzemedaillen gewonnen.\")\n\n    def test_gleich_viele_medaillen(self):\n        self.assertEqual(vergleiche_medaillen(10, 5, 3, 10, 5, 3), \"Beide Länder haben gleich viele Medaillen gewonnen.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 36,
    "programming_concept": "Funktionen als Variablen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen im Kontext \"Kochen\"\n\nSchreibe eine Funktion `koch_rezept(rezept_name)`, die eine Funktion als Parameter akzeptiert und diese Funktion ausführt. Erstelle zwei Beispielrezepte als Funktionen: `rezept_pasta()` und `rezept_salat()`. \n\n- `rezept_pasta()` soll die Nachricht \"Pasta wird gekocht!\" ausgeben.\n- `rezept_salat()` soll die Nachricht \"Salat wird zubereitet!\" ausgeben.\n\nDie Funktion `koch_rezept(rezept_name)` soll die übergebene Rezeptfunktion ausführen.\n\nBeispielaufrufe:\n```python\nkoch_rezept(rezept_pasta)  # Ausgabe: Pasta wird gekocht!\nkoch_rezept(rezept_salat)  # Ausgabe: Salat wird zubereitet!\n```",
    "code_skeleton": "def koch_rezept(rezept_name):\n    ## Hier Code einfügen\n\ndef rezept_pasta():\n    ## Hier Code einfügen\n\ndef rezept_salat():\n    ## Hier Code einfügen",
    "model_solution": "def koch_rezept(rezept_name):\n    rezept_name()\n\ndef rezept_pasta():\n    print(\"Pasta wird gekocht!\")\n\ndef rezept_salat():\n    print(\"Salat wird zubereitet!\")\n\nkoch_rezept(rezept_pasta)\nkoch_rezept(rezept_salat)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import koch_rezept, rezept_pasta, rezept_salat\n\nclass TestKochRezept(unittest.TestCase):\n    def test_rezept_pasta(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        koch_rezept(rezept_pasta)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Pasta wird gekocht!\")\n\n    def test_rezept_salat(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        koch_rezept(rezept_salat)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Salat wird zubereitet!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 37,
    "programming_concept": "Operationen mit Zahlen",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurantrechnung berechnen\n\nSchreibe eine Funktion namens `berechne_rechnung(preise, trinkgeld_prozent)`, die die Gesamtrechnung für ein Restaurant berechnet. Die Funktion soll eine Liste von Preisen (`preise`) und einen Prozentsatz für das Trinkgeld (`trinkgeld_prozent`) als Argumente erhalten. Die Funktion soll die Gesamtsumme der Preise berechnen, das Trinkgeld basierend auf dem Prozentsatz hinzufügen und die Gesamtrechnung zurückgeben.\n\nBeispielaufruf:\n```python\npreise = [10.50, 20.75, 8.99]\ntrinkgeld_prozent = 15\nprint(berechne_rechnung(preise, trinkgeld_prozent))  # Erwartete Ausgabe: 45.29\n```\n\nIn diesem Beispiel sind die Preise der bestellten Gerichte 10.50, 20.75 und 8.99. Das Trinkgeld beträgt 15% der Gesamtsumme der Preise. Die Funktion soll die Gesamtrechnung berechnen und zurückgeben.",
    "code_skeleton": "def berechne_rechnung(preise, trinkgeld_prozent):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_rechnung(preise, trinkgeld_prozent):\n    gesamt = sum(preise)\n    trinkgeld = gesamt * (trinkgeld_prozent / 100)\n    return round(gesamt + trinkgeld, 2)\n\npreise = [10.50, 20.75, 8.99]\ntrinkgeld_prozent = 15\nprint(berechne_rechnung(preise, trinkgeld_prozent))",
    "unit_tests": "import unittest\nfrom main import berechne_rechnung\n\nclass TestBerechneRechnung(unittest.TestCase):\n    def test_einfache_rechnung(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 15\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 45.29)\n\n    def test_keine_preise(self):\n        preise = []\n        trinkgeld_prozent = 15\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 0.00)\n\n    def test_kein_trinkgeld(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 0\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 40.24)\n\n    def test_hohes_trinkgeld(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 100\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 80.48)\n\n    def test_rundung(self):\n        preise = [10.333, 20.666, 8.999]\n        trinkgeld_prozent = 10\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 43.22)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 38,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rezeptauswahl basierend auf Zutaten\n\nSchreibe eine Funktion namens `rezept_auswahl(zutaten)`, die basierend auf einer Liste von Zutaten entscheidet, welches Rezept gekocht werden kann. Die Funktion soll die folgenden Rezepte berücksichtigen:\n\n- **Pasta**: Wenn sowohl \"Nudeln\" als auch \"Tomatensauce\" in der Zutatenliste enthalten sind.\n- **Salat**: Wenn sowohl \"Salat\" als auch \"Tomaten\" in der Zutatenliste enthalten sind.\n- **Omelette**: Wenn sowohl \"Eier\" als auch \"Milch\" in der Zutatenliste enthalten sind.\n\nDie Funktion soll den Namen des Rezepts als String zurückgeben, das gekocht werden kann. Wenn keine der Zutatenkombinationen vorhanden ist, soll die Funktion \"Kein Rezept gefunden\" zurückgeben.\n\nBeispielaufrufe:\n\n```python\nprint(rezept_auswahl([\"Nudeln\", \"Tomatensauce\", \"Käse\"]))  # Ausgabe: \"Pasta\"\nprint(rezept_auswahl([\"Salat\", \"Tomaten\", \"Gurke\"]))        # Ausgabe: \"Salat\"\nprint(rezept_auswahl([\"Eier\", \"Milch\", \"Käse\"]))            # Ausgabe: \"Omelette\"\nprint(rezept_auswahl([\"Brot\", \"Butter\"]))                   # Ausgabe: \"Kein Rezept gefunden\"\n```",
    "code_skeleton": "def rezept_auswahl(zutaten):\n    ## Hier Code einfügen",
    "model_solution": "def rezept_auswahl(zutaten):\n    if \"Nudeln\" in zutaten and \"Tomatensauce\" in zutaten:\n        return \"Pasta\"\n    elif \"Salat\" in zutaten and \"Tomaten\" in zutaten:\n        return \"Salat\"\n    elif \"Eier\" in zutaten and \"Milch\" in zutaten:\n        return \"Omelette\"\n    return \"Kein Rezept gefunden\"\n\nprint(rezept_auswahl([\"Nudeln\", \"Tomatensauce\", \"Käse\"]))\nprint(rezept_auswahl([\"Salat\", \"Tomaten\", \"Gurke\"]))\nprint(rezept_auswahl([\"Eier\", \"Milch\", \"Käse\"]))\nprint(rezept_auswahl([\"Brot\", \"Butter\"]))",
    "unit_tests": "import unittest\nfrom main import rezept_auswahl\n\nclass TestRezeptAuswahl(unittest.TestCase):\n    def test_pasta(self):\n        self.assertEqual(rezept_auswahl([\"Nudeln\", \"Tomatensauce\", \"Käse\"]), \"Pasta\")\n\n    def test_salat(self):\n        self.assertEqual(rezept_auswahl([\"Salat\", \"Tomaten\", \"Gurke\"]), \"Salat\")\n\n    def test_omelette(self):\n        self.assertEqual(rezept_auswahl([\"Eier\", \"Milch\", \"Käse\"]), \"Omelette\")\n\n    def test_kein_rezept(self):\n        self.assertEqual(rezept_auswahl([\"Brot\", \"Butter\"]), \"Kein Rezept gefunden\")\n\n    def test_leere_liste(self):\n        self.assertEqual(rezept_auswahl([]), \"Kein Rezept gefunden\")\n\n    def test_unvollstaendige_zutaten(self):\n        self.assertEqual(rezept_auswahl([\"Nudeln\"]), \"Kein Rezept gefunden\")\n        self.assertEqual(rezept_auswahl([\"Tomatensauce\"]), \"Kein Rezept gefunden\")\n        self.assertEqual(rezept_auswahl([\"Salat\"]), \"Kein Rezept gefunden\")\n        self.assertEqual(rezept_auswahl([\"Tomaten\"]), \"Kein Rezept gefunden\")\n        self.assertEqual(rezept_auswahl([\"Eier\"]), \"Kein Rezept gefunden\")\n        self.assertEqual(rezept_auswahl([\"Milch\"]), \"Kein Rezept gefunden\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 39,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillen\n\nSchreibe eine Funktion namens `medaillen_auswertung(anzahl_gold, anzahl_silber, anzahl_bronze)`, die die Anzahl der gewonnenen Medaillen eines Landes bei den Olympischen Spielen auswertet und eine entsprechende Nachricht zurückgibt.\n\n- Wenn das Land mindestens 10 Goldmedaillen gewonnen hat, soll die Nachricht \"Hervorragende Leistung!\" zurückgegeben werden.\n- Wenn das Land mindestens 5 Goldmedaillen und mindestens 5 Silbermedaillen gewonnen hat, soll die Nachricht \"Sehr gute Leistung!\" zurückgegeben werden.\n- Wenn das Land mindestens 3 Goldmedaillen, 3 Silbermedaillen und 3 Bronzemedaillen gewonnen hat, soll die Nachricht \"Gute Leistung!\" zurückgegeben werden.\n- In allen anderen Fällen soll die Nachricht \"Teilnahme ist alles!\" zurückgegeben werden.\n\nBeispielaufruf:\n```python\nprint(medaillen_auswertung(12, 4, 3))  # Ausgabe: Hervorragende Leistung!\nprint(medaillen_auswertung(6, 5, 2))   # Ausgabe: Sehr gute Leistung!\nprint(medaillen_auswertung(3, 3, 3))   # Ausgabe: Gute Leistung!\nprint(medaillen_auswertung(1, 2, 1))   # Ausgabe: Teilnahme ist alles!\n```",
    "code_skeleton": "def medaillen_auswertung(anzahl_gold, anzahl_silber, anzahl_bronze):\n    ## Hier Code einfügen",
    "model_solution": "def medaillen_auswertung(anzahl_gold, anzahl_silber, anzahl_bronze):\n    if anzahl_gold >= 10:\n        return \"Hervorragende Leistung!\"\n    elif anzahl_gold >= 5 and anzahl_silber >= 5:\n        return \"Sehr gute Leistung!\"\n    elif anzahl_gold >= 3 and anzahl_silber >= 3 and anzahl_bronze >= 3:\n        return \"Gute Leistung!\"\n    else:\n        return \"Teilnahme ist alles!\"\n\nprint(medaillen_auswertung(12, 4, 3))\nprint(medaillen_auswertung(6, 5, 2))\nprint(medaillen_auswertung(3, 3, 3))\nprint(medaillen_auswertung(1, 2, 1))",
    "unit_tests": "import unittest\nfrom main import medaillen_auswertung\n\nclass TestMedaillenAuswertung(unittest.TestCase):\n    def test_hervorragende_leistung(self):\n        self.assertEqual(medaillen_auswertung(12, 4, 3), \"Hervorragende Leistung!\")\n\n    def test_sehr_gute_leistung(self):\n        self.assertEqual(medaillen_auswertung(6, 5, 2), \"Sehr gute Leistung!\")\n\n    def test_gute_leistung(self):\n        self.assertEqual(medaillen_auswertung(3, 3, 3), \"Gute Leistung!\")\n\n    def test_teilnahme_ist_alles(self):\n        self.assertEqual(medaillen_auswertung(1, 2, 1), \"Teilnahme ist alles!\")\n\n    def test_grenzfall_hervorragende_leistung(self):\n        self.assertEqual(medaillen_auswertung(10, 0, 0), \"Hervorragende Leistung!\")\n\n    def test_grenzfall_sehr_gute_leistung(self):\n        self.assertEqual(medaillen_auswertung(5, 5, 0), \"Sehr gute Leistung!\")\n\n    def test_grenzfall_gute_leistung(self):\n        self.assertEqual(medaillen_auswertung(3, 3, 3), \"Gute Leistung!\")\n\n    def test_grenzfall_teilnahme_ist_alles(self):\n        self.assertEqual(medaillen_auswertung(2, 2, 2), \"Teilnahme ist alles!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 40,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Benutzerstatus\n\nSchreibe eine Funktion namens `benutzer_status(anzahl_follower)`, die den Status eines Benutzers auf einer sozialen Medienplattform basierend auf der Anzahl seiner Follower bestimmt. Die Funktion soll eine entsprechende Nachricht mit `return` zurückgeben.\n\n- Wenn die Anzahl der Follower weniger als 100 beträgt, soll die Nachricht \"Neuling\" zurückgegeben werden.\n- Wenn die Anzahl der Follower zwischen 100 und 1000 liegt (einschließlich), soll die Nachricht \"Aufstrebend\" zurückgegeben werden.\n- Wenn die Anzahl der Follower mehr als 1000 beträgt, soll die Nachricht \"Influencer\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `benutzer_status(50)` gibt \"Neuling\" zurück.\n- `benutzer_status(500)` gibt \"Aufstrebend\" zurück.\n- `benutzer_status(1500)` gibt \"Influencer\" zurück.",
    "code_skeleton": "def benutzer_status(anzahl_follower):\n    ## Hier Code einfügen",
    "model_solution": "def benutzer_status(anzahl_follower):\n    if anzahl_follower < 100:\n        return \"Neuling\"\n    elif anzahl_follower <= 1000:\n        return \"Aufstrebend\"\n    else:\n        return \"Influencer\"\n\n# Beispielaufrufe\nprint(benutzer_status(50))    # Neuling\nprint(benutzer_status(500))   # Aufstrebend\nprint(benutzer_status(1500))  # Influencer",
    "unit_tests": "import unittest\n\nfrom main import benutzer_status\n\nclass TestBenutzerStatus(unittest.TestCase):\n    def test_neuling(self):\n        self.assertEqual(benutzer_status(50), \"Neuling\")\n\n    def test_aufstrebend(self):\n        self.assertEqual(benutzer_status(500), \"Aufstrebend\")\n\n    def test_influencer(self):\n        self.assertEqual(benutzer_status(1500), \"Influencer\")\n\n    def test_grenze_neuling_aufstrebend(self):\n        self.assertEqual(benutzer_status(100), \"Aufstrebend\")\n\n    def test_grenze_aufstrebend_influencer(self):\n        self.assertEqual(benutzer_status(1000), \"Aufstrebend\")\n\n    def test_null_follower(self):\n        self.assertEqual(benutzer_status(0), \"Neuling\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 41,
    "programming_concept": "Rekursion",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Rekursive Medaillenzählung\n\nSchreibe eine rekursive Funktion namens `medaillen_zaehlen(medaillen)`, die die Gesamtzahl der Medaillen berechnet, die ein Land bei den Olympischen Spielen gewonnen hat. Die Medaillen werden in einer Liste übergeben, wobei jede Medaille als ein String (\"Gold\", \"Silber\" oder \"Bronze\") repräsentiert wird.\n\nBeispielaufruf:\n```python\nmedaillen = [\"Gold\", \"Silber\", \"Bronze\", \"Gold\", \"Silber\"]\nprint(medaillen_zaehlen(medaillen))  # Ausgabe: 5\n```\n\nImplementiere die Funktion so, dass sie rekursiv arbeitet.",
    "code_skeleton": "def medaillen_zaehlen(medaillen):\n    ## Hier Code einfügen",
    "model_solution": "def medaillen_zaehlen(medaillen):\n    if not medaillen:\n        return 0\n    return 1 + medaillen_zaehlen(medaillen[1:])\n\nmedaillen = [\"Gold\", \"Silber\", \"Bronze\", \"Gold\", \"Silber\"]\nprint(medaillen_zaehlen(medaillen))  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import medaillen_zaehlen\n\nclass TestMedaillenZaehlen(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(medaillen_zaehlen([]), 0)\n\n    def test_eine_medaille(self):\n        self.assertEqual(medaillen_zaehlen([\"Gold\"]), 1)\n\n    def test_mehrere_medaille(self):\n        self.assertEqual(medaillen_zaehlen([\"Gold\", \"Silber\", \"Bronze\", \"Gold\", \"Silber\"]), 5)\n\n    def test_nur_gold(self):\n        self.assertEqual(medaillen_zaehlen([\"Gold\", \"Gold\", \"Gold\"]), 3)\n\n    def test_nur_silber(self):\n        self.assertEqual(medaillen_zaehlen([\"Silber\", \"Silber\"]), 2)\n\n    def test_nur_bronze(self):\n        self.assertEqual(medaillen_zaehlen([\"Bronze\"]), 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 42,
    "programming_concept": "Listen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Highscore-Liste\n\nSchreibe eine Funktion namens `aktualisiere_highscore(liste, neuer_score)`, die eine Liste von Highscores und einen neuen Score als Argumente erhält. Die Funktion soll den neuen Score in die Liste einfügen und die Liste anschließend in absteigender Reihenfolge sortieren. Wenn die Liste mehr als 10 Einträge enthält, soll der niedrigste Score entfernt werden, sodass die Liste immer nur die Top 10 Scores enthält. Die Funktion soll die aktualisierte Highscore-Liste zurückgeben.\n\nBeispielaufruf:\n```python\nhighscores = [1000, 950, 900, 850, 800, 750, 700, 650, 600, 550]\nneuer_score = 920\nprint(aktualisiere_highscore(highscores, neuer_score))\n```\n\nErwartete Ausgabe:\n```\n[1000, 950, 920, 900, 850, 800, 750, 700, 650, 600]\n```",
    "code_skeleton": "def aktualisiere_highscore(liste, neuer_score):\n    ## Hier Code einfügen",
    "model_solution": "def aktualisiere_highscore(liste, neuer_score):\n    liste.append(neuer_score)\n    liste.sort(reverse=True)\n    return liste[:10]\n\nhighscores = [1000, 950, 900, 850, 800, 750, 700, 650, 600, 550]\nneuer_score = 920\nprint(aktualisiere_highscore(highscores, neuer_score))",
    "unit_tests": "import unittest\nfrom main import aktualisiere_highscore\n\nclass TestAktualisiereHighscore(unittest.TestCase):\n    def test_neuer_score_mittendrin(self):\n        self.assertEqual(aktualisiere_highscore([1000, 950, 900, 850, 800, 750, 700, 650, 600, 550], 920), [1000, 950, 920, 900, 850, 800, 750, 700, 650, 600])\n\n    def test_neuer_score_hoechster(self):\n        self.assertEqual(aktualisiere_highscore([1000, 950, 900, 850, 800, 750, 700, 650, 600, 550], 1050), [1050, 1000, 950, 900, 850, 800, 750, 700, 650, 600])\n\n    def test_neuer_score_niedrigster(self):\n        self.assertEqual(aktualisiere_highscore([1000, 950, 900, 850, 800, 750, 700, 650, 600, 550], 500), [1000, 950, 900, 850, 800, 750, 700, 650, 600, 550])\n\n    def test_neuer_score_zehnter(self):\n        self.assertEqual(aktualisiere_highscore([1000, 950, 900, 850, 800, 750, 700, 650, 600, 550], 550), [1000, 950, 900, 850, 800, 750, 700, 650, 600, 550])\n\n    def test_leere_liste(self):\n        self.assertEqual(aktualisiere_highscore([], 500), [500])\n\n    def test_weniger_als_zehn_scores(self):\n        self.assertEqual(aktualisiere_highscore([1000, 950, 900], 850), [1000, 950, 900, 850])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 43,
    "programming_concept": "Float",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Berechnung der VR-Renderzeit\n\nIn der virtuellen Realität (VR) ist es wichtig, dass die Renderzeit pro Frame möglichst gering ist, um eine flüssige und realistische Darstellung zu gewährleisten. Die Renderzeit wird oft in Millisekunden (ms) gemessen.\n\nSchreibe eine Funktion namens `berechne_renderzeit(frames, gesamtzeit)`, die die durchschnittliche Renderzeit pro Frame berechnet. Die Funktion soll zwei Parameter entgegennehmen:\n- `frames`: Die Anzahl der gerenderten Frames (ganzzahliger Wert).\n- `gesamtzeit`: Die gesamte Renderzeit in Millisekunden (Fließkommawert).\n\nDie Funktion soll die durchschnittliche Renderzeit pro Frame als Fließkommawert zurückgeben.\n\nBeispielaufruf:\n```python\ndurchschnitt = berechne_renderzeit(240, 5000.0)\nprint(durchschnitt)  # Erwartete Ausgabe: 20.833333333333332\n```",
    "code_skeleton": "def berechne_renderzeit(frames, gesamtzeit):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_renderzeit(frames, gesamtzeit):\n    return gesamtzeit / frames\n\ndurchschnitt = berechne_renderzeit(240, 5000.0)\nprint(durchschnitt)",
    "unit_tests": "import unittest\n\nfrom main import berechne_renderzeit\n\nclass TestBerechneRenderzeit(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertAlmostEqual(berechne_renderzeit(240, 5000.0), 20.833333333333332)\n\n    def test_null_frames(self):\n        with self.assertRaises(ZeroDivisionError):\n            berechne_renderzeit(0, 5000.0)\n\n    def test_null_gesamtzeit(self):\n        self.assertEqual(berechne_renderzeit(240, 0.0), 0.0)\n\n    def test_ein_frame(self):\n        self.assertEqual(berechne_renderzeit(1, 5000.0), 5000.0)\n\n    def test_grosse_werte(self):\n        self.assertAlmostEqual(berechne_renderzeit(1000000, 5000000.0), 5.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 44,
    "programming_concept": "String",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungen und Strings\n\nSchreibe eine Funktion namens `beziehungsstatus(status)`, die den Beziehungsstatus einer Person als String entgegennimmt und eine entsprechende Nachricht zurückgibt. Die möglichen Beziehungsstatus sind:\n\n- \"Single\"\n- \"Vergeben\"\n- \"Verheiratet\"\n- \"Es ist kompliziert\"\n\nDie Funktion soll je nach Beziehungsstatus eine passende Nachricht zurückgeben:\n\n- Bei \"Single\" soll: \"Genieße deine Freiheit!\" zurückgegeben werden.\n- Bei \"Vergeben\" soll: \"Viel Glück euch beiden!\" zurückgegeben werden.\n- Bei \"Verheiratet\" soll: \"Herzlichen Glückwunsch zur Ehe!\" zurückgegeben werden.\n- Bei \"Es ist kompliziert\" soll: \"Alles Gute für die Zukunft!\" zurückgegeben werden.\n\nBeispielaufruf: `beziehungsstatus(\"Verheiratet\")` gibt \"Herzlichen Glückwunsch zur Ehe!\" zurück.",
    "code_skeleton": "def beziehungsstatus(status):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(status):\n    return {\n        \"Single\": \"Genieße deine Freiheit!\",\n        \"Vergeben\": \"Viel Glück euch beiden!\",\n        \"Verheiratet\": \"Herzlichen Glückwunsch zur Ehe!\",\n        \"Es ist kompliziert\": \"Alles Gute für die Zukunft!\"\n    }.get(status, \"Unbekannter Status\")\n\n# Beispielaufruf\nprint(beziehungsstatus(\"Verheiratet\"))",
    "unit_tests": "import unittest\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_single(self):\n        self.assertEqual(beziehungsstatus(\"Single\"), \"Genieße deine Freiheit!\")\n\n    def test_vergeben(self):\n        self.assertEqual(beziehungsstatus(\"Vergeben\"), \"Viel Glück euch beiden!\")\n\n    def test_verheiratet(self):\n        self.assertEqual(beziehungsstatus(\"Verheiratet\"), \"Herzlichen Glückwunsch zur Ehe!\")\n\n    def test_kompliziert(self):\n        self.assertEqual(beziehungsstatus(\"Es ist kompliziert\"), \"Alles Gute für die Zukunft!\")\n\n    def test_unbekannter_status(self):\n        self.assertEqual(beziehungsstatus(\"Unbekannt\"), \"Unbekannter Status\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 45,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Kontext \"Kochen\"\n\nSchreibe eine Funktion `koch_assistent(rezept, zubereitung)`, die zwei Argumente akzeptiert: eine Liste von Zutaten (`rezept`) und eine Funktion (`zubereitung`), die die Zubereitungsschritte beschreibt. Die Funktion `koch_assistent` soll die Zubereitungsschritte auf jede Zutat anwenden und eine Liste der Ergebnisse zurückgeben.\n\nBeispielaufruf:\n```python\ndef schneide(ingredient):\n    return f\"Schneide {ingredient}\"\n\nzutaten = [\"Tomaten\", \"Zwiebeln\", \"Paprika\"]\nresultat = koch_assistent(zutaten, schneide)\nprint(resultat)  # Ausgabe: [\"Schneide Tomaten\", \"Schneide Zwiebeln\", \"Schneide Paprika\"]\n```\n\nImplementiere die Funktion `koch_assistent` so, dass sie die Zubereitungsschritte auf jede Zutat in der Liste anwendet und die Ergebnisse in einer neuen Liste zurückgibt.",
    "code_skeleton": "def koch_assistent(rezept, zubereitung):\n    ## Hier Code einfügen",
    "model_solution": "def koch_assistent(rezept, zubereitung):\n    return [zubereitung(zutat) for zutat in rezept]\n\ndef schneide(ingredient):\n    return f\"Schneide {ingredient}\"\n\nzutaten = [\"Tomaten\", \"Zwiebeln\", \"Paprika\"]\nresultat = koch_assistent(zutaten, schneide)\nprint(resultat)",
    "unit_tests": "import unittest\nfrom main import koch_assistent\n\ndef schneide(ingredient):\n    return f\"Schneide {ingredient}\"\n\ndef koche(ingredient):\n    return f\"Koche {ingredient}\"\n\nclass TestKochAssistent(unittest.TestCase):\n    def test_schneide(self):\n        zutaten = [\"Tomaten\", \"Zwiebeln\", \"Paprika\"]\n        expected = [\"Schneide Tomaten\", \"Schneide Zwiebeln\", \"Schneide Paprika\"]\n        self.assertEqual(koch_assistent(zutaten, schneide), expected)\n\n    def test_koche(self):\n        zutaten = [\"Kartoffeln\", \"Karotten\"]\n        expected = [\"Koche Kartoffeln\", \"Koche Karotten\"]\n        self.assertEqual(koch_assistent(zutaten, koche), expected)\n\n    def test_leere_liste(self):\n        zutaten = []\n        expected = []\n        self.assertEqual(koch_assistent(zutaten, schneide), expected)\n\n    def test_eine_zutat(self):\n        zutaten = [\"Gurke\"]\n        expected = [\"Schneide Gurke\"]\n        self.assertEqual(koch_assistent(zutaten, schneide), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 46,
    "programming_concept": "Integer",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Filmbewertung\n\nSchreibe eine Funktion namens `bewerte_film(bewertung)`, die eine Bewertung für einen Film entgegennimmt und eine entsprechende Nachricht zurückgibt. Die Bewertung ist ein Integer-Wert zwischen 1 und 10.\n\n- Wenn die Bewertung zwischen 1 und 3 liegt, soll die Nachricht \"Der Film war schlecht.\" zurückgegeben werden.\n- Wenn die Bewertung zwischen 4 und 6 liegt, soll die Nachricht \"Der Film war durchschnittlich.\" zurückgegeben werden.\n- Wenn die Bewertung zwischen 7 und 10 liegt, soll die Nachricht \"Der Film war großartig!\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `bewerte_film(2)` gibt \"Der Film war schlecht.\" zurück.\n- `bewerte_film(5)` gibt \"Der Film war durchschnittlich.\" zurück.\n- `bewerte_film(9)` gibt \"Der Film war großartig!\" zurück.",
    "code_skeleton": "def bewerte_film(bewertung):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_film(bewertung):\n    if 1 <= bewertung <= 3:\n        return \"Der Film war schlecht.\"\n    elif 4 <= bewertung <= 6:\n        return \"Der Film war durchschnittlich.\"\n    elif 7 <= bewertung <= 10:\n        return \"Der Film war großartig!\"\n\n# Beispielaufrufe\nprint(bewerte_film(2))\nprint(bewerte_film(5))\nprint(bewerte_film(9))",
    "unit_tests": "import unittest\nfrom main import bewerte_film\n\nclass TestBewerteFilm(unittest.TestCase):\n    def test_schlecht(self):\n        self.assertEqual(bewerte_film(2), \"Der Film war schlecht.\")\n\n    def test_durchschnittlich(self):\n        self.assertEqual(bewerte_film(5), \"Der Film war durchschnittlich.\")\n\n    def test_grossartig(self):\n        self.assertEqual(bewerte_film(9), \"Der Film war großartig!\")\n\n    def test_unterer_randwert(self):\n        self.assertEqual(bewerte_film(1), \"Der Film war schlecht.\")\n\n    def test_oberer_randwert(self):\n        self.assertEqual(bewerte_film(10), \"Der Film war großartig!\")\n\n    def test_grenze_schlecht_durchschnittlich(self):\n        self.assertEqual(bewerte_film(3), \"Der Film war schlecht.\")\n        self.assertEqual(bewerte_film(4), \"Der Film war durchschnittlich.\")\n\n    def test_grenze_durchschnittlich_grossartig(self):\n        self.assertEqual(bewerte_film(6), \"Der Film war durchschnittlich.\")\n        self.assertEqual(bewerte_film(7), \"Der Film war großartig.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 47,
    "programming_concept": "String",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Angeln und Fische\n\nSchreibe eine Funktion namens `fisch_zaehlen(text)`, die einen Text als Eingabe erhält und die Anzahl der Vorkommen des Wortes \"Fisch\" in diesem Text zurückgibt. Die Funktion soll dabei nicht zwischen Groß- und Kleinschreibung unterscheiden.\n\nBeispielaufruf:\n```python\nfisch_zaehlen(\"Ich habe heute drei Fische gefangen. Fisch ist mein Lieblingsessen.\")\n```\n\nErwartete Ausgabe:\n```\n2\n```",
    "code_skeleton": "def fisch_zaehlen(text):\n    ## Hier Code einfügen",
    "model_solution": "def fisch_zaehlen(text):\n    print(text.lower().count(\"fisch\"))\n\nfisch_zaehlen(\"Ich habe heute drei Fische gefangen. Fisch ist mein Lieblingsessen.\")",
    "unit_tests": "import unittest\n\nfrom main import fisch_zaehlen\n\nclass TestFischZaehlen(unittest.TestCase):\n    def test_einfacher_text(self):\n        self.assertEqual(fisch_zaehlen(\"Ich habe heute drei Fische gefangen. Fisch ist mein Lieblingsessen.\"), 2)\n\n    def test_keine_fische(self):\n        self.assertEqual(fisch_zaehlen(\"Ich habe heute keine Fische gefangen.\"), 1)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(fisch_zaehlen(\"Fisch Fisch Fisch\"), 3)\n\n    def test_gemischte_schreibweise(self):\n        self.assertEqual(fisch_zaehlen(\"fisch Fisch FISCH\"), 3)\n\n    def test_leerer_text(self):\n        self.assertEqual(fisch_zaehlen(\"\"), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 48,
    "programming_concept": "String",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rezeptbeschreibung\n\nSchreibe eine Funktion namens `rezept_beschreibung(rezept)`, die eine Beschreibung eines Rezepts formatiert. Die Funktion soll einen String `rezept` als Eingabe erhalten, der die Zutaten und Zubereitungsschritte enthält. Die Funktion soll den String so formatieren, dass jede Zutat und jeder Zubereitungsschritt in einer neuen Zeile steht. \n\nBeispielaufruf:\n```python\nrezept = \"Zutaten: Mehl, Zucker, Eier, Milch. Zubereitung: Mischen, Backen, Abkühlen.\"\nprint(rezept_beschreibung(rezept))\n```\n\nErwartete Ausgabe:\n```\nZutaten:\nMehl\nZucker\nEier\nMilch\nZubereitung:\nMischen\nBacken\nAbkühlen\n```",
    "code_skeleton": "def rezept_beschreibung(rezept):\n    ## Hier Code einfügen",
    "model_solution": "def rezept_beschreibung(rezept):\n    zutaten, zubereitung = rezept.split(\"Zubereitung:\")\n    zutaten = zutaten.replace(\"Zutaten:\", \"Zutaten:\\n\").replace(\", \", \"\\n\")\n    zubereitung = \"Zubereitung:\\n\" + zubereitung.replace(\", \", \"\\n\")\n    return zutaten + zubereitung\n\nrezept = \"Zutaten: Mehl, Zucker, Eier, Milch. Zubereitung: Mischen, Backen, Abkühlen.\"\nprint(rezept_beschreibung(rezept))",
    "unit_tests": "import unittest\n\nfrom main import rezept_beschreibung\n\nclass TestRezeptBeschreibung(unittest.TestCase):\n    def test_einfaches_rezept(self):\n        rezept = \"Zutaten: Mehl, Zucker, Eier, Milch. Zubereitung: Mischen, Backen, Abkühlen.\"\n        expected = \"Zutaten:\\nMehl\\nZucker\\nEier\\nMilch\\nZubereitung:\\nMischen\\nBacken\\nAbkühlen\"\n        self.assertEqual(rezept_beschreibung(rezept), expected)\n\n    def test_leeres_rezept(self):\n        rezept = \"Zutaten: . Zubereitung: .\"\n        expected = \"Zutaten:\\n\\nZubereitung:\\n\"\n        self.assertEqual(rezept_beschreibung(rezept), expected)\n\n    def test_nur_zutaten(self):\n        rezept = \"Zutaten: Mehl, Zucker. Zubereitung: .\"\n        expected = \"Zutaten:\\nMehl\\nZucker\\nZubereitung:\\n\"\n        self.assertEqual(rezept_beschreibung(rezept), expected)\n\n    def test_nur_zubereitung(self):\n        rezept = \"Zutaten: . Zubereitung: Mischen, Backen.\"\n        expected = \"Zutaten:\\n\\nZubereitung:\\nMischen\\nBacken\"\n        self.assertEqual(rezept_beschreibung(rezept), expected)\n\n    def test_komplexes_rezept(self):\n        rezept = \"Zutaten: Mehl, Zucker, Eier, Milch, Butter, Salz. Zubereitung: Mischen, Kneten, Backen, Abkühlen, Servieren.\"\n        expected = \"Zutaten:\\nMehl\\nZucker\\nEier\\nMilch\\nButter\\nSalz\\nZubereitung:\\nMischen\\nKneten\\nBacken\\nAbkühlen\\nServieren\"\n        self.assertEqual(rezept_beschreibung(rezept), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 49,
    "programming_concept": "Operationen mit Zahlen",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Operationen mit Zahlen im Restaurant\n\nSchreibe eine Funktion namens `berechne_rechnung(preise, trinkgeld_prozent)`, die die Gesamtrechnung für ein Restaurant berechnet. Die Funktion soll eine Liste von Preisen (`preise`) und einen Prozentsatz für das Trinkgeld (`trinkgeld_prozent`) als Argumente erhalten. Die Funktion soll die Gesamtsumme der Preise berechnen, das Trinkgeld basierend auf dem Prozentsatz hinzufügen und den Gesamtbetrag zurückgeben.\n\nBeispielaufruf:\n```python\npreise = [10.50, 20.75, 8.99]\ntrinkgeld_prozent = 15\nprint(berechne_rechnung(preise, trinkgeld_prozent))  # Erwartete Ausgabe: 45.29\n```\n\nIn diesem Beispiel sind die Preise der bestellten Gerichte 10.50, 20.75 und 8.99. Das Trinkgeld beträgt 15% der Gesamtsumme der Preise. Die Funktion soll den Gesamtbetrag inklusive Trinkgeld berechnen und zurückgeben.",
    "code_skeleton": "def berechne_rechnung(preise, trinkgeld_prozent):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_rechnung(preise, trinkgeld_prozent):\n    gesamt = sum(preise)\n    trinkgeld = gesamt * (trinkgeld_prozent / 100)\n    return round(gesamt + trinkgeld, 2)\n\npreise = [10.50, 20.75, 8.99]\ntrinkgeld_prozent = 15\nprint(berechne_rechnung(preise, trinkgeld_prozent))",
    "unit_tests": "import unittest\nfrom main import berechne_rechnung\n\nclass TestBerechneRechnung(unittest.TestCase):\n    def test_einfache_rechnung(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 15\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 45.29)\n\n    def test_keine_preise(self):\n        preise = []\n        trinkgeld_prozent = 15\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 0.00)\n\n    def test_kein_trinkgeld(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 0\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 40.24)\n\n    def test_hohes_trinkgeld(self):\n        preise = [10.50, 20.75, 8.99]\n        trinkgeld_prozent = 100\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 80.48)\n\n    def test_rundung(self):\n        preise = [10.333, 20.666, 8.999]\n        trinkgeld_prozent = 10\n        self.assertEqual(berechne_rechnung(preise, trinkgeld_prozent), 43.22)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 50,
    "programming_concept": "Float",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tiergewicht in Kilogramm\n\nSchreibe eine Funktion namens `gewicht_in_kg(gewicht_pfund)`, die das Gewicht eines Tieres in Pfund (float) als Argument entgegennimmt und das Gewicht in Kilogramm (float) zurückgibt. Beachte, dass 1 Pfund ungefähr 0.453592 Kilogramm entspricht.\n\nBeispielaufruf:\n```python\ngewicht_in_kg(10.0)\n```\nsollte ungefähr `4.53592` zurückgeben.",
    "code_skeleton": "def gewicht_in_kg(gewicht_pfund):\n    ## Hier Code einfügen",
    "model_solution": "def gewicht_in_kg(gewicht_pfund):\n    return gewicht_pfund * 0.453592\n\nprint(gewicht_in_kg(10.0))",
    "unit_tests": "import unittest\n\nfrom main import gewicht_in_kg\n\nclass TestGewichtInKg(unittest.TestCase):\n    def test_zehn_pfund(self):\n        self.assertAlmostEqual(gewicht_in_kg(10.0), 4.53592, places=5)\n\n    def test_null_pfund(self):\n        self.assertEqual(gewicht_in_kg(0.0), 0.0)\n\n    def test_ein_pfund(self):\n        self.assertAlmostEqual(gewicht_in_kg(1.0), 0.453592, places=5)\n\n    def test_negatives_gewicht(self):\n        self.assertAlmostEqual(gewicht_in_kg(-5.0), -2.26796, places=5)\n\n    def test_grosses_gewicht(self):\n        self.assertAlmostEqual(gewicht_in_kg(1000.0), 453.592, places=3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 51,
    "programming_concept": "String",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielertag validieren\n\nSchreibe eine Funktion namens `ist_gueltiger_spielertag(spielertag)`, die überprüft, ob ein gegebener Spielertag (String) den folgenden Kriterien entspricht:\n\n1. Der Spielertag muss zwischen 3 und 16 Zeichen lang sein.\n2. Der Spielertag darf nur alphanumerische Zeichen (Buchstaben und Zahlen) enthalten.\n3. Der Spielertag darf keine Leerzeichen enthalten.\n\nDie Funktion soll `True` zurückgeben, wenn der Spielertag gültig ist, und `False`, wenn er ungültig ist.\n\nBeispielaufrufe:\n- `ist_gueltiger_spielertag(\"Gamer123\")` gibt `True` zurück.\n- `ist_gueltiger_spielertag(\"G@mer\")` gibt `False` zurück.\n- `ist_gueltiger_spielertag(\"Gamer 123\")` gibt `False` zurück.\n- `ist_gueltiger_spielertag(\"G\")` gibt `False` zurück.",
    "code_skeleton": "def ist_gueltiger_spielertag(spielertag):\n    ## Hier Code einfügen",
    "model_solution": "def ist_gueltiger_spielertag(spielertag):\n    return 3 <= len(spielertag) <= 16 and spielertag.isalnum()\n\n# Beispielaufrufe\nprint(ist_gueltiger_spielertag(\"Gamer123\"))  # True\nprint(ist_gueltiger_spielertag(\"G@mer\"))     # False\nprint(ist_gueltiger_spielertag(\"Gamer 123\")) # False\nprint(ist_gueltiger_spielertag(\"G\"))         # False",
    "unit_tests": "import unittest\nfrom main import ist_gueltiger_spielertag\n\nclass TestIstGueltigerSpielertag(unittest.TestCase):\n    def test_gueltiger_spielertag(self):\n        self.assertTrue(ist_gueltiger_spielertag(\"Gamer123\"))\n\n    def test_ungueltiger_spielertag_sonderzeichen(self):\n        self.assertFalse(ist_gueltiger_spielertag(\"G@mer\"))\n\n    def test_ungueltiger_spielertag_leerzeichen(self):\n        self.assertFalse(ist_gueltiger_spielertag(\"Gamer 123\"))\n\n    def test_ungueltiger_spielertag_zu_kurz(self):\n        self.assertFalse(ist_gueltiger_spielertag(\"G\"))\n\n    def test_ungueltiger_spielertag_zu_lang(self):\n        self.assertFalse(ist_gueltiger_spielertag(\"Gamer1234567890123\"))\n\n    def test_gueltiger_spielertag_minimum_laenge(self):\n        self.assertTrue(ist_gueltiger_spielertag(\"abc\"))\n\n    def test_gueltiger_spielertag_maximum_laenge(self):\n        self.assertTrue(ist_gueltiger_spielertag(\"Gamer1234567890\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 52,
    "programming_concept": "Operationen mit Zahlen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Punktestand berechnen\n\nSchreibe eine Funktion namens `berechne_punktestand(zweier, dreier)`, die den Punktestand eines Basketballspiels basierend auf der Anzahl der erzielten Zweipunkte- und Dreipunktewürfe berechnet. Die Funktion soll zwei Argumente entgegennehmen:\n\n- `zweier`: Die Anzahl der erzielten Zweipunktewürfe.\n- `dreier`: Die Anzahl der erzielten Dreipunktewürfe.\n\nDie Funktion soll den gesamten Punktestand berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\npunktestand = berechne_punktestand(10, 5)\nprint(punktestand)  # Ausgabe: 35\n```\n\nIn diesem Beispiel wurden 10 Zweipunktewürfe (10 * 2 = 20 Punkte) und 5 Dreipunktewürfe (5 * 3 = 15 Punkte) erzielt, was insgesamt 35 Punkte ergibt.",
    "code_skeleton": "def berechne_punktestand(zweier, dreier):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punktestand(zweier, dreier):\n    return zweier * 2 + dreier * 3\n\nprint(berechne_punktestand(10, 5))  # Ausgabe: 35",
    "unit_tests": "import unittest\nfrom main import berechne_punktestand\n\nclass TestBerechnePunktestand(unittest.TestCase):\n    def test_kein_punkt(self):\n        self.assertEqual(berechne_punktestand(0, 0), 0)\n\n    def test_nur_zweier(self):\n        self.assertEqual(berechne_punktestand(10, 0), 20)\n\n    def test_nur_dreier(self):\n        self.assertEqual(berechne_punktestand(0, 5), 15)\n\n    def test_gemischt(self):\n        self.assertEqual(berechne_punktestand(10, 5), 35)\n\n    def test_grosse_zahlen(self):\n        self.assertEqual(berechne_punktestand(1000, 500), 3500)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 53,
    "programming_concept": "While-Schleifen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Training\n\nSchreibe eine Funktion namens `basketball_training(ziel_punkte)`, die eine While-Schleife verwendet, um die Anzahl der benötigten Würfe zu berechnen, bis ein Spieler eine bestimmte Anzahl von Punkten erreicht hat. Jeder erfolgreiche Wurf zählt 2 Punkte. Die Funktion soll die Anzahl der Würfe zurückgeben.\n\nBeispielaufruf: `basketball_training(10)` gibt `5` zurück, da 5 erfolgreiche Würfe benötigt werden, um 10 Punkte zu erreichen.",
    "code_skeleton": "def basketball_training(ziel_punkte):\n    ## Hier Code einfügen",
    "model_solution": "def basketball_training(ziel_punkte):\n    punkte, würfe = 0, 0\n    while punkte < ziel_punkte:\n        punkte += 2\n        würfe += 1\n    print(würfe)\n\nbasketball_training(10)",
    "unit_tests": "import unittest\nfrom main import basketball_training\n\nclass TestBasketballTraining(unittest.TestCase):\n    def test_zehn_punkte(self):\n        self.assertEqual(basketball_training(10), 5)\n\n    def test_null_punkte(self):\n        self.assertEqual(basketball_training(0), 0)\n\n    def test_ungerade_punkte(self):\n        self.assertEqual(basketball_training(7), 4)\n\n    def test_grosse_punktezahl(self):\n        self.assertEqual(basketball_training(100), 50)\n\n    def test_negative_punkte(self):\n        self.assertEqual(basketball_training(-5), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 54,
    "programming_concept": "For-Schleifen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Einführung in For-Schleifen im Kontext von Modernem Gaming\n\nSchreibe eine Funktion namens `level_up(punkte_liste)`, die eine Liste von Punktzahlen (Integer) als Argument erhält. Die Funktion soll durch die Liste iterieren und für jede Punktzahl überprüfen, ob sie größer oder gleich 1000 ist. Wenn dies der Fall ist, soll die Funktion die Nachricht \"Level Up!\" ausgeben, andernfalls \"Weiter so!\".\n\nBeispielaufruf:\n```python\nlevel_up([500, 1500, 800, 1200])\n```\n\nErwartete Ausgabe:\n```\nWeiter so!\nLevel Up!\nWeiter so!\nLevel Up!\n```",
    "code_skeleton": "def level_up(punkte_liste):\n    ## Hier Code einfügen",
    "model_solution": "def level_up(punkte_liste):\n    for punkte in punkte_liste:\n        if punkte >= 1000:\n            print(\"Level Up!\")\n        else:\n            print(\"Weiter so!\")\n\nlevel_up([500, 1500, 800, 1200])",
    "unit_tests": "import unittest\nfrom main import level_up\nfrom io import StringIO\nimport sys\n\nclass TestLevelUp(unittest.TestCase):\n    def test_mixed_scores(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        level_up([500, 1500, 800, 1200])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Weiter so!\\nLevel Up!\\nWeiter so!\\nLevel Up!\")\n\n    def test_all_below_threshold(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        level_up([100, 200, 300])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Weiter so!\\nWeiter so!\\nWeiter so!\")\n\n    def test_all_above_threshold(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        level_up([1000, 2000, 3000])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Level Up!\\nLevel Up!\\nLevel Up!\")\n\n    def test_empty_list(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        level_up([])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 55,
    "programming_concept": "Funktionen als Variablen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen im Kontext Sport\n\nSchreibe eine Funktion `sport_auswahl(sportart)`, die eine andere Funktion als Variable zurückgibt. Die zurückgegebene Funktion soll eine Nachricht ausgeben, die spezifisch für die gewählte Sportart ist. \n\nDefiniere mindestens drei verschiedene Sportarten und die entsprechenden Funktionen, die eine Nachricht für jede Sportart ausgeben. \n\nBeispielaufruf:\n```python\nfussball_funktion = sport_auswahl(\"Fussball\")\nfussball_funktion()  # Gibt eine Nachricht für Fussball aus\n\nbasketball_funktion = sport_auswahl(\"Basketball\")\nbasketball_funktion()  # Gibt eine Nachricht für Basketball aus\n```\n\nErwartete Nachrichten könnten sein:\n- Für \"Fussball\": \"Du hast Fussball gewählt! Ein spannendes Spiel auf dem Rasen.\"\n- Für \"Basketball\": \"Du hast Basketball gewählt! Ein dynamisches Spiel auf dem Court.\"\n- Für \"Tennis\": \"Du hast Tennis gewählt! Ein intensives Match auf dem Platz.\"\n\nImplementiere die Funktion `sport_auswahl(sportart)` und die entsprechenden Funktionen für die Sportarten.",
    "code_skeleton": "def sport_auswahl(sportart):\n    ## Hier Code einfügen\n\ndef fussball():\n    ## Hier Code einfügen\n\ndef basketball():\n    ## Hier Code einfügen\n\ndef tennis():\n    ## Hier Code einfügen",
    "model_solution": "def sport_auswahl(sportart):\n    if sportart == \"Fussball\":\n        return fussball\n    elif sportart == \"Basketball\":\n        return basketball\n    elif sportart == \"Tennis\":\n        return tennis\n\ndef fussball():\n    print(\"Du hast Fussball gewählt! Ein spannendes Spiel auf dem Rasen.\")\n\ndef basketball():\n    print(\"Du hast Basketball gewählt! Ein dynamisches Spiel auf dem Court.\")\n\ndef tennis():\n    print(\"Du hast Tennis gewählt! Ein intensives Match auf dem Platz.\")\n\n# Beispielaufrufe\nfussball_funktion = sport_auswahl(\"Fussball\")\nfussball_funktion()\n\nbasketball_funktion = sport_auswahl(\"Basketball\")\nbasketball_funktion()\n\ntennis_funktion = sport_auswahl(\"Tennis\")\ntennis_funktion()",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import sport_auswahl\n\nclass TestSportAuswahl(unittest.TestCase):\n    def test_fussball(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        func = sport_auswahl(\"Fussball\")\n        func()\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Du hast Fussball gewählt! Ein spannendes Spiel auf dem Rasen.\")\n\n    def test_basketball(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        func = sport_auswahl(\"Basketball\")\n        func()\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Du hast Basketball gewählt! Ein dynamisches Spiel auf dem Court.\")\n\n    def test_tennis(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        func = sport_auswahl(\"Tennis\")\n        func()\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Du hast Tennis gewählt! Ein intensives Match auf dem Platz.\")\n\n    def test_unbekannte_sportart(self):\n        self.assertIsNone(sport_auswahl(\"Handball\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 56,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Kontext psychischer Gesundheit\n\nSchreibe eine Funktion `filter_positive_thoughts(thoughts, filter_function)`, die eine Liste von Gedanken (`thoughts`) und eine Filterfunktion (`filter_function`) als Argumente nimmt. Die Funktion soll die `filter_function` auf jeden Gedanken anwenden und nur die positiven Gedanken zurückgeben.\n\nEin Gedanke wird als positiv betrachtet, wenn die `filter_function` für diesen Gedanken `True` zurückgibt.\n\nBeispielaufruf:\n```python\ndef is_positive(thought):\n    positive_keywords = [\"glücklich\", \"zufrieden\", \"erfolgreich\", \"geliebt\"]\n    return any(keyword in thought for keyword in positive_keywords)\n\ngedanken = [\"Ich fühle mich glücklich\", \"Heute war ein anstrengender Tag\", \"Ich bin zufrieden mit meiner Arbeit\", \"Ich fühle mich geliebt\"]\npositive_gedanken = filter_positive_thoughts(gedanken, is_positive)\nprint(positive_gedanken)\n```\n\nErwartete Ausgabe:\n```\n[\"Ich fühle mich glücklich\", \"Ich bin zufrieden mit meiner Arbeit\", \"Ich fühle mich geliebt\"]\n```\n\nImplementiere die Funktion `filter_positive_thoughts(thoughts, filter_function)`.",
    "code_skeleton": "def filter_positive_thoughts(thoughts, filter_function):\n    ## Hier Code einfügen",
    "model_solution": "def filter_positive_thoughts(thoughts, filter_function):\n    return [thought for thought in thoughts if filter_function(thought)]\n\ndef is_positive(thought):\n    positive_keywords = [\"glücklich\", \"zufrieden\", \"erfolgreich\", \"geliebt\"]\n    return any(keyword in thought for keyword in positive_keywords)\n\ngedanken = [\"Ich fühle mich glücklich\", \"Heute war ein anstrengender Tag\", \"Ich bin zufrieden mit meiner Arbeit\", \"Ich fühle mich geliebt\"]\npositive_gedanken = filter_positive_thoughts(gedanken, is_positive)\nprint(positive_gedanken)",
    "unit_tests": "import unittest\nfrom main import filter_positive_thoughts\n\ndef is_positive(thought):\n    positive_keywords = [\"glücklich\", \"zufrieden\", \"erfolgreich\", \"geliebt\"]\n    return any(keyword in thought for keyword in positive_keywords)\n\nclass TestFilterPositiveThoughts(unittest.TestCase):\n    def test_all_positive(self):\n        thoughts = [\"Ich fühle mich glücklich\", \"Ich bin zufrieden\", \"Ich fühle mich geliebt\"]\n        self.assertEqual(filter_positive_thoughts(thoughts, is_positive), thoughts)\n\n    def test_no_positive(self):\n        thoughts = [\"Heute war ein anstrengender Tag\", \"Ich bin müde\", \"Es war ein schlechter Tag\"]\n        self.assertEqual(filter_positive_thoughts(thoughts, is_positive), [])\n\n    def test_mixed_thoughts(self):\n        thoughts = [\"Ich fühle mich glücklich\", \"Heute war ein anstrengender Tag\", \"Ich bin zufrieden mit meiner Arbeit\", \"Ich fühle mich geliebt\"]\n        expected = [\"Ich fühle mich glücklich\", \"Ich bin zufrieden mit meiner Arbeit\", \"Ich fühle mich geliebt\"]\n        self.assertEqual(filter_positive_thoughts(thoughts, is_positive), expected)\n\n    def test_empty_list(self):\n        self.assertEqual(filter_positive_thoughts([], is_positive), [])\n\n    def test_no_keywords(self):\n        thoughts = [\"Ich fühle mich okay\", \"Es war ein Tag\", \"Nichts besonderes\"]\n        self.assertEqual(filter_positive_thoughts(thoughts, is_positive), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 57,
    "programming_concept": "Tupel",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Psychische Gesundheit und Wohlbefinden\n\nSchreibe eine Funktion namens `psychische_gesundheit(daten)`, die ein Tupel mit Informationen zur psychischen Gesundheit einer Person entgegennimmt und eine entsprechende Nachricht zurückgibt. Das Tupel enthält folgende Informationen in dieser Reihenfolge:\n\n1. Name der Person (String)\n2. Anzahl der Stunden Schlaf pro Nacht (Integer)\n3. Anzahl der Stunden körperlicher Aktivität pro Woche (Integer)\n4. Anzahl der Stunden, die mit Entspannungsaktivitäten pro Woche verbracht werden (Integer)\n\nDie Funktion soll eine Nachricht zurückgeben, die den Namen der Person und eine Bewertung ihrer psychischen Gesundheit basierend auf den übergebenen Daten enthält. Beispielaufruf: \n\n```python\npsychische_gesundheit((\"Max\", 7, 5, 3))\n```\n\nDie Funktion könnte eine Nachricht wie folgt zurückgeben:\n\n```python\n\"Max, deine psychische Gesundheit scheint in einem guten Zustand zu sein!\"\n```\n\noder\n\n```python\n\"Max, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\"\n```",
    "code_skeleton": "def psychische_gesundheit(daten):\n    ## Hier Code einfügen",
    "model_solution": "def psychische_gesundheit(daten):\n    name, schlaf, aktivitaet, entspannung = daten\n    if schlaf >= 7 and aktivitaet >= 5 and entspannung >= 3:\n        return f\"{name}, deine psychische Gesundheit scheint in einem guten Zustand zu sein!\"\n    else:\n        return f\"{name, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\"\n\nprint(psychische_gesundheit((\"Max\", 7, 5, 3)))\nprint(psychische_gesundheit((\"Anna\", 6, 4, 2)))",
    "unit_tests": "import unittest\nfrom main import psychische_gesundheit\n\nclass TestPsychischeGesundheit(unittest.TestCase):\n    def test_guter_zustand(self):\n        self.assertEqual(psychische_gesundheit((\"Max\", 7, 5, 3)), \"Max, deine psychische Gesundheit scheint in einem guten Zustand zu sein!\")\n\n    def test_mehr_entspannung_noetig(self):\n        self.assertEqual(psychische_gesundheit((\"Anna\", 6, 4, 2)), \"Anna, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\")\n\n    def test_mehr_schlaf_noetig(self):\n        self.assertEqual(psychische_gesundheit((\"Tom\", 6, 5, 3)), \"Tom, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\")\n\n    def test_mehr_aktivitaet_noetig(self):\n        self.assertEqual(psychische_gesundheit((\"Lisa\", 7, 4, 3)), \"Lisa, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\")\n\n    def test_mehr_entspannung_und_aktivitaet_noetig(self):\n        self.assertEqual(psychische_gesundheit((\"John\", 7, 4, 2)), \"John, es könnte hilfreich sein, mehr Zeit für Entspannung einzuplanen.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 58,
    "programming_concept": "Integer",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Follower-Zähler\n\nSchreibe eine Funktion namens `follower_zaehler(follower_liste)`, die eine Liste von Integern als Argument erhält. Jeder Integer in der Liste repräsentiert die Anzahl der Follower eines Benutzers in einem sozialen Netzwerk. Die Funktion soll die Gesamtanzahl der Follower berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nfollower_zaehler([150, 200, 350, 400])\n```\nsoll `1100` zurückgeben.",
    "code_skeleton": "def follower_zaehler(follower_liste):\n    ## Hier Code einfügen",
    "model_solution": "def follower_zaehler(follower_liste):\n    return sum(follower_liste)\n\nprint(follower_zaehler([150, 200, 350, 400]))",
    "unit_tests": "import unittest\n\nfrom main import follower_zaehler\n\nclass TestFollowerZaehler(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(follower_zaehler([150, 200, 350, 400]), 1100)\n\n    def test_leere_liste(self):\n        self.assertEqual(follower_zaehler([]), 0)\n\n    def test_ein_element(self):\n        self.assertEqual(follower_zaehler([500]), 500)\n\n    def test_negativer_wert(self):\n        self.assertEqual(follower_zaehler([100, -50, 200]), 250)\n\n    def test_gemischte_werte(self):\n        self.assertEqual(follower_zaehler([100, 200, 300, 400, 500]), 1500)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 59,
    "programming_concept": "Rekursion",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rekursive Zubereitung von Pfannkuchen\n\nSchreibe eine rekursive Funktion namens `pfannkuchen_zubereiten(anzahl)`, die die Zubereitung von Pfannkuchen simuliert. Die Funktion soll für jeden Pfannkuchen eine Nachricht ausgeben, dass ein Pfannkuchen zubereitet wird, und dann die Funktion für den nächsten Pfannkuchen aufrufen, bis keine Pfannkuchen mehr übrig sind.\n\nBeispielaufruf: `pfannkuchen_zubereiten(3)` sollte folgende Ausgaben erzeugen:\n```\nPfannkuchen 1 wird zubereitet.\nPfannkuchen 2 wird zubereitet.\nPfannkuchen 3 wird zubereitet.\n```\n\nImplementiere die Funktion so, dass sie die Anzahl der Pfannkuchen als Argument erhält und rekursiv arbeitet.",
    "code_skeleton": "def pfannkuchen_zubereiten(anzahl):\n    ## Hier Code einfügen",
    "model_solution": "def pfannkuchen_zubereiten(anzahl, aktueller=1):\n    if aktueller > anzahl:\n        return\n    print(f'Pfannkuchen {aktueller} wird zubereitet.')\n    pfannkuchen_zubereiten(anzahl, aktueller + 1)\n\npfannkuchen_zubereiten(3)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import pfannkuchen_zubereiten\n\nclass TestPfannkuchenZubereiten(unittest.TestCase):\n    def test_drei_pfannkuchen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        pfannkuchen_zubereiten(3)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Pfannkuchen 1 wird zubereitet.\\nPfannkuchen 2 wird zubereitet.\\nPfannkuchen 3 wird zubereitet.\")\n\n    def test_keine_pfannkuchen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        pfannkuchen_zubereiten(0)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"\")\n\n    def test_ein_pfannkuchen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        pfannkuchen_zubereiten(1)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Pfannkuchen 1 wird zubereitet.\")\n\n    def test_fuenf_pfannkuchen(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        pfannkuchen_zubereiten(5)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Pfannkuchen 1 wird zubereitet.\\nPfannkuchen 2 wird zubereitet.\\nPfannkuchen 3 wird zubereitet.\\nPfannkuchen 4 wird zubereitet.\\nPfannkuchen 5 wird zubereitet.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 60,
    "programming_concept": "Integer",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutaten für ein Rezept berechnen\n\nSchreibe eine Funktion namens `zutaten_berechnen(anzahl_personen)`, die die benötigte Menge an Zutaten für ein Rezept berechnet. Das Rezept ist für 4 Personen ausgelegt und benötigt folgende Zutaten:\n\n- 200 Gramm Mehl\n- 100 Gramm Zucker\n- 2 Eier\n\nDie Funktion soll die Mengen der Zutaten entsprechend der Anzahl der Personen anpassen und eine Nachricht mit den berechneten Mengen zurückgeben. Beispielaufruf: `zutaten_berechnen(2)` gibt \"Für 2 Personen benötigst du: 100 Gramm Mehl, 50 Gramm Zucker, 1 Ei.\" zurück.",
    "code_skeleton": "def zutaten_berechnen(anzahl_personen):\n    ## Hier Code einfügen",
    "model_solution": "def zutaten_berechnen(anzahl_personen):\n    mehl = 200 * anzahl_personen / 4\n    zucker = 100 * anzahl_personen / 4\n    eier = 2 * anzahl_personen / 4\n    print(f\"Für {anzahl_personen} Personen benötigst du: {mehl} Gramm Mehl, {zucker} Gramm Zucker, {eier} Eier.\")\n\nzutaten_berechnen(2)",
    "unit_tests": "import unittest\nfrom main import zutaten_berechnen\n\nclass TestZutatenBerechnen(unittest.TestCase):\n    def test_zwei_personen(self):\n        self.assertEqual(zutaten_berechnen(2), \"Für 2 Personen benötigst du: 100 Gramm Mehl, 50 Gramm Zucker, 1 Ei.\")\n\n    def test_vier_personen(self):\n        self.assertEqual(zutaten_berechnen(4), \"Für 4 Personen benötigst du: 200 Gramm Mehl, 100 Gramm Zucker, 2 Eier.\")\n\n    def test_null_personen(self):\n        self.assertEqual(zutaten_berechnen(0), \"Für 0 Personen benötigst du: 0 Gramm Mehl, 0 Gramm Zucker, 0 Eier.\")\n\n    def test_acht_personen(self):\n        self.assertEqual(zutaten_berechnen(8), \"Für 8 Personen benötigst du: 400 Gramm Mehl, 200 Gramm Zucker, 4 Eier.\")\n\n    def test_negative_personen(self):\n        self.assertEqual(zutaten_berechnen(-2), \"Für -2 Personen benötigst du: -100 Gramm Mehl, -50 Gramm Zucker, -1 Ei.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 61,
    "programming_concept": "Tupel",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Gartenarbeit mit Tupeln\n\nSchreibe eine Funktion namens `pflanzen_info(pflanze)`, die Informationen über verschiedene Pflanzen in einem Garten zurückgibt. Die Informationen über die Pflanzen sollen in einem Tupel gespeichert werden. Jedes Tupel soll den Namen der Pflanze, die benötigte Wassermenge (in Litern pro Woche) und die bevorzugte Sonnenmenge (in Stunden pro Tag) enthalten.\n\nDie Funktion soll ein Tupel mit den Informationen der übergebenen Pflanze zurückgeben. Wenn die Pflanze nicht im Garten vorhanden ist, soll die Funktion `None` zurückgeben.\n\nBeispielaufrufe:\n- `pflanzen_info(\"Tomate\")` könnte `(\"Tomate\", 5, 8)` zurückgeben.\n- `pflanzen_info(\"Rose\")` könnte `(\"Rose\", 3, 6)` zurückgeben.\n- `pflanzen_info(\"Kaktus\")` könnte `None` zurückgeben, wenn \"Kaktus\" nicht im Garten vorhanden ist.",
    "code_skeleton": "def pflanzen_info(pflanze):\n    ## Hier Code einfügen",
    "model_solution": "def pflanzen_info(pflanze):\n    garten = {\n        \"Tomate\": (\"Tomate\", 5, 8),\n        \"Rose\": (\"Rose\", 3, 6),\n        \"Basilikum\": (\"Basilikum\", 2, 6)\n    }\n    return garten.get(pflanze)\n\n# Beispielaufrufe\nprint(pflanzen_info(\"Tomate\"))\nprint(pflanzen_info(\"Rose\"))\nprint(pflanzen_info(\"Kaktus\"))",
    "unit_tests": "import unittest\nfrom main import pflanzen_info\n\nclass TestPflanzenInfo(unittest.TestCase):\n    def test_tomate(self):\n        self.assertEqual(pflanzen_info(\"Tomate\"), (\"Tomate\", 5, 8))\n\n    def test_rose(self):\n        self.assertEqual(pflanzen_info(\"Rose\"), (\"Rose\", 3, 6))\n\n    def test_basilikum(self):\n        self.assertEqual(pflanzen_info(\"Basilikum\"), (\"Basilikum\", 2, 6))\n\n    def test_kaktus(self):\n        self.assertIsNone(pflanzen_info(\"Kaktus\"))\n\n    def test_leerer_string(self):\n        self.assertIsNone(pflanzen_info(\"\"))\n\n    def test_none(self):\n        self.assertIsNone(pflanzen_info(None))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 62,
    "programming_concept": "Listen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Angeln und Listen in Python\n\nSchreibe eine Funktion namens `fange_fische(fische)`, die eine Liste von Fischen als Argument erhält. Die Funktion soll die Anzahl der gefangenen Fische zählen und eine Nachricht zurückgeben, die die Anzahl der Fische angibt.\n\nBeispielaufruf:\n```python\nfange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"])\n```\n\nErwartete Rückgabe:\n```\n\"Du hast 4 Fische gefangen.\"\n```",
    "code_skeleton": "def fange_fische(fische):\n    ## Hier Code einfügen",
    "model_solution": "def fange_fische(fische):\n    print(f\"Du hast {len(fische)} Fische gefangen.\")\n\nfange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"])",
    "unit_tests": "import unittest\nfrom main import fange_fische\n\nclass TestFangeFische(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(fange_fische([]), \"Du hast 0 Fische gefangen.\")\n\n    def test_ein_fisch(self):\n        self.assertEqual(fange_fische([\"Hecht\"]), \"Du hast 1 Fisch gefangen.\")\n\n    def test_mehrere_fische(self):\n        self.assertEqual(fange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"]), \"Du hast 4 Fische gefangen.\")\n\n    def test_viele_fische(self):\n        self.assertEqual(fange_fische([\"Hecht\"] * 100), \"Du hast 100 Fische gefangen.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 63,
    "programming_concept": "String",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Hashtag-Extraktion\n\nSchreibe eine Funktion namens `extrahiere_hashtags(text)`, die alle Hashtags aus einem gegebenen Text extrahiert und als Liste zurückgibt. Ein Hashtag beginnt mit dem Zeichen `#` und endet mit einem Leerzeichen oder dem Ende des Textes. \n\nBeispielaufruf:\n```python\nextrahiere_hashtags(\"Loving the new features of our app! #excited #newrelease #tech\")\n```\n\nsollte die Liste `[\"#excited\", \"#newrelease\", \"#tech\"]` zurückgeben.",
    "code_skeleton": "def extrahiere_hashtags(text):\n    ## Hier Code einfügen",
    "model_solution": "def extrahiere_hashtags(text):\n    return [word for word in text.split() if word.startswith('#')]\n\nprint(extrahiere_hashtags(\"Loving the new features of our app! #excited #newrelease #tech\"))",
    "unit_tests": "import unittest\n\nfrom main import extrahiere_hashtags\n\nclass TestExtrahiereHashtags(unittest.TestCase):\n    def test_einfacher_text(self):\n        self.assertEqual(extrahiere_hashtags(\"Loving the new features of our app! #excited #newrelease #tech\"), [\"#excited\", \"#newrelease\", \"#tech\"])\n\n    def test_text_ohne_hashtags(self):\n        self.assertEqual(extrahiere_hashtags(\"This is a simple text without hashtags.\"), [])\n\n    def test_text_mit_einem_hashtag(self):\n        self.assertEqual(extrahiere_hashtags(\"Check out our new product! #innovation\"), [\"#innovation\"])\n\n    def test_text_mit_hashtags_am_anfang(self):\n        self.assertEqual(extrahiere_hashtags(\"#start your day with a smile! #happy #positive\"), [\"#start\", \"#happy\", \"#positive\"])\n\n    def test_text_mit_hashtags_am_ende(self):\n        self.assertEqual(extrahiere_hashtags(\"End your day with a good book. #reading #relaxing\"), [\"#reading\", \"#relaxing\"])\n\n    def test_text_mit_gemischten_zeichen(self):\n        self.assertEqual(extrahiere_hashtags(\"Coding is fun! #100DaysOfCode #Python3 #AI&ML\"), [\"#100DaysOfCode\", \"#Python3\", \"#AI&ML\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 64,
    "programming_concept": "Tupel",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Statistiken mit Tupeln\n\nSchreibe eine Funktion namens `spieler_statistik(spieler)`, die ein Tupel mit den Statistiken eines Basketballspielers entgegennimmt und eine formatierte Zeichenkette zurückgibt. Das Tupel enthält folgende Informationen in dieser Reihenfolge:\n\n1. Name des Spielers (String)\n2. Anzahl der gespielten Spiele (Integer)\n3. Durchschnittliche Punkte pro Spiel (Float)\n4. Durchschnittliche Rebounds pro Spiel (Float)\n5. Durchschnittliche Assists pro Spiel (Float)\n\nDie Funktion soll eine Zeichenkette im folgenden Format zurückgeben:\n\n```\n\"Spieler: [Name], Spiele: [Anzahl], Punkte/Spiel: [Punkte], Rebounds/Spiel: [Rebounds], Assists/Spiel: [Assists]\"\n```\n\nBeispielaufruf:\n```python\nspieler = (\"LeBron James\", 82, 27.5, 7.4, 7.2)\nprint(spieler_statistik(spieler))\n```\n\nBeispielausgabe:\n```\n\"Spieler: LeBron James, Spiele: 82, Punkte/Spiel: 27.5, Rebounds/Spiel: 7.4, Assists/Spiel: 7.2\"\n```",
    "code_skeleton": "def spieler_statistik(spieler):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_statistik(spieler):\n    return f\"Spieler: {spieler[0]}, Spiele: {spieler[1]}, Punkte/Spiel: {spieler[2]}, Rebounds/Spiel: {spieler[3]}, Assists/Spiel: {spieler[4]}\"\n\nspieler = (\"LeBron James\", 82, 27.5, 7.4, 7.2)\nprint(spieler_statistik(spieler))",
    "unit_tests": "import unittest\nfrom main import spieler_statistik\n\nclass TestSpielerStatistik(unittest.TestCase):\n    def test_standard_fall(self):\n        spieler = (\"LeBron James\", 82, 27.5, 7.4, 7.2)\n        expected = \"Spieler: LeBron James, Spiele: 82, Punkte/Spiel: 27.5, Rebounds/Spiel: 7.4, Assists/Spiel: 7.2\"\n        self.assertEqual(spieler_statistik(spieler), expected)\n\n    def test_anderer_spieler(self):\n        spieler = (\"Michael Jordan\", 82, 30.1, 6.2, 5.3)\n        expected = \"Spieler: Michael Jordan, Spiele: 82, Punkte/Spiel: 30.1, Rebounds/Spiel: 6.2, Assists/Spiel: 5.3\"\n        self.assertEqual(spieler_statistik(spieler), expected)\n\n    def test_wenige_spiele(self):\n        spieler = (\"Kobe Bryant\", 10, 25.0, 5.2, 4.5)\n        expected = \"Spieler: Kobe Bryant, Spiele: 10, Punkte/Spiel: 25.0, Rebounds/Spiel: 5.2, Assists/Spiel: 4.5\"\n        self.assertEqual(spieler_statistik(spieler), expected)\n\n    def test_rundungswerte(self):\n        spieler = (\"Stephen Curry\", 82, 27.456, 5.678, 6.789)\n        expected = \"Spieler: Stephen Curry, Spiele: 82, Punkte/Spiel: 27.456, Rebounds/Spiel: 5.678, Assists/Spiel: 6.789\"\n        self.assertEqual(spieler_statistik(spieler), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 65,
    "programming_concept": "Rekursion",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rekursive Berechnung der Rugby-Punktzahl\n\nIn einem Rugby-Spiel erhält ein Team Punkte durch verschiedene Aktionen:\n\n- Ein Versuch (Try) bringt 5 Punkte.\n- Eine Erhöhung (Conversion) bringt 2 Punkte.\n- Ein Straftritt (Penalty) oder ein Dropgoal bringt jeweils 3 Punkte.\n\nSchreibe eine rekursive Funktion `berechne_punkte(aktionen)`, die eine Liste von Aktionen als Eingabe erhält und die Gesamtpunktzahl des Teams berechnet. Jede Aktion in der Liste ist ein String, der entweder \"Try\", \"Conversion\", \"Penalty\" oder \"Dropgoal\" lautet.\n\nBeispielaufruf:\n```python\naktionen = [\"Try\", \"Conversion\", \"Penalty\", \"Try\", \"Dropgoal\"]\nprint(berechne_punkte(aktionen))  # Ausgabe: 18\n```\n\nImplementiere die Funktion `berechne_punkte(aktionen)`, die die Gesamtpunktzahl des Teams berechnet und zurückgibt.",
    "code_skeleton": "def berechne_punkte(aktionen):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punkte(aktionen):\n    if not aktionen:\n        return 0\n    punkte = {\"Try\": 5, \"Conversion\": 2, \"Penalty\": 3, \"Dropgoal\": 3}\n    return punkte[aktionen[0]] + berechne_punkte(aktionen[1:])\n\naktionen = [\"Try\", \"Conversion\", \"Penalty\", \"Try\", \"Dropgoal\"]\nprint(berechne_punkte(aktionen))",
    "unit_tests": "import unittest\nfrom main import berechne_punkte\n\nclass TestBerechnePunkte(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(berechne_punkte([]), 0)\n\n    def test_nur_try(self):\n        self.assertEqual(berechne_punkte([\"Try\"]), 5)\n\n    def test_nur_conversion(self):\n        self.assertEqual(berechne_punkte([\"Conversion\"]), 2)\n\n    def test_nur_penalty(self):\n        self.assertEqual(berechne_punkte([\"Penalty\"]), 3)\n\n    def test_nur_dropgoal(self):\n        self.assertEqual(berechne_punkte([\"Dropgoal\"]), 3)\n\n    def test_gemischte_aktionen(self):\n        self.assertEqual(berechne_punkte([\"Try\", \"Conversion\", \"Penalty\", \"Try\", \"Dropgoal\"]), 18)\n\n    def test_mehrere_tries(self):\n        self.assertEqual(berechne_punkte([\"Try\", \"Try\", \"Try\"]), 15)\n\n    def test_mehrere_conversions(self):\n        self.assertEqual(berechne_punkte([\"Conversion\", \"Conversion\", \"Conversion\"]), 6)\n\n    def test_mehrere_penalties(self):\n        self.assertEqual(berechne_punkte([\"Penalty\", \"Penalty\", \"Penalty\"]), 9)\n\n    def test_mehrere_dropgoals(self):\n        self.assertEqual(berechne_punkte([\"Dropgoal\", \"Dropgoal\", \"Dropgoal\"]), 9)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 66,
    "programming_concept": "Funktionen als Variablen",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen im Kontext psychischer Gesundheit\n\nSchreibe eine Funktion `psychische_gesundheit(tage)`, die eine Liste von Tagen der Woche als Eingabe erhält. Jeder Tag ist eine Zeichenkette, die den Namen des Tages repräsentiert (z.B. \"Montag\", \"Dienstag\", etc.). Die Funktion soll für jeden Tag eine zufällige Aktivität zur Förderung der psychischen Gesundheit auswählen und zurückgeben. \n\nDefiniere dazu drei separate Funktionen:\n1. `meditation()`: Gibt die Zeichenkette \"Meditation\" zurück.\n2. `spaziergang()`: Gibt die Zeichenkette \"Spaziergang im Park\" zurück.\n3. `lesen()`: Gibt die Zeichenkette \"Ein gutes Buch lesen\" zurück.\n\nDie Funktion `psychische_gesundheit(tage)` soll eine Liste von Aktivitäten zurückgeben, wobei für jeden Tag eine der drei Aktivitäten zufällig ausgewählt wird.\n\nBeispielaufruf:\n```python\nprint(psychische_gesundheit([\"Montag\", \"Dienstag\", \"Mittwoch\"]))\n```\n\nMögliche Ausgabe:\n```python\n[\"Meditation\", \"Spaziergang im Park\", \"Ein gutes Buch lesen\"]\n```",
    "code_skeleton": "def meditation():\n    ## Hier Code einfügen\n\ndef spaziergang():\n    ## Hier Code einfügen\n\ndef lesen():\n    ## Hier Code einfügen\n\ndef psychische_gesundheit(tage):\n    ## Hier Code einfügen",
    "model_solution": "import random\n\ndef meditation():\n    return \"Meditation\"\n\ndef spaziergang():\n    return \"Spaziergang im Park\"\n\ndef lesen():\n    return \"Ein gutes Buch lesen\"\n\ndef psychische_gesundheit(tage):\n    aktivitaeten = [meditation, spaziergang, lesen]\n    return [random.choice(aktivitaeten)() for tag in tage]\n\nprint(psychische_gesundheit([\"Montag\", \"Dienstag\", \"Mittwoch\"]))",
    "unit_tests": "import unittest\nfrom main import meditation, spaziergang, lesen, psychische_gesundheit\n\nclass TestPsychischeGesundheit(unittest.TestCase):\n    def test_meditation(self):\n        self.assertEqual(meditation(), \"Meditation\")\n\n    def test_spaziergang(self):\n        self.assertEqual(spaziergang(), \"Spaziergang im Park\")\n\n    def test_lesen(self):\n        self.assertEqual(lesen(), \"Ein gutes Buch lesen\")\n\n    def test_psychische_gesundheit(self):\n        tage = [\"Montag\", \"Dienstag\", \"Mittwoch\"]\n        result = psychische_gesundheit(tage)\n        self.assertEqual(len(result), len(tage))\n        for aktivitaet in result:\n            self.assertIn(aktivitaet, [\"Meditation\", \"Spaziergang im Park\", \"Ein gutes Buch lesen\"])\n\n    def test_leere_liste(self):\n        self.assertEqual(psychische_gesundheit([]), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 67,
    "programming_concept": "Boolean und None",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Aktivität\n\nSchreibe eine Funktion namens `ist_sportlich(aktivitaet)`, die überprüft, ob eine übergebene Aktivität als sportlich gilt. Die Funktion soll einen Boolean-Wert zurückgeben: `True`, wenn die Aktivität sportlich ist, und `False`, wenn sie es nicht ist. Wenn die Aktivität nicht in der Liste der bekannten Aktivitäten enthalten ist, soll die Funktion `None` zurückgeben.\n\nBekannte sportliche Aktivitäten sind:\n- \"Laufen\"\n- \"Schwimmen\"\n- \"Radfahren\"\n- \"Fußball\"\n- \"Basketball\"\n\nBeispielaufrufe:\n- `ist_sportlich(\"Laufen\")` gibt `True` zurück.\n- `ist_sportlich(\"Schach\")` gibt `False` zurück.\n- `ist_sportlich(\"Tanzen\")` gibt `None` zurück.",
    "code_skeleton": "def ist_sportlich(aktivitaet):\n    ## Hier Code einfügen",
    "model_solution": "def ist_sportlich(aktivitaet):\n    sportliche_aktivitaeten = [\"Laufen\", \"Schwimmen\", \"Radfahren\", \"Fußball\", \"Basketball\"]\n    if aktivitaet in sportliche_aktivitaeten:\n        return True\n    elif aktivitaet in [\"Schach\", \"Tanzen\"]:\n        return False\n    return None\n\n# Beispielaufrufe\nprint(ist_sportlich(\"Laufen\"))  # True\nprint(ist_sportlich(\"Schach\"))  # False\nprint(ist_sportlich(\"Tanzen\"))  # None",
    "unit_tests": "import unittest\nfrom main import ist_sportlich\n\nclass TestIstSportlich(unittest.TestCase):\n    def test_sportliche_aktivitaet(self):\n        self.assertTrue(ist_sportlich(\"Laufen\"))\n        self.assertTrue(ist_sportlich(\"Schwimmen\"))\n        self.assertTrue(ist_sportlich(\"Radfahren\"))\n        self.assertTrue(ist_sportlich(\"Fußball\"))\n        self.assertTrue(ist_sportlich(\"Basketball\"))\n\n    def test_nicht_sportliche_aktivitaet(self):\n        self.assertFalse(ist_sportlich(\"Schach\"))\n\n    def test_unbekannte_aktivitaet(self):\n        self.assertIsNone(ist_sportlich(\"Tanzen\"))\n        self.assertIsNone(ist_sportlich(\"Lesen\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 68,
    "programming_concept": "Rekursion",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Rekursive Musiknoten\n\nSchreibe eine Funktion namens `spiele_notenfolge(notenfolge)`, die eine Liste von Musiknoten (als Strings) rekursiv durchläuft und jede Note in der Konsole ausgibt. Die Funktion soll die Noten in der Reihenfolge ausgeben, in der sie in der Liste erscheinen.\n\nBeispielaufruf:\n```python\nspiele_notenfolge([\"C\", \"D\", \"E\", \"F\", \"G\"])\n```\n\nAusgabe:\n```\nC\nD\nE\nF\nG\n```\n\nImplementiere die Funktion so, dass sie rekursiv arbeitet.",
    "code_skeleton": "def spiele_notenfolge(notenfolge):\n    ## Hier Code einfügen",
    "model_solution": "def spiele_notenfolge(notenfolge):\n    if not notenfolge:\n        return\n    print(notenfolge[0])\n    spiele_notenfolge(notenfolge[1:])\n\nspiele_notenfolge([\"C\", \"D\", \"E\", \"F\", \"G\"])",
    "unit_tests": "import unittest\nfrom unittest.mock import patch\nfrom main import spiele_notenfolge\n\nclass TestSpieleNotenfolge(unittest.TestCase):\n    @patch('builtins.print')\n    def test_einfache_notenfolge(self, mock_print):\n        spiele_notenfolge([\"C\", \"D\", \"E\", \"F\", \"G\"])\n        mock_print.assert_has_calls([unittest.mock.call(\"C\"), unittest.mock.call(\"D\"), unittest.mock.call(\"E\"), unittest.mock.call(\"F\"), unittest.mock.call(\"G\")])\n\n    @patch('builtins.print')\n    def test_leere_notenfolge(self, mock_print):\n        spiele_notenfolge([])\n        mock_print.assert_not_called()\n\n    @patch('builtins.print')\n    def test_eine_note(self, mock_print):\n        spiele_notenfolge([\"A\"])\n        mock_print.assert_called_once_with(\"A\")\n\n    @patch('builtins.print')\n    def test_verschachtelte_notenfolge(self, mock_print):\n        spiele_notenfolge([\"A\", \"B\", \"C\", \"D\", \"E\"])\n        mock_print.assert_has_calls([unittest.mock.call(\"A\"), unittest.mock.call(\"B\"), unittest.mock.call(\"C\"), unittest.mock.call(\"D\"), unittest.mock.call(\"E\")])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 69,
    "programming_concept": "Float",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musik-Streaming-Dauer\n\nSchreibe eine Funktion namens `berechne_spieldauer(lieder)`, die eine Liste von Liedern erhält. Jedes Lied wird durch seine Spieldauer in Minuten als Float-Wert dargestellt. Die Funktion soll die gesamte Spieldauer der Lieder in Stunden berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nlieder = [3.5, 4.2, 5.0, 2.8]\nprint(berechne_spieldauer(lieder))  # Ausgabe: 0.25\n```\n\nHinweis: Die Ausgabe sollte in Stunden und als Float-Wert zurückgegeben werden.",
    "code_skeleton": "def berechne_spieldauer(lieder):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_spieldauer(lieder):\n    return sum(lieder) / 60\n\nlieder = [3.5, 4.2, 5.0, 2.8]\nprint(berechne_spieldauer(lieder))",
    "unit_tests": "import unittest\nfrom main import berechne_spieldauer\n\nclass TestBerechneSpieldauer(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertAlmostEqual(berechne_spieldauer([3.5, 4.2, 5.0, 2.8]), 0.25)\n\n    def test_leere_liste(self):\n        self.assertAlmostEqual(berechne_spieldauer([]), 0.0)\n\n    def test_ein_lied(self):\n        self.assertAlmostEqual(berechne_spieldauer([60.0]), 1.0)\n\n    def test_gemischte_werte(self):\n        self.assertAlmostEqual(berechne_spieldauer([30.0, 45.0, 15.0]), 1.5)\n\n    def test_grosse_werte(self):\n        self.assertAlmostEqual(berechne_spieldauer([120.0, 180.0, 240.0]), 9.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 70,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Kontrollstrukturen beim Angeln\n\nSchreibe eine Funktion namens `fisch_fangen(gewicht, laenge)`, die überprüft, ob ein gefangener Fisch die Mindestanforderungen für das Behalten erfüllt. Ein Fisch darf nur behalten werden, wenn er mindestens 2 kg wiegt und mindestens 30 cm lang ist. Die Funktion soll `True` zurückgeben, wenn der Fisch behalten werden darf, und `False`, wenn nicht.\n\nBeispielaufrufe:\n- `fisch_fangen(2.5, 35)` gibt `True` zurück.\n- `fisch_fangen(1.8, 32)` gibt `False` zurück.\n- `fisch_fangen(2.0, 29)` gibt `False` zurück.",
    "code_skeleton": "def fisch_fangen(gewicht, laenge):\n    ## Hier Code einfügen",
    "model_solution": "def fisch_fangen(gewicht, laenge):\n    return gewicht >= 2 and laenge >= 30\n\n# Beispielaufrufe\nprint(fisch_fangen(2.5, 35))  # True\nprint(fisch_fangen(1.8, 32))  # False\nprint(fisch_fangen(2.0, 29))  # False",
    "unit_tests": "import unittest\nfrom main import fisch_fangen\n\nclass TestFischFangen(unittest.TestCase):\n    def test_fisch_behalten(self):\n        self.assertTrue(fisch_fangen(2.5, 35))\n\n    def test_fisch_zu_leicht(self):\n        self.assertFalse(fisch_fangen(1.8, 32))\n\n    def test_fisch_zu_kurz(self):\n        self.assertFalse(fisch_fangen(2.0, 29))\n\n    def test_fisch_genau_grenze(self):\n        self.assertTrue(fisch_fangen(2.0, 30))\n\n    def test_fisch_unter_grenze(self):\n        self.assertFalse(fisch_fangen(1.9, 29))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 71,
    "programming_concept": "Integer",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Streaming-Dienste und Integer\n\nSchreibe eine Funktion namens `berechne_monatliche_kosten(abonnements)`, die eine Liste von Integern als Argument erhält. Jeder Integer in der Liste repräsentiert die monatlichen Kosten eines Abonnements bei verschiedenen Streaming-Diensten in Euro. Die Funktion soll die Gesamtkosten aller Abonnements berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nabonnements = [10, 15, 8, 12]\nprint(berechne_monatliche_kosten(abonnements))  # Ausgabe: 45\n```",
    "code_skeleton": "def berechne_monatliche_kosten(abonnements):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_monatliche_kosten(abonnements):\n    return sum(abonnements)\n\nabonnements = [10, 15, 8, 12]\nprint(berechne_monatliche_kosten(abonnements))",
    "unit_tests": "import unittest\nfrom main import berechne_monatliche_kosten\n\nclass TestBerechneMonatlicheKosten(unittest.TestCase):\n    def test_mehrere_abonnements(self):\n        self.assertEqual(berechne_monatliche_kosten([10, 15, 8, 12]), 45)\n\n    def test_keine_abonnements(self):\n        self.assertEqual(berechne_monatliche_kosten([]), 0)\n\n    def test_ein_abonnement(self):\n        self.assertEqual(berechne_monatliche_kosten([20]), 20)\n\n    def test_gemischte_abonnements(self):\n        self.assertEqual(berechne_monatliche_kosten([5, 10, 15, 20, 25]), 75)\n\n    def test_negativer_wert(self):\n        self.assertEqual(berechne_monatliche_kosten([10, -5, 15]), 20)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 72,
    "programming_concept": "Integer",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerlevel\n\nIn modernen Videospielen ist das Level eines Spielers oft ein wichtiger Indikator für seinen Fortschritt und seine Fähigkeiten. Schreibe eine Funktion namens `spieler_level(xp)`, die das Level eines Spielers basierend auf seiner Erfahrungspunkte (XP) berechnet und zurückgibt. \n\nDie Level sollen wie folgt berechnet werden:\n- Level 1: 0 - 999 XP\n- Level 2: 1000 - 1999 XP\n- Level 3: 2000 - 2999 XP\n- Level 4: 3000 - 3999 XP\n- Level 5: 4000 - 4999 XP\n- Level 6: 5000 - 5999 XP\n- Level 7: 6000 - 6999 XP\n- Level 8: 7000 - 7999 XP\n- Level 9: 8000 - 8999 XP\n- Level 10: 9000+ XP\n\nBeispielaufruf: `spieler_level(4500)` gibt `5` zurück.",
    "code_skeleton": "def spieler_level(xp):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_level(xp):\n    print(min(xp // 1000 + 1, 10))\n\nspieler_level(4500)",
    "unit_tests": "import unittest\n\nfrom main import spieler_level\n\nclass TestSpielerLevel(unittest.TestCase):\n    def test_level_1(self):\n        self.assertEqual(spieler_level(0), 1)\n        self.assertEqual(spieler_level(999), 1)\n\n    def test_level_2(self):\n        self.assertEqual(spieler_level(1000), 2)\n        self.assertEqual(spieler_level(1999), 2)\n\n    def test_level_3(self):\n        self.assertEqual(spieler_level(2000), 3)\n        self.assertEqual(spieler_level(2999), 3)\n\n    def test_level_4(self):\n        self.assertEqual(spieler_level(3000), 4)\n        self.assertEqual(spieler_level(3999), 4)\n\n    def test_level_5(self):\n        self.assertEqual(spieler_level(4000), 5)\n        self.assertEqual(spieler_level(4999), 5)\n\n    def test_level_6(self):\n        self.assertEqual(spieler_level(5000), 6)\n        self.assertEqual(spieler_level(5999), 6)\n\n    def test_level_7(self):\n        self.assertEqual(spieler_level(6000), 7)\n        self.assertEqual(spieler_level(6999), 7)\n\n    def test_level_8(self):\n        self.assertEqual(spieler_level(7000), 8)\n        self.assertEqual(spieler_level(7999), 8)\n\n    def test_level_9(self):\n        self.assertEqual(spieler_level(8000), 9)\n        self.assertEqual(spieler_level(8999), 9)\n\n    def test_level_10(self):\n        self.assertEqual(spieler_level(9000), 10)\n        self.assertEqual(spieler_level(10000), 10)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 73,
    "programming_concept": "Rekursion",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Rekursive Berechnung der VR-Welt-Tiefe\n\nIn einer virtuellen Realität (VR) gibt es verschiedene Ebenen, die ineinander verschachtelt sind. Jede Ebene kann weitere Unterebenen enthalten, die wiederum weitere Unterebenen enthalten können, und so weiter. Deine Aufgabe ist es, eine Funktion zu schreiben, die die maximale Tiefe dieser verschachtelten Ebenen berechnet.\n\nSchreibe eine Funktion `berechne_tiefe(vr_welt)`, die die Tiefe einer VR-Welt berechnet. Die VR-Welt wird als verschachtelte Liste dargestellt, wobei jede Liste weitere Listen enthalten kann, die die Unterebenen repräsentieren.\n\nBeispiel:\n```python\nvr_welt = [[], [[], []], [[[]]], [[], [[], [[], []]]]]\n```\n\nIn diesem Beispiel hat die VR-Welt eine maximale Tiefe von 4.\n\nImplementiere die Funktion `berechne_tiefe(vr_welt)`, die die maximale Tiefe der VR-Welt als Integer zurückgibt.\n\n```python\ndef berechne_tiefe(vr_welt):\n    # Deine Implementierung hier\n    pass\n```\n\nBeispielaufrufe:\n```python\nprint(berechne_tiefe([[], [[], []], [[[]]], [[], [[], [[], []]]]]))  # Ausgabe: 4\nprint(berechne_tiefe([[], [[], []], [[[]]]]))  # Ausgabe: 3\nprint(berechne_tiefe([[]]))  # Ausgabe: 2\nprint(berechne_tiefe([]))  # Ausgabe: 1\n```",
    "code_skeleton": "def berechne_tiefe(vr_welt):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_tiefe(vr_welt):\n    if not isinstance(vr_welt, list):\n        return 0\n    return 1 + max((berechne_tiefe(ebene) for ebene in vr_welt), default=0)\n\nprint(berechne_tiefe([[], [[], []], [[[]]], [[], [[], [[], []]]]]))  # Ausgabe: 4\nprint(berechne_tiefe([[], [[], []], [[[]]]]))  # Ausgabe: 3\nprint(berechne_tiefe([[]]))  # Ausgabe: 2\nprint(berechne_tiefe([]))  # Ausgabe: 1",
    "unit_tests": "import unittest\nfrom main import berechne_tiefe\n\nclass TestBerechneTiefe(unittest.TestCase):\n    def test_einfache_vr_welt(self):\n        self.assertEqual(berechne_tiefe([[], [[], []], [[[]]], [[], [[], [[], []]]]]), 4)\n\n    def test_mittlere_vr_welt(self):\n        self.assertEqual(berechne_tiefe([[], [[], []], [[[]]]]), 3)\n\n    def test_einfache_verschachtelung(self):\n        self.assertEqual(berechne_tiefe([[]]), 2)\n\n    def test_leere_vr_welt(self):\n        self.assertEqual(berechne_tiefe([]), 1)\n\n    def test_tief_verschachtelte_vr_welt(self):\n        self.assertEqual(berechne_tiefe([[[[[[]]]]]]), 6)\n\n    def test_ohne_verschachtelung(self):\n        self.assertEqual(berechne_tiefe([1, 2, 3]), 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 74,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Rugby-Kontext\n\nSchreibe eine Funktion `filter_spieler(spieler_liste, kriterium_funktion)`, die eine Liste von Rugby-Spielern und eine Funktion als Parameter akzeptiert. Die Funktion soll eine neue Liste zurückgeben, die nur die Spieler enthält, die das Kriterium der übergebenen Funktion erfüllen.\n\nJeder Spieler wird durch ein Dictionary repräsentiert, das mindestens die Schlüssel `name` und `position` enthält.\n\nBeispiel:\n\n```python\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\"},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\"},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\"},\n    {\"name\": \"Paul\", \"position\": \"Verteidiger\"}\n]\n\ndef ist_stuermer(spieler):\n    return spieler[\"position\"] == \"Stürmer\"\n\n# Aufruf der Funktion\nresultat = filter_spieler(spieler_liste, ist_stuermer)\n# Erwartetes Ergebnis: [{\"name\": \"Max\", \"position\": \"Stürmer\"}, {\"name\": \"Leo\", \"position\": \"Stürmer\"}]\n```\n\nImplementiere die Funktion `filter_spieler` und teste sie mit verschiedenen Kriterien.",
    "code_skeleton": "def filter_spieler(spieler_liste, kriterium_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def filter_spieler(spieler_liste, kriterium_funktion):\n    return [spieler for spieler in spieler_liste, if kriterium_funktion(spieler)]\n\nspieler_liste = [\n    {\"name\": \"Max\", \"position\": \"Stürmer\"},\n    {\"name\": \"Tom\", \"position\": \"Verteidiger\"},\n    {\"name\": \"Leo\", \"position\": \"Stürmer\"},\n    {\"name\": \"Paul\", \"position\": \"Verteidiger\"}\n]\n\ndef ist_stuermer(spieler):\n    return spieler[\"position\"] == \"Stürmer\"\n\nresultat = filter_spieler(spieler_liste, ist_stuermer)\nprint(resultat)",
    "unit_tests": "import unittest\nfrom main import filter_spieler\n\nclass TestFilterSpieler(unittest.TestCase):\n    def setUp(self):\n        self.spieler_liste = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\"},\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\"},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\"},\n            {\"name\": \"Paul\", \"position\": \"Verteidiger\"}\n        ]\n\n    def test_ist_stuermer(self):\n        def ist_stuermer(spieler):\n            return spieler[\"position\"] == \"Stürmer\"\n        expected = [\n            {\"name\": \"Max\", \"position\": \"Stürmer\"},\n            {\"name\": \"Leo\", \"position\": \"Stürmer\"}\n        ]\n        self.assertEqual(filter_spieler(self.spieler_liste, ist_stuermer), expected)\n\n    def test_ist_verteidiger(self):\n        def ist_verteidiger(spieler):\n            return spieler[\"position\"] == \"Verteidiger\"\n        expected = [\n            {\"name\": \"Tom\", \"position\": \"Verteidiger\"},\n            {\"name\": \"Paul\", \"position\": \"Verteidiger\"}\n        ]\n        self.assertEqual(filter_spieler(self.spieler_liste, ist_verteidiger), expected)\n\n    def test_leere_liste(self):\n        def ist_stuermer(spieler):\n            return spieler[\"position\"] == \"Stürmer\"\n        self.assertEqual(filter_spieler([], ist_stuermer), [])\n\n    def test_keine_treffer(self):\n        def ist_torwart(spieler):\n            return spieler[\"position\"] == \"Torwart\"\n        self.assertEqual(filter_spieler(self.spieler_liste, ist_torwart), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 75,
    "programming_concept": "Integer",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustiere zählen\n\nSchreibe eine Funktion namens `zaehle_haustiere(hunde, katzen)`, die zwei Integer-Parameter entgegennimmt: die Anzahl der Hunde und die Anzahl der Katzen in einem Haushalt. Die Funktion soll die Gesamtanzahl der Haustiere berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\ngesamt = zaehle_haustiere(3, 2)\nprint(gesamt)  # Ausgabe: 5\n```\n\nIn diesem Beispiel gibt es 3 Hunde und 2 Katzen, was insgesamt 5 Haustiere ergibt.",
    "code_skeleton": "def zaehle_haustiere(hunde, katzen):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_haustiere(hunde, katzen):\n    return hunde + katzen\n\nprint(zaehle_haustiere(3, 2))  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import zaehle_haustiere\n\nclass TestZaehleHaustiere(unittest.TestCase):\n    def test_keine_haustiere(self):\n        self.assertEqual(zaehle_haustiere(0, 0), 0)\n\n    def test_nur_hunde(self):\n        self.assertEqual(zaehle_haustiere(5, 0), 5)\n\n    def test_nur_katzen(self):\n        self.assertEqual(zaehle_haustiere(0, 3), 3)\n\n    def test_hunde_und_katzen(self):\n        self.assertEqual(zaehle_haustiere(2, 4), 6)\n\n    def test_grosse_zahlen(self):\n        self.assertEqual(zaehle_haustiere(1000, 2000), 3000)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 76,
    "programming_concept": "For-Schleifen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Punktestand\n\nSchreibe eine Funktion namens `berechne_punktestand(punkte_liste)`, die eine Liste von erzielten Punkten in einem Basketballspiel als Argument erhält. Die Funktion soll die Gesamtpunktzahl berechnen und zurückgeben. Verwende eine For-Schleife, um die Punkte zu summieren.\n\nBeispielaufruf:\n```python\npunkte = [2, 3, 2, 1, 3, 2]\ngesamtpunktzahl = berechne_punktestand(punkte)\nprint(gesamtpunktzahl)  # Ausgabe: 13\n```\n\nImplementiere die Funktion `berechne_punktestand(punkte_liste)`, sodass sie die Gesamtpunktzahl korrekt berechnet und zurückgibt.",
    "code_skeleton": "def berechne_punktestand(punkte_liste):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punktestand(punkte_liste):\n    return sum(punkte_liste)\n\npunkte = [2, 3, 2, 1, 3, 2]\ngesamtpunktzahl = berechne_punktestand(punkte)\nprint(gesamtpunktzahl)  # Ausgabe: 13",
    "unit_tests": "import unittest\nfrom main import berechne_punktestand\n\nclass TestBerechnePunktestand(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(berechne_punktestand([]), 0)\n\n    def test_ein_punkt(self):\n        self.assertEqual(berechne_punktestand([2]), 2)\n\n    def test_mehrere_punkte(self):\n        self.assertEqual(berechne_punktestand([2, 3, 2, 1, 3, 2]), 13)\n\n    def test_negativer_punkt(self):\n        self.assertEqual(berechne_punktestand([2, -1, 3]), 4)\n\n    def test_gemischte_punkte(self):\n        self.assertEqual(berechne_punktestand([2, 3, 0, 1, 3, 2]), 11)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 77,
    "programming_concept": "Boolean und None",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Aquarium-Überprüfung\n\nSchreibe eine Funktion namens `ist_aquarium_voll(wasserstand, kapazitaet)`, die überprüft, ob ein Aquarium voll ist. Die Funktion soll zwei Parameter entgegennehmen: `wasserstand` (in Litern) und `kapazitaet` (in Litern). Die Funktion soll `True` zurückgeben, wenn das Aquarium voll ist, `False`, wenn es nicht voll ist, und `None`, wenn der Wasserstand größer als die Kapazität ist.\n\nBeispielaufrufe:\n- `ist_aquarium_voll(50, 100)` gibt `False` zurück.\n- `ist_aquarium_voll(100, 100)` gibt `True` zurück.\n- `ist_aquarium_voll(150, 100)` gibt `None` zurück.",
    "code_skeleton": "def ist_aquarium_voll(wasserstand, kapazitaet):\n    ## Hier Code einfügen",
    "model_solution": "def ist_aquarium_voll(wasserstand, kapazitaet):\n    if wasserstand > kapazitaet:\n        return None\n    return wasserstand == kapazitaet\n\n# Beispielaufrufe\nprint(ist_aquarium_voll(50, 100))  # False\nprint(ist_aquarium_voll(100, 100)) # True\nprint(ist_aquarium_voll(150, 100)) # None",
    "unit_tests": "import unittest\nfrom main import ist_aquarium_voll\n\nclass TestIstAquariumVoll(unittest.TestCase):\n    def test_aquarium_nicht_voll(self):\n        self.assertEqual(ist_aquarium_voll(50, 100), False)\n\n    def test_aquarium_voll(self):\n        self.assertEqual(ist_aquarium_voll(100, 100), True)\n\n    def test_aquarium_ueberfuellt(self):\n        self.assertEqual(ist_aquarium_voll(150, 100), None)\n\n    def test_aquarium_leer(self):\n        self.assertEqual(ist_aquarium_voll(0, 100), False)\n\n    def test_aquarium_genau_voll(self):\n        self.assertEqual(ist_aquarium_voll(100, 100), True)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 78,
    "programming_concept": "Funktionen als Variablen",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen\n\nSchreibe eine Funktion `haustier_aktion(haustier, aktion)`, die eine Aktion für ein bestimmtes Haustier ausführt. Die Funktion soll zwei Parameter akzeptieren: `haustier` (ein String, der den Namen des Haustiers angibt) und `aktion` (eine Funktion, die eine Aktion beschreibt, die mit dem Haustier durchgeführt wird).\n\nBeispielaufruf:\n```python\ndef streicheln(haustier):\n    return f\"{haustier} wird gestreichelt.\"\n\ndef fuettern(haustier):\n    return f\"{haustier} wird gefüttert.\"\n\nhaustier_aktion(\"Bello\", streicheln)  # sollte \"Bello wird gestreichelt.\" zurückgeben\nhaustier_aktion(\"Mieze\", fuettern)    # sollte \"Mieze wird gefüttert.\" zurückgeben\n```\n\nImplementiere die Funktion `haustier_aktion(haustier, aktion)` so, dass sie die entsprechende Aktion für das angegebene Haustier ausführt und das Ergebnis zurückgibt.",
    "code_skeleton": "def haustier_aktion(haustier, aktion):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_aktion(haustier, aktion):\n    print(aktion(haustier))\n\ndef streicheln(haustier):\n    return f\"{haustier} wird gestreichelt.\"\n\ndef fuettern(haustier):\n    return f\"{haustier} wird gefüttert.\"\n\nhaustier_aktion(\"Bello\", streicheln)\nhaustier_aktion(\"Mieze\", fuettern)",
    "unit_tests": "import unittest\nfrom main import haustier_aktion\n\ndef streicheln(haustier):\n    return f\"{haustier} wird gestreichelt.\"\n\ndef fuettern(haustier):\n    return f\"{haustier} wird gefüttert.\"\n\nclass TestHaustierAktion(unittest.TestCase):\n    def test_streicheln(self):\n        self.assertEqual(haustier_aktion(\"Bello\", streicheln), \"Bello wird gestreichelt.\")\n\n    def test_fuettern(self):\n        self.assertEqual(haustier_aktion(\"Mieze\", fuettern), \"Mieze wird gefüttert.\")\n\n    def test_leerer_name(self):\n        self.assertEqual(haustier_aktion(\"\", streicheln), \" wird gestreichelt.\")\n\n    def test_andere_aktion(self):\n        def baden(haustier):\n            return f\"{haustier} wird gebadet.\"\n        self.assertEqual(haustier_aktion(\"Rex\", baden), \"Rex wird gebadet.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 79,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Kontext psychischer Gesundheit\n\nSchreibe eine Funktion `filter_positive_affirmations(affirmations, filter_function)`, die eine Liste von positiven Affirmationen und eine Filterfunktion als Argumente erhält. Die Funktion soll die Affirmationen basierend auf der übergebenen Filterfunktion filtern und die gefilterte Liste zurückgeben.\n\nEine positive Affirmation ist ein kurzer, positiver Satz, der das Selbstwertgefühl und die psychische Gesundheit stärken soll. Beispiele für Affirmationen sind: \"Ich bin stark\", \"Ich bin wertvoll\", \"Ich kann alles erreichen\".\n\nBeispielaufruf:\n```python\naffirmations = [\"Ich bin stark\", \"Ich bin wertvoll\", \"Ich kann alles erreichen\", \"Ich bin genug\"]\ndef contains_word_ich(affirmation):\n    return \"Ich\" in affirmation\n\ngefilterte_affirmationen = filter_positive_affirmations(affirmations, contains_word_ich)\nprint(gefilterte_affirmationen)  # Ausgabe: [\"Ich bin stark\", \"Ich bin wertvoll\", \"Ich kann alles erreichen\", \"Ich bin genug\"]\n```\n\nImplementiere die Funktion `filter_positive_affirmations` so, dass sie die Liste der Affirmationen basierend auf der übergebenen Filterfunktion korrekt filtert und zurückgibt.",
    "code_skeleton": "def filter_positive_affirmations(affirmations, filter_function):\n    ## Hier Code einfügen",
    "model_solution": "def filter_positive_affirmations(affirmations, filter_function):\n    return list(filter(filter_function, affirmations))\n\naffirmations = [\"Ich bin stark\", \"Ich bin wertvoll\", \"Ich kann alles erreichen\", \"Ich bin genug\"]\ndef contains_word_ich(affirmation):\n    return \"Ich\" in affirmation\n\ngefilterte_affirmationen = filter_positive_affirmations(affirmations, contains_word_ich)\nprint(gefilterte_affirmationen)",
    "unit_tests": "import unittest\nfrom main import filter_positive_affirmations\n\nclass TestFilterPositiveAffirmations(unittest.TestCase):\n    def test_contains_word_ich(self):\n        affirmations = [\"Ich bin stark\", \"Ich bin wertvoll\", \"Ich kann alles erreichen\", \"Ich bin genug\"]\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), affirmations)\n\n    def test_empty_list(self):\n        affirmations = []\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), [])\n\n    def test_no_match(self):\n        affirmations = [\"Du bist stark\", \"Du bist wertvoll\", \"Du kannst alles erreichen\", \"Du bist genug\"]\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), [])\n\n    def test_partial_match(self):\n        affirmations = [\"Ich bin stark\", \"Du bist wertvoll\", \"Ich kann alles erreichen\", \"Du bist genug\"]\n        def contains_word_ich(affirmation):\n            return \"Ich\" in affirmation\n        self.assertEqual(filter_positive_affirmations(affirmations, contains_word_ich), [\"Ich bin stark\", \"Ich kann alles erreichen\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 80,
    "programming_concept": "Rekursion",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Rekursive Zählung von Haustieren\n\nSchreibe eine rekursive Funktion namens `zaehle_haustiere(haustiere)`, die die Anzahl der Haustiere in einer verschachtelten Liste zählt. Die Liste kann sowohl einzelne Haustiere als auch weitere Listen von Haustieren enthalten.\n\nBeispiel:\n```python\nhaustiere = [\"Hund\", [\"Katze\", \"Vogel\"], [\"Fisch\", [\"Hamster\", \"Kaninchen\"]]]\n```\n\nEin Aufruf von `zaehle_haustiere(haustiere)` sollte die Gesamtzahl der Haustiere in der Liste zurückgeben.\n\n```python\nzaehle_haustiere(haustiere)  # sollte 6 zurückgeben\n```\n\nImplementiere die Funktion `zaehle_haustiere(haustiere)`, die die Anzahl der Haustiere in der verschachtelten Liste korrekt zählt.",
    "code_skeleton": "def zaehle_haustiere(haustiere):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_haustiere(haustiere):\n    if not haustiere:\n        return 0\n    if isinstance(haustiere[0], list):\n        return zaehle_haustiere(haustiere[0]) + zaehle_haustiere(haustiere[1:])\n    return 1 + zaehle_haustiere(haustiere[1:])\n\nhaustiere = [\"Hund\", [\"Katze\", \"Vogel\"], [\"Fisch\", [\"Hamster\", \"Kaninchen\"]]]\nprint(zaehle_haustiere(haustiere))  # sollte 6 zurückgeben",
    "unit_tests": "import unittest\nfrom main import zaehle_haustiere\n\nclass TestZaehleHaustiere(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(zaehle_haustiere([\"Hund\", \"Katze\", \"Vogel\"]), 3)\n\n    def test_verschachtelte_liste(self):\n        self.assertEqual(zaehle_haustiere([\"Hund\", [\"Katze\", \"Vogel\"], [\"Fisch\", [\"Hamster\", \"Kaninchen\"]]]), 6)\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_haustiere([]), 0)\n\n    def test_ein_haustier(self):\n        self.assertEqual(zaehle_haustiere([\"Hund\"]), 1)\n\n    def test_tief_verschachtelte_liste(self):\n        self.assertEqual(zaehle_haustiere([\"Hund\", [\"Katze\", [\"Vogel\", [\"Fisch\", [\"Hamster\", \"Kaninchen\"]]]]]), 6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 81,
    "programming_concept": "Tupel",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Gartenarbeit mit Tupeln\n\nSchreibe eine Funktion namens `pflanzen_info(pflanze)`, die Informationen über verschiedene Pflanzen in einem Garten zurückgibt. Die Informationen über die Pflanzen sollen in einem Tupel gespeichert sein. Jedes Tupel soll den Namen der Pflanze, die benötigte Wassermenge (in Litern pro Woche) und die bevorzugte Sonneneinstrahlung (z.B. \"Vollsonne\", \"Halbschatten\", \"Schatten\") enthalten.\n\nDie Funktion soll ein Tupel mit den Informationen der übergebenen Pflanze zurückgeben. Wenn die Pflanze nicht im Garten vorhanden ist, soll die Funktion `None` zurückgeben.\n\nBeispielaufrufe:\n```python\npflanzen_info(\"Tomate\")  # könnte z.B. (\"Tomate\", 5, \"Vollsonne\") zurückgeben\npflanzen_info(\"Lavendel\")  # könnte z.B. (\"Lavendel\", 2, \"Vollsonne\") zurückgeben\npflanzen_info(\"Unbekannt\")  # sollte None zurückgeben\n```",
    "code_skeleton": "def pflanzen_info(pflanze):\n    ## Hier Code einfügen",
    "model_solution": "def pflanzen_info(pflanze):\n    garten = {\n        \"Tomate\": (\"Tomate\", 5, \"Vollsonne\"),\n        \"Lavendel\": (\"Lavendel\", 2, \"Vollsonne\"),\n        \"Basilikum\": (\"Basilikum\", 3, \"Halbschatten\")\n    }\n    return garten.get(pflanze)\n\nprint(pflanzen_info(\"Tomate\"))\nprint(pflanzen_info(\"Lavendel\"))\nprint(pflanzen_info(\"Unbekannt\"))",
    "unit_tests": "import unittest\nfrom main import pflanzen_info\n\nclass TestPflanzenInfo(unittest.TestCase):\n    def test_tomate(self):\n        self.assertEqual(pflanzen_info(\"Tomate\"), (\"Tomate\", 5, \"Vollsonne\"))\n\n    def test_lavendel(self):\n        self.assertEqual(pflanzen_info(\"Lavendel\"), (\"Lavendel\", 2, \"Vollsonne\"))\n\n    def test_basilikum(self):\n        self.assertEqual(pflanzen_info(\"Basilikum\"), (\"Basilikum\", 3, \"Halbschatten\"))\n\n    def test_unbekannt(self):\n        self.assertIsNone(pflanzen_info(\"Unbekannt\"))\n\n    def test_leerer_string(self):\n        self.assertIsNone(pflanzen_info(\"\"))\n\n    def test_none(self):\n        self.assertIsNone(pflanzen_info(None))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 82,
    "programming_concept": "Integer",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tiere zählen\n\nSchreibe eine Funktion namens `zaehle_tiere(tiere)`, die eine Liste von Tieren als Eingabe erhält und die Anzahl der Tiere in der Liste als Integer zurückgibt. \n\nBeispielaufruf: \n```python\ntiere = [\"Hund\", \"Katze\", \"Vogel\", \"Hund\", \"Katze\"]\nprint(zaehle_tiere(tiere))  # Ausgabe: 5\n```\n\nDie Funktion soll die Anzahl der Tiere in der Liste korrekt zählen und als Integer zurückgeben.",
    "code_skeleton": "def zaehle_tiere(tiere):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_tiere(tiere):\n    return len(tiere)\n\ntiere = [\"Hund\", \"Katze\", \"Vogel\", \"Hund\", \"Katze\"]\nprint(zaehle_tiere(tiere))  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import zaehle_tiere\n\nclass TestZaehleTiere(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_tiere([]), 0)\n\n    def test_ein_tier(self):\n        self.assertEqual(zaehle_tiere([\"Hund\"]), 1)\n\n    def test_mehrere_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\", \"Hund\", \"Katze\"]), 5)\n\n    def test_gleiche_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Hund\", \"Hund\"]), 3)\n\n    def test_verschiedene_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\"]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 83,
    "programming_concept": "Float",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Berechnung des durchschnittlichen Stresslevels\n\nPsychische Gesundheit ist ein wichtiges Thema, und das Verständnis von Stressleveln kann dabei helfen, das Wohlbefinden zu verbessern. In dieser Aufgabe sollst du eine Funktion schreiben, die den durchschnittlichen Stresslevel einer Person berechnet.\n\nSchreibe eine Funktion namens `durchschnittlicher_stresslevel(stresswerte)`, die eine Liste von Fließkommazahlen (Floats) als Argument nimmt. Diese Liste repräsentiert die täglichen Stresslevel einer Person über einen bestimmten Zeitraum. Die Funktion soll den durchschnittlichen Stresslevel berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nstresswerte = [3.5, 4.0, 2.8, 5.0, 3.9]\nprint(durchschnittlicher_stresslevel(stresswerte))  # Ausgabe: 3.84\n```\n\nHinweis: Die Ausgabe muss nicht exakt 3.84 sein, da dies nur ein Beispiel ist.",
    "code_skeleton": "def durchschnittlicher_stresslevel(stresswerte):\n    ## Hier Code einfügen",
    "model_solution": "def durchschnittlicher_stresslevel(stresswerte):\n    return sum(stresswerte) / len(stresswerte)\n\nstresswerte = [3.5, 4.0, 2.8, 5.0, 3.9]\nprint(durchschnittlicher_stresslevel(stresswerte))",
    "unit_tests": "import unittest\nfrom main import durchschnittlicher_stresslevel\n\nclass TestDurchschnittlicherStresslevel(unittest.TestCase):\n    def test_durchschnittlicher_stresslevel_einfach(self):\n        self.assertAlmostEqual(durchschnittlicher_stresslevel([3.5, 4.0, 2.8, 5.0, 3.9]), 3.84, places=2)\n\n    def test_durchschnittlicher_stresslevel_leer(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittlicher_stresslevel([])\n\n    def test_durchschnittlicher_stresslevel_ein_element(self):\n        self.assertEqual(durchschnittlicher_stresslevel([4.2]), 4.2)\n\n    def test_durchschnittlicher_stresslevel_negative_werte(self):\n        self.assertAlmostEqual(durchschnittlicher_stresslevel([-1.0, -2.0, -3.0]), -2.0, places=2)\n\n    def test_durchschnittlicher_stresslevel_gemischte_werte(self):\n        self.assertAlmostEqual(durchschnittlicher_stresslevel([1.0, -1.0, 1.0, -1.0]), 0.0, places=2)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 84,
    "programming_concept": "Listen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Angeln und Listen in Python\n\nSchreibe eine Funktion namens `fange_fische(fische)`, die eine Liste von Fischen als Argument erhält. Die Funktion soll die Anzahl der gefangenen Fische zählen und eine Nachricht zurückgeben, die die Anzahl der Fische angibt. \n\nBeispielaufruf: \n```python\nfange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"])\n```\n\nErwartete Rückgabe:\n```python\n\"Du hast 4 Fische gefangen.\"\n```",
    "code_skeleton": "def fange_fische(fische):\n    ## Hier Code einfügen",
    "model_solution": "def fange_fische(fische):\n    print(f\"Du hast {len(fische)} Fische gefangen.\")\n\nfange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"])",
    "unit_tests": "import unittest\nfrom main import fange_fische\n\nclass TestFangeFische(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(fange_fische([]), \"Du hast 0 Fische gefangen.\")\n\n    def test_ein_fisch(self):\n        self.assertEqual(fange_fische([\"Hecht\"]), \"Du hast 1 Fisch gefangen.\")\n\n    def test_mehrere_fische(self):\n        self.assertEqual(fange_fische([\"Hecht\", \"Barsch\", \"Forelle\", \"Hecht\"]), \"Du hast 4 Fische gefangen.\")\n\n    def test_viele_fische(self):\n        self.assertEqual(fange_fische([\"Hecht\"] * 100), \"Du hast 100 Fische gefangen.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 85,
    "programming_concept": "Integer",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Aquarium\n\nSchreibe eine Funktion namens `fische_zaehlen(anzahl_fische)`, die die Anzahl der Fische in einem Aquarium überprüft und eine entsprechende Nachricht zurückgibt. \n\n- Wenn die Anzahl der Fische weniger als 5 ist, soll die Nachricht \"Das Aquarium ist ziemlich leer.\" zurückgegeben werden.\n- Wenn die Anzahl der Fische zwischen 5 und 10 liegt (einschließlich), soll die Nachricht \"Das Aquarium hat eine gute Anzahl an Fischen.\" zurückgegeben werden.\n- Wenn die Anzahl der Fische mehr als 10 ist, soll die Nachricht \"Das Aquarium ist überfüllt!\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `fische_zaehlen(3)` gibt \"Das Aquarium ist ziemlich leer.\" zurück.\n- `fische_zaehlen(7)` gibt \"Das Aquarium hat eine gute Anzahl an Fischen.\" zurück.\n- `fische_zaehlen(12)` gibt \"Das Aquarium ist überfüllt!\" zurück.",
    "code_skeleton": "def fische_zaehlen(anzahl_fische):\n    ## Hier Code einfügen",
    "model_solution": "def fische_zaehlen(anzahl_fische):\n    if anzahl_fische < 5:\n        return \"Das Aquarium ist ziemlich leer.\"\n    elif 5 <= anzahl_fische <= 10:\n        return \"Das Aquarium hat eine gute Anzahl an Fischen.\"\n    else:\n        return \"Das Aquarium ist überfüllt!\"\n\n# Beispielaufrufe\nprint(fische_zaehlen(3))\nprint(fische_zaehlen(7))\nprint(fische_zaehlen(12))",
    "unit_tests": "import unittest\nfrom main import fische_zaehlen\n\nclass TestFischeZaehlen(unittest.TestCase):\n    def test_wenige_fische(self):\n        self.assertEqual(fische_zaehlen(3), \"Das Aquarium ist ziemlich leer.\")\n\n    def test_gute_anzahl_fische(self):\n        self.assertEqual(fische_zaehlen(7), \"Das Aquarium hat eine gute Anzahl an Fischen.\")\n\n    def test_viele_fische(self):\n        self.assertEqual(fische_zaehlen(12), \"Das Aquarium ist überfüllt!\")\n\n    def test_unterer_randwert(self):\n        self.assertEqual(fische_zaehlen(5), \"Das Aquarium hat eine gute Anzahl an Fischen.\")\n\n    def test_oberer_randwert(self):\n        self.assertEqual(fische_zaehlen(10), \"Das Aquarium hat eine gute Anzahl an Fischen.\")\n\n    def test_null_fische(self):\n        self.assertEqual(fische_zaehlen(0), \"Das Aquarium ist ziemlich leer.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 86,
    "programming_concept": "While-Schleifen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Angeln mit While-Schleifen\n\nSchreibe eine Funktion namens `angeln()`, die simuliert, wie oft ein Angler einen Fisch fängt, bis er genug Fische für ein Abendessen hat. Der Angler benötigt mindestens 5 Fische. \n\nDie Funktion soll eine While-Schleife verwenden, um den Fangprozess zu simulieren. Bei jedem Durchlauf der Schleife soll die Anzahl der gefangenen Fische um 1 erhöht werden. Sobald der Angler 5 oder mehr Fische gefangen hat, soll die Schleife beendet werden und die Funktion die Gesamtzahl der gefangenen Fische zurückgeben.\n\nBeispielaufruf: `angeln()` könnte `5` zurückgeben, wenn der Angler genau 5 Fische gefangen hat.",
    "code_skeleton": "def angeln():\n    ## Hier Code einfügen",
    "model_solution": "def angeln():\n    fische = 0\n    while fische < 5:\n        fische += 1\n    print(fische)\n\nangeln()",
    "unit_tests": "import unittest\nfrom main import angeln\n\nclass TestAngeln(unittest.TestCase):\n    def test_genug_fische(self):\n        self.assertEqual(angeln(), 5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 87,
    "programming_concept": "Rekursion",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Rekursive Fischzählung\n\nSchreibe eine rekursive Funktion namens `zaehle_fische(teich)`, die die Anzahl der Fische in einem Teich zählt. Der Teich wird als Liste von Listen dargestellt, wobei jede innere Liste entweder leer ist oder weitere Listen enthält. Ein leerer Teich (leere Liste) enthält keine Fische.\n\nBeispielaufrufe:\n\n```python\n# Ein Teich ohne Fische\nteich1 = []\n\n# Ein Teich mit einem Fisch\nteich2 = [[], []]\n\n# Ein Teich mit drei Fischen\nteich3 = [[], [[], []], [[], [[], []]]]\n\nprint(zaehle_fische(teich1))  # Ausgabe: 0\nprint(zaehle_fische(teich2))  # Ausgabe: 2\nprint(zaehle_fische(teich3))  # Ausgabe: 6\n```\n\nImplementiere die Funktion `zaehle_fische(teich)`, die die Anzahl der Fische im Teich rekursiv zählt und zurückgibt.",
    "code_skeleton": "def zaehle_fische(teich):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(teich):\n    return 1 + sum(zaehle_fische(t) for t in teich) if teich else 0\n\n# Beispielaufrufe\nteich1 = []\nteich2 = [[], []]\nteich3 = [[], [[], []], [[], [[], []]]]\n\nprint(zaehle_fische(teich1))  # Ausgabe: 0\nprint(zaehle_fische(teich2))  # Ausgabe: 2\nprint(zaehle_fische(teich3))  # Ausgabe: 6",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_leerer_teich(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische([[], []]), 2)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(zaehle_fische([[], [[], []], [[], [[], []]]]), 6)\n\n    def test_verschachtelter_teich(self):\n        self.assertEqual(zaehle_fische([[], [[], [[], []]], [[], []]]), 5)\n\n    def test_tief_verschachtelter_teich(self):\n        self.assertEqual(zaehle_fische([[], [[], [[], [[], []]]], [[], []]]), 6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 88,
    "programming_concept": "Integer",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Punktzahlberechnung\n\nSchreibe eine Funktion namens `berechne_punkte(tore, assists)`, die die Gesamtpunktzahl eines Spielers in einem Fußballspiel berechnet. Dabei erhält der Spieler 3 Punkte für jedes erzielte Tor und 1 Punkt für jede Vorlage (Assist). Die Funktion soll die Gesamtpunktzahl als Integer zurückgeben.\n\nBeispielaufruf:\n```python\nberechne_punkte(2, 3)\n```\nDieser Aufruf sollte 9 zurückgeben, da der Spieler 2 Tore (2 * 3 = 6 Punkte) und 3 Assists (3 * 1 = 3 Punkte) erzielt hat, was insgesamt 9 Punkte ergibt.",
    "code_skeleton": "def berechne_punkte(tore, assists):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punkte(tore, assists):\n    return tore * 3 + assists\n\n# Beispielaufruf\nprint(berechne_punkte(2, 3))",
    "unit_tests": "import unittest\n\nfrom main import berechne_punkte\n\nclass TestBerechnePunkte(unittest.TestCase):\n    def test_keine_tore_und_assists(self):\n        self.assertEqual(berechne_punkte(0, 0), 0)\n\n    def test_nur_tore(self):\n        self.assertEqual(berechne_punkte(3, 0), 9)\n\n    def test_nur_assists(self):\n        self.assertEqual(berechne_punkte(0, 4), 4)\n\n    def test_tore_und_assists(self):\n        self.assertEqual(berechne_punkte(2, 3), 9)\n\n    def test_grosse_zahlen(self):\n        self.assertEqual(berechne_punkte(100, 200), 500)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 89,
    "programming_concept": "For-Schleifen",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurant-Bestellungen\n\nSchreibe eine Funktion namens `bestellungen_aufnehmen(bestellungen)`, die eine Liste von Bestellungen als Argument erhält. Jede Bestellung ist ein String, der den Namen eines Gerichts enthält. Die Funktion soll die Anzahl der Bestellungen für jedes Gericht zählen und das Ergebnis als Dictionary zurückgeben. \n\nBeispielaufruf:\n```python\nbestellungen = [\"Pizza\", \"Burger\", \"Salat\", \"Pizza\", \"Burger\", \"Pizza\"]\nprint(bestellungen_aufnehmen(bestellungen))\n```\n\nErwartete Ausgabe:\n```python\n{'Pizza': 3, 'Burger': 2, 'Salat': 1}\n```",
    "code_skeleton": "def bestellungen_aufnehmen(bestellungen):\n    ## Hier Code einfügen",
    "model_solution": "def bestellungen_aufnehmen(bestellungen):\n    ergebnis = {}\n    for gericht in bestellungen:\n        if gericht in ergebnis:\n            ergebnis[gericht] += 1\n        else:\n            ergebnis[gericht] = 1\n    return ergebnis\n\nbestellungen = [\"Pizza\", \"Burger\", \"Salat\", \"Pizza\", \"Burger\", \"Pizza\"]\nprint(bestellungen_aufnehmen(bestellungen))",
    "unit_tests": "import unittest\nfrom main import bestellungen_aufnehmen\n\nclass TestBestellungenAufnehmen(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(bestellungen_aufnehmen([\"Pizza\", \"Burger\", \"Salat\", \"Pizza\", \"Burger\", \"Pizza\"]), {'Pizza': 3, 'Burger': 2, 'Salat': 1})\n\n    def test_leere_liste(self):\n        self.assertEqual(bestellungen_aufnehmen([]), {})\n\n    def test_einzelne_bestellung(self):\n        self.assertEqual(bestellungen_aufnehmen([\"Pizza\"]), {'Pizza': 1})\n\n    def test_mehrere_verschiedene_bestellungen(self):\n        self.assertEqual(bestellungen_aufnehmen([\"Pizza\", \"Burger\", \"Salat\", \"Nudeln\", \"Pizza\", \"Burger\", \"Pizza\", \"Nudeln\"]), {'Pizza': 3, 'Burger': 2, 'Salat': 1, 'Nudeln': 2})\n\n    def test_alle_gleichen_bestellungen(self):\n        self.assertEqual(bestellungen_aufnehmen([\"Pizza\", \"Pizza\", \"Pizza\", \"Pizza\"]), {'Pizza': 4})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 90,
    "programming_concept": "For-Schleifen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fische zählen\n\nSchreibe eine Funktion namens `zaehle_fische(fische_liste)`, die eine Liste von Fischen als Eingabe erhält und die Anzahl der Fische in der Liste zählt. Die Funktion soll die Anzahl der Fische mit `return` zurückgeben.\n\nBeispielaufruf:\n```python\nfische = [\"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Barsch\"]\nanzahl = zaehle_fische(fische)\nprint(anzahl)  # Ausgabe: 5\n```\n\nVerwende eine For-Schleife, um die Anzahl der Fische in der Liste zu ermitteln.",
    "code_skeleton": "def zaehle_fische(fische_liste):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fische_liste):\n    return len(fische_liste)\n\nfische = [\"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Barsch\"]\nanzahl = zaehle_fische(fische)\nprint(anzahl)  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische([\"Hecht\"]), 1)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Barsch\"]), 5)\n\n    def test_alle_gleichen_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Hecht\", \"Hecht\"]), 3)\n\n    def test_verschiedene_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\", \"Barsch\", \"Zander\"]), 5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 91,
    "programming_concept": "While-Schleifen",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Aquarium - Fische zählen\n\nSchreibe eine Funktion namens `zaehle_fische(fische)`, die eine Liste von Fischen als Argument erhält. Die Funktion soll eine While-Schleife verwenden, um die Anzahl der Fische in der Liste zu zählen und diese Anzahl zurückzugeben.\n\nBeispielaufruf:\n```python\nfische = [\"Goldfisch\", \"Guppy\", \"Neonsalmler\", \"Platy\"]\nprint(zaehle_fische(fische))  # Ausgabe: 4\n```\n\nImplementiere die Funktion `zaehle_fische(fische)`, die die Anzahl der Fische in der Liste zählt und zurückgibt.",
    "code_skeleton": "def zaehle_fische(fische):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fische):\n    count = 0\n    i = 0\n    while i < len(fische):\n        count += 1\n        i += 1\n    return count\n\nfische = [\"Goldfisch\", \"Guppy\", \"Neonsalmler\", \"Platy\"]\nprint(zaehle_fische(fische))",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische([\"Goldfisch\"]), 1)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(zaehle_fische([\"Goldfisch\", \"Guppy\", \"Neonsalmler\", \"Platy\"]), 4)\n\n    def test_gleiche_fische(self):\n        self.assertEqual(zaehle_fische([\"Guppy\", \"Guppy\", \"Guppy\"]), 3)\n\n    def test_gemischte_fische(self):\n        self.assertEqual(zaehle_fische([\"Goldfisch\", \"Guppy\", \"Guppy\", \"Neonsalmler\", \"Platy\", \"Platy\"]), 6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 92,
    "programming_concept": "Operationen mit Zahlen",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Operationen mit Zahlen im Kontext \"Aquarium\"\n\nSchreibe eine Funktion namens `berechne_wasservolumen(laenge, breite, hoehe)`, die das Volumen eines rechteckigen Aquariums in Litern berechnet. Die Funktion soll die Länge, Breite und Höhe des Aquariums in Zentimetern als Parameter entgegennehmen und das Volumen in Litern zurückgeben. \n\nHinweis: 1 Liter entspricht 1000 Kubikzentimetern.\n\nBeispielaufruf: \n```python\nvolumen = berechne_wasservolumen(100, 50, 40)\nprint(volumen)  # Ausgabe: 200.0\n```\n\nIn diesem Beispiel hat das Aquarium eine Länge von 100 cm, eine Breite von 50 cm und eine Höhe von 40 cm. Das berechnete Volumen beträgt 200 Liter.",
    "code_skeleton": "def berechne_wasservolumen(laenge, breite, hoehe):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_wasservolumen(laenge, breite, hoehe):\n    return (laenge * breite * hoehe) / 1000\n\nvolumen = berechne_wasservolumen(100, 50, 40)\nprint(volumen)",
    "unit_tests": "import unittest\nfrom main import berechne_wasservolumen\n\nclass TestBerechneWasservolumen(unittest.TestCase):\n    def test_standard_fall(self):\n        self.assertEqual(berechne_wasservolumen(100, 50, 40), 200.0)\n\n    def test_null_volumen(self):\n        self.assertEqual(berechne_wasservolumen(0, 50, 40), 0.0)\n        self.assertEqual(berechne_wasservolumen(100, 0, 40), 0.0)\n        self.assertEqual(berechne_wasservolumen(100, 50, 0), 0.0)\n\n    def test_ein_liter(self):\n        self.assertEqual(berechne_wasservolumen(10, 10, 10), 1.0)\n\n    def test_grosse_werte(self):\n        self.assertEqual(berechne_wasservolumen(1000, 1000, 1000), 1000000.0)\n\n    def test_kleine_werte(self):\n        self.assertAlmostEqual(berechne_wasservolumen(1, 1, 1), 0.001)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 93,
    "programming_concept": "Listen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutatenliste für ein Rezept\n\nSchreibe eine Funktion namens `zutaten_hinzufuegen(zutaten_liste, neue_zutat)`, die eine Liste von Zutaten und eine neue Zutat als Parameter erhält. Die Funktion soll die neue Zutat zur Zutatenliste hinzufügen und die aktualisierte Liste zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\naktualisierte_liste = zutaten_hinzufuegen(zutaten, \"Milch\")\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\n```\n\n### Zusätzliche Aufgabe: Zutaten entfernen\n\nErweitere die Funktion um die Möglichkeit, eine Zutat aus der Liste zu entfernen. Schreibe eine Funktion namens `zutaten_entfernen(zutaten_liste, entferne_zutat)`, die eine Liste von Zutaten und eine zu entfernende Zutat als Parameter erhält. Die Funktion soll die Zutat aus der Liste entfernen und die aktualisierte Liste zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\naktualisierte_liste = zutaten_entfernen(zutaten, \"Zucker\")\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Eier\", \"Milch\"]\n```",
    "code_skeleton": "def zutaten_hinzufuegen(zutaten_liste, neue_zutat):\n    ## Hier Code einfügen\n\ndef zutaten_entfernen(zutaten_liste, entferne_zutat):\n    ## Hier Code einfügen",
    "model_solution": "def zutaten_hinzufuegen(zutaten_liste, neue_zutat):\n    zutaten_liste.append(neue_zutat)\n    return zutaten_liste\n\ndef zutaten_entfernen(zutaten_liste, entferne_zutat):\n    if entferne_zutat in zutaten_liste:\n        zutaten_liste.remove(entferne_zutat)\n    return zutaten_liste\n\n# Beispielaufrufe\nzutaten = [\"Mehl\", \"Zucker\", \"Eier\"]\naktualisierte_liste = zutaten_hinzufuegen(zutaten, \"Milch\")\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"]\n\naktualisierte_liste = zutaten_entfernen(zutaten, \"Zucker\")\nprint(aktualisierte_liste)  # Ausgabe: [\"Mehl\", \"Eier\", \"Milch\"]",
    "unit_tests": "import unittest\nfrom main import zutaten_hinzufuegen, zutaten_entfernen\n\nclass TestZutaten(unittest.TestCase):\n    def test_zutat_hinzufuegen(self):\n        self.assertEqual(zutaten_hinzufuegen([\"Mehl\", \"Zucker\", \"Eier\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"])\n\n    def test_zutat_entfernen(self):\n        self.assertEqual(zutaten_entfernen([\"Mehl\", \"Zucker\", \"Eier\", \"Milch\"], \"Zucker\"), [\"Mehl\", \"Eier\", \"Milch\"])\n\n    def test_zutat_hinzufuegen_leere_liste(self):\n        self.assertEqual(zutaten_hinzufuegen([], \"Milch\"), [\"Milch\"])\n\n    def test_zutat_entfernen_nicht_vorhanden(self):\n        self.assertEqual(zutaten_entfernen([\"Mehl\", \"Zucker\", \"Eier\"], \"Milch\"), [\"Mehl\", \"Zucker\", \"Eier\"])\n\n    def test_zutat_entfernen_leere_liste(self):\n        self.assertEqual(zutaten_entfernen([], \"Milch\"), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 94,
    "programming_concept": "Float",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Punktestand\n\nSchreibe eine Funktion namens `berechne_punktestand(tries, conversions, penalties)`, die den Punktestand eines Rugby-Spiels berechnet. \n\n- Ein Try (Versuch) zählt 5 Punkte.\n- Eine Conversion (Erhöhung) zählt 2 Punkte.\n- Ein Penalty (Straftritt) zählt 3 Punkte.\n\nDie Funktion soll drei Parameter entgegennehmen:\n- `tries` (float): Anzahl der erzielten Tries.\n- `conversions` (float): Anzahl der erzielten Conversions.\n- `penalties` (float): Anzahl der erzielten Penalties.\n\nDie Funktion soll den gesamten Punktestand als float zurückgeben.\n\nBeispielaufruf:\n```python\nberechne_punktestand(3.0, 2.0, 1.0)\n```\nDieser Aufruf sollte den Wert `21.0` zurückgeben.",
    "code_skeleton": "def berechne_punktestand(tries, conversions, penalties):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punktestand(tries, conversions, penalties):\n    return tries * 5 + conversions * 2 + penalties * 3\n\nprint(berechne_punktestand(3.0, 2.0, 1.0))",
    "unit_tests": "import unittest\n\nfrom main import berechne_punktestand\n\nclass TestBerechnePunktestand(unittest.TestCase):\n    def test_alle_arten_von_punkten(self):\n        self.assertEqual(berechne_punktestand(3.0, 2.0, 1.0), 21.0)\n\n    def test_nur_tries(self):\n        self.assertEqual(berechne_punktestand(4.0, 0.0, 0.0), 20.0)\n\n    def test_nur_conversions(self):\n        self.assertEqual(berechne_punktestand(0.0, 3.0, 0.0), 6.0)\n\n    def test_nur_penalties(self):\n        self.assertEqual(berechne_punktestand(0.0, 0.0, 5.0), 15.0)\n\n    def test_keine_punkte(self):\n        self.assertEqual(berechne_punktestand(0.0, 0.0, 0.0), 0.0)\n\n    def test_gemischte_punkte(self):\n        self.assertEqual(berechne_punktestand(2.0, 3.0, 4.0), 25.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 95,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung in der Gartenarbeit\n\nSchreibe eine Funktion namens `pflanzen_verwalten(pflanzen_liste, funktion)`, die eine Liste von Pflanzen und eine Funktion als Argumente entgegennimmt. Die Funktion `pflanzen_verwalten` soll die übergebene Funktion auf jede Pflanze in der Liste anwenden und die Ergebnisse in einer neuen Liste zurückgeben.\n\nBeispielaufruf:\n```python\ndef pflanze_beschreiben(pflanze):\n    return f\"Die Pflanze {pflanze} wächst gut im Garten.\"\n\npflanzen = [\"Tomate\", \"Gurke\", \"Zucchini\"]\nergebnisse = pflanzen_verwalten(pflanzen, pflanze_beschreiben)\nprint(ergebnisse)\n```\n\nErwartete Ausgabe:\n```\n['Die Pflanze Tomate wächst gut im Garten.', 'Die Pflanze Gurke wächst gut im Garten.', 'Die Pflanze Zucchini wächst gut im Garten.']\n```\n\nImplementiere die Funktion `pflanzen_verwalten` so, dass sie die übergebene Funktion auf jede Pflanze in der Liste anwendet und die Ergebnisse in einer neuen Liste zurückgibt.",
    "code_skeleton": "def pflanzen_verwalten(pflanzen_liste, funktion):\n    ## Hier Code einfügen",
    "model_solution": "def pflanzen_verwalten(pflanzen_liste, funktion):\n    return [funktion(pflanze) for pflanze in pflanzen_liste]\n\ndef pflanze_beschreiben(pflanze):\n    return f\"Die Pflanze {pflanze} wächst gut im Garten.\"\n\npflanzen = [\"Tomate\", \"Gurke\", \"Zucchini\"]\nergebnisse = pflanzen_verwalten(pflanzen, pflanze_beschreiben)\nprint(ergebnisse)",
    "unit_tests": "import unittest\nfrom main import pflanzen_verwalten\n\ndef pflanze_beschreiben(pflanze):\n    return f\"Die Pflanze {pflanze} wächst gut im Garten.\"\n\nclass TestPflanzenVerwalten(unittest.TestCase):\n    def test_einfache_liste(self):\n        pflanzen = [\"Tomate\", \"Gurke\", \"Zucchini\"]\n        erwartet = [\n            \"Die Pflanze Tomate wächst gut im Garten.\",\n            \"Die Pflanze Gurke wächst gut im Garten.\",\n            \"Die Pflanze Zucchini wächst gut im Garten.\"\n        ]\n        self.assertEqual(pflanzen_verwalten(pflanzen, pflanze_beschreiben), erwartet)\n\n    def test_leere_liste(self):\n        pflanzen = []\n        erwartet = []\n        self.assertEqual(pflanzen_verwalten(pflanzen, pflanze_beschreiben), erwartet)\n\n    def test_eine_pflanze(self):\n        pflanzen = [\"Tomate\"]\n        erwartet = [\"Die Pflanze Tomate wächst gut im Garten.\"]\n        self.assertEqual(pflanzen_verwalten(pflanzen, pflanze_beschreiben), erwartet)\n\n    def test_verschiedene_pflanzen(self):\n        pflanzen = [\"Tomate\", \"Gurke\", \"Zucchini\", \"Paprika\"]\n        erwartet = [\n            \"Die Pflanze Tomate wächst gut im Garten.\",\n            \"Die Pflanze Gurke wächst gut im Garten.\",\n            \"Die Pflanze Zucchini wächst gut im Garten.\",\n            \"Die Pflanze Paprika wächst gut im Garten.\"\n        ]\n        self.assertEqual(pflanzen_verwalten(pflanzen, pflanze_beschreiben), erwartet)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 96,
    "programming_concept": "Funktionen höherer Ordnung",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung im Sport\n\nSchreibe eine Funktion namens `filter_sportler(sportler_liste, kriterium_funktion)`, die eine Liste von Sportlern und eine Funktion als Parameter entgegennimmt. Die Funktion soll eine neue Liste zurückgeben, die nur die Sportler enthält, die das Kriterium der übergebenen Funktion erfüllen.\n\nEin Sportler wird durch ein Dictionary repräsentiert, das mindestens die Schlüssel `name` und `sportart` enthält.\n\nBeispiel:\n\n```python\nsportler_liste = [\n    {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n    {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n    {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"},\n    {\"name\": \"David\", \"sportart\": \"Tennis\"}\n]\n\ndef ist_tennisspieler(sportler):\n    return sportler[\"sportart\"] == \"Tennis\"\n\n# Aufruf der Funktion\ngefilterte_sportler = filter_sportler(sportler_liste, ist_tennisspieler)\n# Erwartete Ausgabe: [{\"name\": \"Anna\", \"sportart\": \"Tennis\"}, {\"name\": \"David\", \"sportart\": \"Tennis\"}]\n```\n\nImplementiere die Funktion `filter_sportler` so, dass sie die Liste der Sportler basierend auf der übergebenen Kriterium-Funktion filtert und die gefilterte Liste zurückgibt.",
    "code_skeleton": "def filter_sportler(sportler_liste, kriterium_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def filter_sportler(sportler_liste, kriterium_funktion):\n    return [sportler for sportler in sportler_liste wenn kriterium_funktion(sportler)]\n\nsportler_liste = [\n    {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n    {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n    {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"},\n    {\"name\": \"David\", \"sportart\": \"Tennis\"}\n]\n\ndef ist_tennisspieler(sportler):\n    return sportler[\"sportart\"] == \"Tennis\"\n\ngefilterte_sportler = filter_sportler(sportler_liste, ist_tennisspieler)\nprint(gefilterte_sportler)",
    "unit_tests": "import unittest\nfrom main import filter_sportler\n\nclass TestFilterSportler(unittest.TestCase):\n    def test_tennisspieler(self):\n        sportler_liste = [\n            {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n            {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n            {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"},\n            {\"name\": \"David\", \"sportart\": \"Tennis\"}\n        ]\n        def ist_tennisspieler(sportler):\n            return sportler[\"sportart\"] == \"Tennis\"\n        self.assertEqual(filter_sportler(sportler_liste, ist_tennisspieler), [\n            {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n            {\"name\": \"David\", \"sportart\": \"Tennis\"}\n        ])\n\n    def test_fussballspieler(self):\n        sportler_liste = [\n            {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n            {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n            {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"},\n            {\"name\": \"David\", \"sportart\": \"Tennis\"}\n        ]\n        def ist_fussballspieler(sportler):\n            return sportler[\"sportart\"] == \"Fußball\"\n        self.assertEqual(filter_sportler(sportler_liste, ist_fussballspieler), [\n            {\"name\": \"Ben\", \"sportart\": \"Fußball\"}\n        ])\n\n    def test_keine_sportler(self):\n        sportler_liste = []\n        def ist_tennisspieler(sportler):\n            return sportler[\"sportart\"] == \"Tennis\"\n        self.assertEqual(filter_sportler(sportler_liste, ist_tennisspieler), [])\n\n    def test_alle_sportler(self):\n        sportler_liste = [\n            {\"name\": \"Anna\", \"sportart\": \"Tennis\"},\n            {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n            {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"},\n            {\"name\": \"David\", \"sportart\": \"Tennis\"}\n        ]\n        def alle_sportler(sportler):\n            return True\n        self.assertEqual(filter_sportler(sportler_liste, alle_sportler), sportler_liste)\n\n    def test_keine_tennisspieler(self):\n        sportler_liste = [\n            {\"name\": \"Ben\", \"sportart\": \"Fußball\"},\n            {\"name\": \"Clara\", \"sportart\": \"Schwimmen\"}\n        ]\n        def ist_tennisspieler(sportler):\n            return sportler[\"sportart\"] == \"Tennis\"\n        self.assertEqual(filter_sportler(sportler_liste, ist_tennisspieler), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 97,
    "programming_concept": "Boolean und None",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustiere und Boolean\n\nSchreibe eine Funktion namens `ist_haustier(name)`, die überprüft, ob der übergebene Name zu einem bekannten Haustier gehört. Die Funktion soll `True` zurückgeben, wenn der Name in der Liste der bekannten Haustiere enthalten ist, und `False`, wenn nicht. Wenn der Name `None` ist, soll die Funktion ebenfalls `False` zurückgeben.\n\nBekannte Haustiere sind:\n- \"Hund\"\n- \"Katze\"\n- \"Hamster\"\n- \"Kaninchen\"\n- \"Papagei\"\n\nBeispielaufrufe:\n- `ist_haustier(\"Hund\")` gibt `True` zurück.\n- `ist_haustier(\"Elefant\")` gibt `False` zurück.\n- `ist_haustier(None)` gibt `False` zurück.",
    "code_skeleton": "def ist_haustier(name):\n    ## Hier Code einfügen",
    "model_solution": "def ist_haustier(name):\n    return name in [\"Hund\", \"Katze\", \"Hamster\", \"Kaninchen\", \"Papagei\"]\n\n# Testfälle\nprint(ist_haustier(\"Hund\"))      # True\nprint(ist_haustier(\"Elefant\"))   # False\nprint(ist_haustier(None))        # False",
    "unit_tests": "import unittest\nfrom main import ist_haustier\n\nclass TestIstHaustier(unittest.TestCase):\n    def test_hund(self):\n        self.assertTrue(ist_haustier(\"Hund\"))\n\n    def test_katze(self):\n        self.assertTrue(ist_haustier(\"Katze\"))\n\n    def test_hamster(self):\n        self.assertTrue(ist_haustier(\"Hamster\"))\n\n    def test_kaninchen(self):\n        self.assertTrue(ist_haustier(\"Kaninchen\"))\n\n    def test_papagei(self):\n        self.assertTrue(ist_haustier(\"Papagei\"))\n\n    def test_elefant(self):\n        self.assertFalse(ist_haustier(\"Elefant\"))\n\n    def test_none(self):\n        self.assertFalse(ist_haustier(None))\n\n    def test_leerer_string(self):\n        self.assertFalse(ist_haustier(\"\"))\n\n    def test_unbekanntes_tier(self):\n        self.assertFalse(ist_haustier(\"Tiger\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 98,
    "programming_concept": "Float",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutatenmengen berechnen\n\nSchreibe eine Funktion namens `berechne_zutatenmenge(anzahl_personen)`, die die benötigte Menge einer Zutat für ein Rezept berechnet. Das Rezept ist für 4 Personen ausgelegt und benötigt 250.0 Gramm Mehl. Die Funktion soll die benötigte Menge Mehl für die angegebene Anzahl von Personen berechnen und zurückgeben.\n\nBeispielaufruf: `berechne_zutatenmenge(2)` gibt `125.0` zurück.",
    "code_skeleton": "def berechne_zutatenmenge(anzahl_personen):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_zutatenmenge(anzahl_personen):\n    return 250.0 * anzahl_personen / 4\n\nprint(berechne_zutatenmenge(2))",
    "unit_tests": "import unittest\nfrom main import berechne_zutatenmenge\n\nclass TestBerechneZutatenmenge(unittest.TestCase):\n    def test_zwei_personen(self):\n        self.assertEqual(berechne_zutatenmenge(2), 125.0)\n\n    def test_vier_personen(self):\n        self.assertEqual(berechne_zutatenmenge(4), 250.0)\n\n    def test_acht_personen(self):\n        self.assertEqual(berechne_zutatenmenge(8), 500.0)\n\n    def test_null_personen(self):\n        self.assertEqual(berechne_zutatenmenge(0), 0.0)\n\n    def test_halbe_person(self):\n        self.assertEqual(berechne_zutatenmenge(0.5), 31.25)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 99,
    "programming_concept": "If-Else-Anweisungen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tierklassifikation\n\nSchreibe eine Funktion namens `tier_klassifikation(tier)`, die den Typ eines Tieres basierend auf dem übergebenen String klassifiziert. Die Funktion soll eine entsprechende Nachricht mit `return` zurückgeben.\n\n- Wenn das Tier ein \"Hund\" ist, soll die Nachricht \"Das ist ein Säugetier.\" zurückgegeben werden.\n- Wenn das Tier ein \"Adler\" ist, soll die Nachricht \"Das ist ein Vogel.\" zurückgegeben werden.\n- Wenn das Tier ein \"Hai\" ist, soll die Nachricht \"Das ist ein Fisch.\" zurückgegeben werden.\n- Für alle anderen Tiere soll die Nachricht \"Unbekannte Tierklasse.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `tier_klassifikation(\"Hund\")` gibt \"Das ist ein Säugetier.\" zurück.\n- `tier_klassifikation(\"Adler\")` gibt \"Das ist ein Vogel.\" zurück.\n- `tier_klassifikation(\"Hai\")` gibt \"Das ist ein Fisch.\" zurück.\n- `tier_klassifikation(\"Krokodil\")` gibt \"Unbekannte Tierklasse.\" zurück.",
    "code_skeleton": "def tier_klassifikation(tier):\n    ## Hier Code einfügen",
    "model_solution": "def tier_klassifikation(tier):\n    if tier == \"Hund\":\n        return \"Das ist ein Säugetier.\"\n    elif tier == \"Adler\":\n        return \"Das ist ein Vogel.\"\n    elif tier == \"Hai\":\n        return \"Das ist ein Fisch.\"\n    else:\n        return \"Unbekannte Tierklasse.\"\n\n# Beispielaufrufe\nprint(tier_klassifikation(\"Hund\"))\nprint(tier_klassifikation(\"Adler\"))\nprint(tier_klassifikation(\"Hai\"))\nprint(tier_klassifikation(\"Krokodil\"))",
    "unit_tests": "import unittest\n\nfrom main import tier_klassifikation\n\nclass TestTierKlassifikation(unittest.TestCase):\n    def test_hund(self):\n        self.assertEqual(tier_klassifikation(\"Hund\"), \"Das ist ein Säugetier.\")\n\n    def test_adler(self):\n        self.assertEqual(tier_klassifikation(\"Adler\"), \"Das ist ein Vogel.\")\n\n    def test_hai(self):\n        self.assertEqual(tier_klassifikation(\"Hai\"), \"Das ist ein Fisch.\")\n\n    def test_unbekanntes_tier(self):\n        self.assertEqual(tier_klassifikation(\"Krokodil\"), \"Unbekannte Tierklasse.\")\n\n    def test_leerer_string(self):\n        self.assertEqual(tier_klassifikation(\"\"), \"Unbekannte Tierklasse.\")\n\n    def test_none(self):\n        self.assertEqual(tier_klassifikation(None), \"Unbekannte Tierklasse.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 100,
    "programming_concept": "Rekursion",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Rekursive Tierzählung\n\nSchreibe eine rekursive Funktion namens `zaehle_tiere(tiere)`, die eine Liste von Tieren als Argument erhält und die Anzahl der Tiere in der Liste zurückgibt. Die Funktion soll dabei rekursiv arbeiten und keine Schleifen verwenden.\n\nBeispielaufruf:\n```python\ntiere = [\"Hund\", \"Katze\", \"Vogel\", \"Fisch\"]\nprint(zaehle_tiere(tiere))  # Ausgabe: 4\n```\n\nHinweis: Die Liste kann auch leer sein.",
    "code_skeleton": "def zaehle_tiere(tiere):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_tiere(tiere):\n    if not tiere:\n        return 0\n    return 1 + zaehle_tiere(tiere[1:])\n\ntiere = [\"Hund\", \"Katze\", \"Vogel\", \"Fisch\"]\nprint(zaehle_tiere(tiere))",
    "unit_tests": "import unittest\n\nfrom main import zaehle_tiere\n\nclass TestZaehleTiere(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_tiere([]), 0)\n\n    def test_ein_tier(self):\n        self.assertEqual(zaehle_tiere([\"Hund\"]), 1)\n\n    def test_mehrere_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\", \"Fisch\"]), 4)\n\n    def test_verschiedene_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Elefant\", \"Maus\", \"Tiger\", \"Löwe\", \"Giraffe\"]), 5)\n\n    def test_wiederholte_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Hund\", \"Hund\"]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 101,
    "programming_concept": "Rekursion;If-Else-Anweisungen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Rekursive Fischzählung\n\nSchreibe eine rekursive Funktion namens `zaehle_fische(fische)`, die die Anzahl der Fische in einem See zählt. Die Funktion soll eine Liste von Fischen als Argument erhalten, wobei jeder Fisch durch einen String repräsentiert wird. Wenn die Liste leer ist, soll die Funktion 0 zurückgeben. Andernfalls soll die Funktion die Anzahl der Fische in der Liste zurückgeben.\n\nBeispielaufrufe:\n- `zaehle_fische([])` gibt `0` zurück.\n- `zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\"])` gibt `3` zurück.",
    "code_skeleton": "def zaehle_fische(fische):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fische):\n    if not fische:\n        return 0\n    return 1 + zaehle_fische(fische[1:])\n\nprint(zaehle_fische([]))\nprint(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\"]))",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_ein_fisch(self):\n        self.assertEqual(zaehle_fische([\"Hecht\"]), 1)\n\n    def test_mehrere_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\"]), 3)\n\n    def test_viele_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\", \"Barsch\", \"Wels\", \"Zander\"]), 6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 102,
    "programming_concept": "Operationen mit Zahlen;For-Schleifen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Durchschnittliche Laufzeit berechnen\n\nSchreibe eine Funktion namens `durchschnittliche_laufzeit(zeiten)`, die eine Liste von Laufzeiten (in Minuten) als Argument erhält und die durchschnittliche Laufzeit berechnet und zurückgibt. Die Berechnung soll unter Verwendung einer For-Schleife erfolgen.\n\nBeispielaufruf:\n```python\nzeiten = [30, 45, 50, 40, 35]\nprint(durchschnittliche_laufzeit(zeiten))  # Ausgabe: 40.0\n```\n\nIn diesem Beispiel sind die Laufzeiten von fünf Läufern in Minuten angegeben. Die Funktion soll die durchschnittliche Laufzeit berechnen und zurückgeben.",
    "code_skeleton": "def durchschnittliche_laufzeit(zeiten):\n    ## Hier Code einfügen",
    "model_solution": "def durchschnittliche_laufzeit(zeiten):\n    summe = 0\n    for zeit in zeiten:\n        summe += zeit\n    return summe / len(zeiten)\n\nzeiten = [30, 45, 50, 40, 35]\nprint(durchschnittliche_laufzeit(zeiten))",
    "unit_tests": "import unittest\nfrom main import durchschnittliche_laufzeit\n\nclass TestDurchschnittlicheLaufzeit(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(durchschnittliche_laufzeit([30, 45, 50, 40, 35]), 40.0)\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittliche_laufzeit([])\n\n    def test_ein_element(self):\n        self.assertEqual(durchschnittliche_laufzeit([25]), 25.0)\n\n    def test_gemischte_werte(self):\n        self.assertEqual(durchschnittliche_laufzeit([10, 20, 30, 40, 50]), 30.0)\n\n    def test_gleiche_werte(self):\n        self.assertEqual(durchschnittliche_laufzeit([20, 20, 20, 20, 20]), 20.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 103,
    "programming_concept": "Float;Boolean und None",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tierinformationen\n\nSchreibe eine Funktion namens `tier_info(name, gewicht)`, die Informationen über ein Tier basierend auf seinem Namen und Gewicht zurückgibt. Die Funktion soll folgende Anforderungen erfüllen:\n\n1. Wenn der Name des Tieres \"Elefant\" ist und das Gewicht größer als 5000.0 (in Kilogramm) ist, soll die Funktion `True` zurückgeben.\n2. Wenn der Name des Tieres \"Maus\" ist und das Gewicht kleiner als 0.05 (in Kilogramm) ist, soll die Funktion `True` zurückgeben.\n3. In allen anderen Fällen soll die Funktion `None` zurückgeben.\n\nBeispielaufrufe:\n- `tier_info(\"Elefant\", 6000.0)` gibt `True` zurück.\n- `tier_info(\"Maus\", 0.03)` gibt `True` zurück.\n- `tier_info(\"Hund\", 10.0)` gibt `None` zurück.",
    "code_skeleton": "def tier_info(name, gewicht):\n    ## Hier Code einfügen",
    "model_solution": "def tier_info(name, gewicht):\n    if name == \"Elefant\" and gewicht > 5000.0:\n        return True\n    if name == \"Maus\" and gewicht < 0.05:\n        return True\n    return None\n\nprint(tier_info(\"Elefant\", 6000.0))  # True\nprint(tier_info(\"Maus\", 0.03))       # True\nprint(tier_info(\"Hund\", 10.0))       # None",
    "unit_tests": "import unittest\n\nfrom main import tier_info\n\nclass TestTierInfo(unittest.TestCase):\n    def test_elefant_schwer(self):\n        self.assertEqual(tier_info(\"Elefant\", 6000.0), True)\n\n    def test_maus_leicht(self):\n        self.assertEqual(tier_info(\"Maus\", 0.03), True)\n\n    def test_hund(self):\n        self.assertEqual(tier_info(\"Hund\", 10.0), None)\n\n    def test_elefant_leicht(self):\n        self.assertEqual(tier_info(\"Elefant\", 4000.0), None)\n\n    def test_maus_schwer(self):\n        self.assertEqual(tier_info(\"Maus\", 0.1), None)\n\n    def test_randfall_elefant(self):\n        self.assertEqual(tier_info(\"Elefant\", 5000.0), None)\n\n    def test_randfall_maus(self):\n        self.assertEqual(tier_info(\"Maus\", 0.05), None)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 104,
    "programming_concept": "Funktionen als Variablen;Integer",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tieralter in Menschenjahren\n\nSchreibe eine Funktion namens `tier_alter_in_menschenjahren(tier, alter)`, die das Alter eines Tieres in Menschenjahren berechnet. Die Funktion soll zwei Parameter entgegennehmen: `tier` (ein String, der den Typ des Tieres angibt, z.B. \"Hund\" oder \"Katze\") und `alter` (ein Integer, der das Alter des Tieres in Jahren angibt).\n\nDie Umrechnung soll wie folgt erfolgen:\n- Für Hunde: 1 Tierjahr entspricht 7 Menschenjahren.\n- Für Katzen: 1 Tierjahr entspricht 5 Menschenjahren.\n\nDie Funktion soll das berechnete Alter in Menschenjahren zurückgeben.\n\nBeispielaufrufe:\n- `tier_alter_in_menschenjahren(\"Hund\", 3)` soll 21 zurückgeben.\n- `tier_alter_in_menschenjahren(\"Katze\", 4)` soll 20 zurückgeben.",
    "code_skeleton": "def tier_alter_in_menschenjahren(tier, alter):\n    ## Hier Code einfügen",
    "model_solution": "def tier_alter_in_menschenjahren(tier, alter):\n    multiplikator = 7 if tier == \"Hund\" else 5 if tier == \"Katze\" else 1\n    return alter * multiplikator\n\nprint(tier_alter_in_menschenjahren(\"Hund\", 3))  # 21\nprint(tier_alter_in_menschenjahren(\"Katze\", 4))  # 20",
    "unit_tests": "import unittest\n\nfrom main import tier_alter_in_menschenjahren\n\nclass TestTierAlterInMenschenjahren(unittest.TestCase):\n    def test_hund_alter(self):\n        self.assertEqual(tier_alter_in_menschenjahren(\"Hund\", 3), 21)\n\n    def test_katze_alter(self):\n        self.assertEqual(tier_alter_in_menschenjahren(\"Katze\", 4), 20)\n\n    def test_hund_alter_randbedingung(self):\n        self.assertEqual(tier_alter_in_menschenjahren(\"Hund\", 0), 0)\n\n    def test_katze_alter_randbedingung(self):\n        self.assertEqual(tier_alter_in_menschenjahren(\"Katze\", 0), 0)\n\n    def test_unbekanntes_tier(self):\n        self.assertEqual(tier_alter_in_menschenjahren(\"Vogel\", 3), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 105,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);While-Schleifen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerlevel\n\nSchreibe eine Funktion namens `spieler_level(punkte)`, die das Level eines Spielers basierend auf seinen Punkten bestimmt. Die Funktion soll eine Nachricht mit dem erreichten Level zurückgeben. Verwende Kontrollstrukturen und eine While-Schleife, um die Punkte zu überprüfen und das entsprechende Level zu bestimmen.\n\nDie Level sind wie folgt definiert:\n- Level 1: 0 bis 99 Punkte\n- Level 2: 100 bis 199 Punkte\n- Level 3: 200 bis 299 Punkte\n- Level 4: 300 bis 399 Punkte\n- Level 5: 400 oder mehr Punkte\n\nBeispielaufruf:\n```python\nprint(spieler_level(150))  # Ausgabe: \"Du bist auf Level 2!\"\nprint(spieler_level(350))  # Ausgabe: \"Du bist auf Level 4!\"\n```\n\nImplementiere die Funktion `spieler_level(punkte)`, die die Punkte des Spielers als Argument nimmt und das entsprechende Level als Nachricht zurückgibt.",
    "code_skeleton": "def spieler_level(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_level(punkte):\n    level = 1\n    while punkte >= 100:\n        punkte -= 100\n        level += 1\n    return f\"Du bist auf Level {level}!\"\n\nprint(spieler_level(150))  # Ausgabe: \"Du bist auf Level 2!\"\nprint(spieler_level(350))  # Ausgabe: \"Du bist auf Level 4!\"",
    "unit_tests": "import unittest\n\nfrom main import spieler_level\n\nclass TestSpielerLevel(unittest.TestCase):\n    def test_level_1(self):\n        self.assertEqual(spieler_level(50), \"Du bist auf Level 1!\")\n\n    def test_level_2(self):\n        self.assertEqual(spieler_level(150), \"Du bist auf Level 2!\")\n\n    def test_level_3(self):\n        self.assertEqual(spieler_level(250), \"Du bist auf Level 3!\")\n\n    def test_level_4(self):\n        self.assertEqual(spieler_level(350), \"Du bist auf Level 4!\")\n\n    def test_level_5(self):\n        self.assertEqual(spieler_level(450), \"Du bist auf Level 5!\")\n\n    def test_exact_boundary_level_1(self):\n        self.assertEqual(spieler_level(99), \"Du bist auf Level 1!\")\n\n    def test_exact_boundary_level_2(self):\n        self.assertEqual(spieler_level(100), \"Du bist auf Level 2!\")\n\n    def test_exact_boundary_level_3(self):\n        self.assertEqual(spieler_level(200), \"Du bist auf Level 3!\")\n\n    def test_exact_boundary_level_4(self):\n        self.assertEqual(spieler_level(300), \"Du bist auf Level 4!\")\n\n    def test_exact_boundary_level_5(self):\n        self.assertEqual(spieler_level(400), \"Du bist auf Level 5!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 106,
    "programming_concept": "Float;Tupel",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustiergewicht\n\nSchreibe eine Funktion namens `haustier_gewicht(haustiere)`, die ein Tupel von Haustieren und deren Gewichten (in Kilogramm) als Eingabe erhält. Die Funktion soll das durchschnittliche Gewicht der Haustiere berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nhaustiere = ((\"Hund\", 20.5), (\"Katze\", 4.3), (\"Hamster\", 0.1))\ndurchschnitt = haustier_gewicht(haustiere)\nprint(durchschnitt)  # Erwartete Ausgabe: 8.3\n```\n\nImplementiere die Funktion so, dass sie das durchschnittliche Gewicht der Haustiere korrekt berechnet und zurückgibt.",
    "code_skeleton": "def haustier_gewicht(haustiere):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_gewicht(haustiere):\n    return sum(gewicht for _, gewicht in haustiere) / len(haustiere)\n\nhaustiere = ((\"Hund\", 20.5), (\"Katze\", 4.3), (\"Hamster\", 0.1))\ndurchschnitt = haustier_gewicht(haustiere)\nprint(durchschnitt)  # Erwartete Ausgabe: 8.3",
    "unit_tests": "import unittest\nfrom main import haustier_gewicht\n\nclass TestHaustierGewicht(unittest.TestCase):\n    def test_durchschnittliches_gewicht(self):\n        haustiere = ((\"Hund\", 20.5), (\"Katze\", 4.3), (\"Hamster\", 0.1))\n        self.assertAlmostEqual(haustier_gewicht(haustiere), 8.3, places=1)\n\n    def test_leere_liste(self):\n        haustiere = ()\n        with self.assertRaises(ZeroDivisionError):\n            haustier_gewicht(haustiere)\n\n    def test_ein_haustier(self):\n        haustiere = ((\"Hund\", 20.5),)\n        self.assertEqual(haustier_gewicht(haustiere), 20.5)\n\n    def test_gemischte_gewichte(self):\n        haustiere = ((\"Hund\", 20.5), (\"Katze\", 4.3), (\"Hamster\", 0.1), (\"Papagei\", 1.2))\n        self.assertAlmostEqual(haustier_gewicht(haustiere), 6.525, places=3)\n\n    def test_negative_gewichte(self):\n        haustiere = ((\"Hund\", -20.5), (\"Katze\", -4.3), (\"Hamster\", -0.1))\n        self.assertAlmostEqual(haustier_gewicht(haustiere), -8.3, places=1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 107,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);If-Else-Anweisungen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Spielerbewertung\n\nSchreibe eine Funktion namens `bewerte_spieler(punkte, assists, rebounds)`, die die Leistung eines Basketballspielers basierend auf seinen Statistiken bewertet. Die Funktion soll drei Parameter entgegennehmen:\n\n- `punkte`: Anzahl der erzielten Punkte\n- `assists`: Anzahl der Assists\n- `rebounds`: Anzahl der Rebounds\n\nDie Bewertung erfolgt nach folgenden Kriterien:\n\n- Wenn der Spieler mehr als 20 Punkte erzielt hat und mehr als 5 Assists gegeben hat, soll die Funktion \"Hervorragende Leistung!\" zurückgeben.\n- Wenn der Spieler mehr als 15 Punkte erzielt hat oder mehr als 10 Rebounds gesammelt hat, soll die Funktion \"Gute Leistung!\" zurückgeben.\n- Wenn der Spieler weniger als 5 Punkte erzielt hat und weniger als 3 Assists gegeben hat, soll die Funktion \"Schwache Leistung!\" zurückgeben.\n- In allen anderen Fällen soll die Funktion \"Durchschnittliche Leistung\" zurückgeben.\n\nBeispielaufrufe:\n\n```python\nbewerte_spieler(25, 6, 8)  # gibt \"Hervorragende Leistung!\" zurück\nbewerte_spieler(18, 4, 11)  # gibt \"Gute Leistung!\" zurück\nbewerte_spieler(4, 2, 5)    # gibt \"Schwache Leistung!\" zurück\nbewerte_spieler(10, 4, 7)   # gibt \"Durchschnittliche Leistung\" zurück\n```",
    "code_skeleton": "def bewerte_spieler(punkte, assists, rebounds):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(punkte, assists, rebounds):\n    if punkte > 20 and assists > 5:\n        return \"Hervorragende Leistung!\"\n    elif punkte > 15 or rebounds > 10:\n        return \"Gute Leistung!\"\n    elif punkte < 5 and assists < 3:\n        return \"Schwache Leistung!\"\n    else:\n        return \"Durchschnittliche Leistung\"\n\n# Beispielaufrufe\nprint(bewerte_spieler(25, 6, 8))  # Hervorragende Leistung!\nprint(bewerte_spieler(18, 4, 11))  # Gute Leistung!\nprint(bewerte_spieler(4, 2, 5))    # Schwache Leistung!\nprint(bewerte_spieler(10, 4, 7))   # Durchschnittliche Leistung",
    "unit_tests": "import unittest\n\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler(25, 6, 8), \"Hervorragende Leistung!\")\n\n    def test_gute_leistung_punkte(self):\n        self.assertEqual(bewerte_spieler(18, 4, 11), \"Gute Leistung!\")\n\n    def test_gute_leistung_rebounds(self):\n        self.assertEqual(bewerte_spieler(10, 4, 11), \"Gute Leistung!\")\n\n    def test_schwache_leistung(self):\n        self.assertEqual(bewerte_spieler(4, 2, 5), \"Schwache Leistung!\")\n\n    def test_durchschnittliche_leistung(self):\n        self.assertEqual(bewerte_spieler(10, 4, 7), \"Durchschnittliche Leistung\")\n\n    def test_grenzfall_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler(21, 6, 8), \"Durchschnittliche Leistung\")\n\n    def test_grenzfall_gute_leistung(self):\n        self.assertEqual(bewerte_spieler(16, 4, 10), \"Gute Leistung!\")\n\n    def test_grenzfall_schwache_leistung(self):\n        self.assertEqual(bewerte_spieler(5, 2, 5), \"Durchschnittliche Leistung\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 108,
    "programming_concept": "Listen;Rekursion",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Vergnügungspark - Attraktionen zählen\n\nSchreibe eine rekursive Funktion namens `zaehle_attraktionen(attraktionen)`, die eine Liste von Attraktionen in einem Vergnügungspark zählt. Die Liste kann sowohl einzelne Attraktionen als auch weitere Listen von Attraktionen enthalten. Die Funktion soll die Gesamtzahl der Attraktionen zurückgeben.\n\nBeispiel:\n\n```python\nattraktionen = [\"Achterbahn\", [\"Riesenrad\", \"Karussell\"], \"Geisterbahn\", [\"Wasserrutsche\", [\"Wildwasserbahn\", \"Wellenbad\"]]]\n```\n\nEin Aufruf von `zaehle_attraktionen(attraktionen)` sollte die Gesamtzahl der Attraktionen in der Liste zurückgeben.\n\n```python\nprint(zaehle_attraktionen(attraktionen))  # Ausgabe: 7\n```\n\nImplementiere die Funktion `zaehle_attraktionen(attraktionen)`, die die Anzahl der Attraktionen in der Liste rekursiv zählt.",
    "code_skeleton": "def zaehle_attraktionen(attraktionen):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_attraktionen(attraktionen):\n    if not attraktionen:\n        return 0\n    if isinstance(attraktionen[0], list):\n        return zaehle_attraktionen(attraktionen[0]) + zaehle_attraktionen(attraktionen[1:])\n    return 1 + zaehle_attraktionen(attraktionen[1:])\n\nattraktionen = [\"Achterbahn\", [\"Riesenrad\", \"Karussell\"], \"Geisterbahn\", [\"Wasserrutsche\", [\"Wildwasserbahn\", \"Wellenbad\"]]]\nprint(zaehle_attraktionen(attraktionen))  # Ausgabe: 7",
    "unit_tests": "import unittest\n\nfrom main import zaehle_attraktionen\n\nclass TestZaehleAttraktionen(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(zaehle_attraktionen([\"Achterbahn\", \"Riesenrad\", \"Karussell\"]), 3)\n\n    def test_verschachtelte_liste(self):\n        self.assertEqual(zaehle_attraktionen([\"Achterbahn\", [\"Riesenrad\", \"Karussell\"], \"Geisterbahn\"]), 4)\n\n    def test_tief_verschachtelte_liste(self):\n        self.assertEqual(zaehle_attraktionen([\"Achterbahn\", [\"Riesenrad\", [\"Karussell\", \"Geisterbahn\"]], \"Wasserrutsche\"]), 5)\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_attraktionen([]), 0)\n\n    def test_liste_mit_leeren_unterlisten(self):\n        self.assertEqual(zaehle_attraktionen([\"Achterbahn\", [], \"Riesenrad\", []]), 2)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 109,
    "programming_concept": "Funktionen als Variablen;Operationen mit Zahlen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Funktionen als Variablen und Operationen mit Zahlen im Kontext \"Angeln\"\n\nSchreibe eine Funktion namens `fisch_gewicht_berechnen(fisch_gewicht_liste)`, die eine Liste von Gewichten (in Kilogramm) von gefangenen Fischen entgegennimmt und das Gesamtgewicht der Fische berechnet. Die Funktion soll das Gesamtgewicht der Fische zurückgeben.\n\nZusätzlich soll eine zweite Funktion `durchschnittsgewicht(fisch_gewicht_liste)` implementiert werden, die das Durchschnittsgewicht der Fische berechnet und zurückgibt.\n\nBeispielaufrufe:\n```python\nfisch_gewicht_liste = [2.5, 3.0, 1.2, 4.8]\ngesamtgewicht = fisch_gewicht_berechnen(fisch_gewicht_liste)\nprint(gesamtgewicht)  # Ausgabe: 11.5\n\ndurchschnitt = durchschnittsgewicht(fisch_gewicht_liste)\nprint(durchschnitt)  # Ausgabe: 2.875\n```\n\nImplementiere beide Funktionen so, dass sie korrekt arbeiten und die erwarteten Ergebnisse liefern.",
    "code_skeleton": "def fisch_gewicht_berechnen(fisch_gewicht_liste):\n    ## Hier Code einfügen\n\ndef durchschnittsgewicht(fisch_gewicht_liste):\n    ## Hier Code einfügen",
    "model_solution": "def fisch_gewicht_berechnen(fisch_gewicht_liste):\n    return sum(fisch_gewicht_liste)\n\ndef durchschnittsgewicht(fisch_gewicht_liste):\n    return sum(fisch_gewicht_liste) / len(fisch_gewicht_liste)\n\nfisch_gewicht_liste = [2.5, 3.0, 1.2, 4.8]\ngesamtgewicht = fisch_gewicht_berechnen(fisch_gewicht_liste)\nprint(gesamtgewicht)  # Ausgabe: 11.5\n\ndurchschnitt = durchschnittsgewicht(fisch_gewicht_liste)\nprint(durchschnitt)  # Ausgabe: 2.875",
    "unit_tests": "import unittest\n\nfrom main import fisch_gewicht_berechnen, durchschnittsgewicht\n\nclass TestFischGewichtBerechnen(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(fisch_gewicht_berechnen([2.5, 3.0, 1.2, 4.8]), 11.5)\n\n    def test_leere_liste(self):\n        self.assertEqual(fisch_gewicht_berechnen([]), 0)\n\n    def test_ein_element(self):\n        self.assertEqual(fisch_gewicht_berechnen([5.0]), 5.0)\n\n    def test_negatives_gewicht(self):\n        self.assertEqual(fisch_gewicht_berechnen([2.5, -1.0, 3.0]), 4.5)\n\nclass TestDurchschnittsgewicht(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(durchschnittsgewicht([2.5, 3.0, 1.2, 4.8]), 2.875)\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittsgewicht([])\n\n    def test_ein_element(self):\n        self.assertEqual(durchschnittsgewicht([5.0]), 5.0)\n\n    def test_negatives_gewicht(self):\n        self.assertEqual(durchschnittsgewicht([2.5, -1.0, 3.0]), 1.5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 110,
    "programming_concept": "Boolean und None;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Benutzeraktivität prüfen\n\nSchreibe eine Funktion namens `ist_aktiv(benutzername, beitraege, follower)`, die überprüft, ob ein Benutzer auf einer sozialen Medienplattform als aktiv gilt. Ein Benutzer gilt als aktiv, wenn er mindestens 10 Beiträge veröffentlicht hat **und** mehr als 100 Follower hat. Die Funktion soll einen Boolean Wert (`True` oder `False`) zurückgeben.\n\nBeispielaufrufe:\n- `ist_aktiv(\"MaxMustermann\", 15, 150)` gibt `True` zurück.\n- `ist_aktiv(\"ErikaMustermann\", 5, 200)` gibt `False` zurück.",
    "code_skeleton": "def ist_aktiv(benutzername, beitraege, follower):\n    ## Hier Code einfügen",
    "model_solution": "def ist_aktiv(benutzername, beitraege, follower):\n    return beitraege >= 10 and follower > 100\n\n# Beispielaufrufe\nprint(ist_aktiv(\"MaxMustermann\", 15, 150))  # True\nprint(ist_aktiv(\"ErikaMustermann\", 5, 200))  # False",
    "unit_tests": "import unittest\nfrom main import ist_aktiv\n\nclass TestIstAktiv(unittest.TestCase):\n    def test_aktiv(self):\n        self.assertTrue(ist_aktiv(\"MaxMustermann\", 15, 150))\n\n    def test_nicht_aktiv_wenige_beitraege(self):\n        self.assertFalse(ist_aktiv(\"ErikaMustermann\", 5, 200))\n\n    def test_nicht_aktiv_wenige_follower(self):\n        self.assertFalse(ist_aktiv(\"HansMustermann\", 20, 50))\n\n    def test_nicht_aktiv_wenige_beitraege_und_follower(self):\n        self.assertFalse(ist_aktiv(\"AnnaMustermann\", 5, 50))\n\n    def test_grenzwert_beitraege(self):\n        self.assertFalse(ist_aktiv(\"GrenzfallBeitraege\", 9, 150))\n        self.assertTrue(ist_aktiv(\"GrenzfallBeitraege\", 10, 150))\n\n    def test_grenzwert_follower(self):\n        self.assertFalse(ist_aktiv(\"GrenzfallFollower\", 15, 100))\n        self.assertTrue(ist_aktiv(\"GrenzfallFollower\", 15, 101))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 111,
    "programming_concept": "Boolean und None;Float",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Leistung bewerten\n\nSchreibe eine Funktion namens `bewerte_leistung(punkte)`, die die sportliche Leistung eines Athleten basierend auf der Punktzahl bewertet. Die Funktion soll einen `Boolean` Wert zurückgeben, der angibt, ob die Leistung als \"gut\" (True) oder \"schlecht\" (False) bewertet wird. \n\nZusätzlich soll die Funktion `None` zurückgeben, wenn die Punktzahl ein `Float` ist, um anzuzeigen, dass die Punktzahl ungültig ist.\n\n- Wenn die Punktzahl 50 oder mehr beträgt, soll die Leistung als \"gut\" (True) bewertet werden.\n- Wenn die Punktzahl weniger als 50 beträgt, soll die Leistung als \"schlecht\" (False) bewertet werden.\n- Wenn die Punktzahl ein `Float` ist, soll die Funktion `None` zurückgeben.\n\nBeispielaufrufe:\n- `bewerte_leistung(75)` gibt `True` zurück.\n- `bewerte_leistung(30)` gibt `False` zurück.\n- `bewerte_leistung(45.5)` gibt `None` zurück.",
    "code_skeleton": "def bewerte_leistung(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_leistung(punkte):\n    if isinstance(punkte, float):\n        return None\n    return punkte >= 50\n\n# Beispielaufrufe\nprint(bewerte_leistung(75))  # True\nprint(bewerte_leistung(30))  # False\nprint(bewerte_leistung(45.5))  # None",
    "unit_tests": "import unittest\n\nfrom main import bewerte_leistung\n\nclass TestBewerteLeistung(unittest.TestCase):\n    def test_gute_leistung(self):\n        self.assertTrue(bewerte_leistung(75))\n\n    def test_schlechte_leistung(self):\n        self.assertFalse(bewerte_leistung(30))\n\n    def test_ungültige_punktzahl(self):\n        self.assertIsNone(bewerte_leistung(45.5))\n\n    def test_grenze_gut(self):\n        self.assertTrue(bewerte_leistung(50))\n\n    def test_grenze_schlecht(self):\n        self.assertFalse(bewerte_leistung(49))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 112,
    "programming_concept": "Tupel;Funktionen als Variablen",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Psychische Gesundheit - Stimmungsanalyse\n\nSchreibe eine Funktion namens `stimmungsanalyse(stimmung)`, die eine Stimmung als Tupel entgegennimmt und eine entsprechende Nachricht zurückgibt. Das Tupel besteht aus zwei Elementen: einem String, der die Stimmung beschreibt (z.B. \"glücklich\", \"traurig\", \"gestresst\"), und einem Integer, der die Intensität der Stimmung auf einer Skala von 1 bis 10 angibt.\n\nDie Funktion soll eine Nachricht zurückgeben, die die Stimmung und ihre Intensität beschreibt. Verwende eine zweite Funktion namens `nachricht_generieren`, die die Nachricht basierend auf den übergebenen Werten erstellt.\n\nBeispielaufruf:\n```python\nstimmungsanalyse((\"glücklich\", 8))\n```\n\nBeispielausgabe:\n```python\n\"Du fühlst dich sehr glücklich mit einer Intensität von 8.\"\n```",
    "code_skeleton": "def stimmungsanalyse(stimmung):\n    ## Hier Code einfügen\n\ndef nachricht_generieren(stimmung, intensitaet):\n    ## Hier Code einfügen",
    "model_solution": "def stimmungsanalyse(stimmung):\n    print(nachricht_generieren(stimmung[0], stimmung[1]))\n\ndef nachricht_generieren(stimmung, intensitaet):\n    return f\"Du fühlst dich sehr {stimmung} mit einer Intensität von {intensitaet}.\"\n\nstimmungsanalyse((\"glücklich\", 8))",
    "unit_tests": "import unittest\nfrom main import stimmungsanalyse, nachricht_generieren\n\nclass TestStimmungsanalyse(unittest.TestCase):\n    def test_gluecklich(self):\n        self.assertEqual(nachricht_generieren(\"glücklich\", 8), \"Du fühlst dich sehr glücklich mit einer Intensität von 8.\")\n\n    def test_traurig(self):\n        self.assertEqual(nachricht_generieren(\"traurig\", 3), \"Du fühlst dich sehr traurig mit einer Intensität von 3.\")\n\n    def test_gestresst(self):\n        self.assertEqual(nachricht_generieren(\"gestresst\", 10), \"Du fühlst dich sehr gestresst mit einer Intensität von 10.\")\n\n    def test_neutral(self):\n        self.assertEqual(nachricht_generieren(\"neutral\", 5), \"Du fühlst dich sehr neutral mit einer Intensität von 5.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 113,
    "programming_concept": "Float;While-Schleifen",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Vergnügungspark - Fahrgeschäftsüberprüfung\n\nSchreibe eine Funktion namens `fahrgeschaeft_ueberpruefung(fahrzeit)`, die die Funktionalität eines Fahrgeschäfts in einem Vergnügungspark überprüft. Die Funktion soll eine float-Zahl `fahrzeit` als Parameter erhalten, die die Dauer einer Fahrt in Minuten angibt. \n\nDie Funktion soll eine While-Schleife verwenden, um die Fahrzeit zu überprüfen. Wenn die Fahrzeit weniger als 2 Minuten beträgt, soll die Schleife die Fahrzeit um 0.5 Minuten erhöhen und eine Nachricht ausgeben, dass die Fahrzeit zu kurz ist. Sobald die Fahrzeit 2 Minuten oder mehr beträgt, soll die Schleife beendet werden und eine Nachricht ausgegeben werden, dass die Fahrzeit akzeptabel ist.\n\nBeispielaufruf:\n```python\nfahrgeschaeft_ueberpruefung(1.0)\n```\n\nErwartete Ausgabe:\n```\nFahrzeit zu kurz: 1.0 Minuten\nFahrzeit zu kurz: 1.5 Minuten\nFahrzeit akzeptabel: 2.0 Minuten\n```",
    "code_skeleton": "def fahrgeschaeft_ueberpruefung(fahrzeit):\n    ## Hier Code einfügen",
    "model_solution": "def fahrgeschaeft_ueberpruefung(fahrzeit):\n    while fahrzeit < 2:\n        print(f\"Fahrzeit zu kurz: {fahrzeit} Minuten\")\n        fahrzeit += 0.5\n    print(f\"Fahrzeit akzeptabel: {fahrzeit} Minuten\")\n\nfahrgeschaeft_ueberpruefung(1.0)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import fahrgeschaeft_ueberpruefung\n\nclass TestFahrgeschaeftUeberpruefung(unittest.TestCase):\n    def test_fahrzeit_zu_kurz(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        fahrgeschaeft_ueberpruefung(1.0)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Fahrzeit zu kurz: 1.0 Minuten\\nFahrzeit zu kurz: 1.5 Minuten\\nFahrzeit akzeptabel: 2.0 Minuten\")\n\n    def test_fahrzeit_akzeptabel(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        fahrgeschaeft_ueberpruefung(2.0)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Fahrzeit akzeptabel: 2.0 Minuten\")\n\n    def test_fahrzeit_ueber_akzeptabel(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        fahrgeschaeft_ueberpruefung(3.0)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Fahrzeit akzeptabel: 3.0 Minuten\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 114,
    "programming_concept": "While-Schleifen;Funktionen höherer Ordnung",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Kochrezept-Zähler\n\nSchreibe eine Funktion namens `zaehle_zutaten(rezept, kriterium)`, die eine Liste von Zutaten (`rezept`) und eine Funktion (`kriterium`) als Parameter erhält. Die Funktion soll die Anzahl der Zutaten im Rezept zählen, die das Kriterium erfüllen. Verwende eine `while`-Schleife, um durch die Zutatenliste zu iterieren.\n\nBeispielaufruf:\n```python\ndef ist_gemuese(zutat):\n    gemuese = [\"Karotte\", \"Tomate\", \"Gurke\", \"Paprika\"]\n    return zutat in gemuese\n\nrezept = [\"Karotte\", \"Hähnchen\", \"Tomate\", \"Reis\", \"Paprika\"]\nprint(zaehle_zutaten(rezept, ist_gemuese))  # Ausgabe: 3\n```\n\nIn diesem Beispiel wird die Funktion `ist_gemuese` als Kriterium verwendet, um die Anzahl der Gemüsezutaten im Rezept zu zählen.",
    "code_skeleton": "def zaehle_zutaten(rezept, kriterium):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_zutaten(rezept, kriterium):\n    count, i = 0, 0\n    while i < len(rezept):\n        if kriterium(rezept[i]):\n            count += 1\n        i += 1\n    return count\n\ndef ist_gemuese(zutat):\n    gemuese = [\"Karotte\", \"Tomate\", \"Gurke\", \"Paprika\"]\n    return zutat in gemuese\n\nrezept = [\"Karotte\", \"Hähnchen\", \"Tomate\", \"Reis\", \"Paprika\"]\nprint(zaehle_zutaten(rezept, ist_gemuese))  # Ausgabe: 3",
    "unit_tests": "import unittest\n\nfrom main import zaehle_zutaten\n\ndef ist_gemuese(zutat):\n    gemuese = [\"Karotte\", \"Tomate\", \"Gurke\", \"Paprika\"]\n    return zutat in gemuese\n\ndef ist_fleisch(zutat):\n    fleisch = [\"Hähnchen\", \"Rind\", \"Schwein\"]\n    return zutat in fleisch\n\nclass TestZaehleZutaten(unittest.TestCase):\n    def test_gemuese(self):\n        rezept = [\"Karotte\", \"Hähnchen\", \"Tomate\", \"Reis\", \"Paprika\"]\n        self.assertEqual(zaehle_zutaten(rezept, ist_gemuese), 3)\n\n    def test_fleisch(self):\n        rezept = [\"Karotte\", \"Hähnchen\", \"Tomate\", \"Reis\", \"Paprika\"]\n        self.assertEqual(zaehle_zutaten(rezept, ist_fleisch), 1)\n\n    def test_leeres_rezept(self):\n        rezept = []\n        self.assertEqual(zaehle_zutaten(rezept, ist_gemuese), 0)\n\n    def test_kein_kriterium_erfuellt(self):\n        rezept = [\"Reis\", \"Nudeln\", \"Kartoffeln\"]\n        self.assertEqual(zaehle_zutaten(rezept, ist_gemuese), 0)\n\n    def test_alle_kriterien_erfuellt(self):\n        rezept = [\"Karotte\", \"Tomate\", \"Gurke\", \"Paprika\"]\n        self.assertEqual(zaehle_zutaten(rezept, ist_gemuese), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 115,
    "programming_concept": "Operationen mit Zahlen;Integer",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerlevel Berechnung\n\nIn modernen Videospielen ist es üblich, dass Spieler durch das Sammeln von Erfahrungspunkten (XP) im Level aufsteigen. Schreibe eine Funktion namens `berechne_level(xp)`, die das aktuelle Level eines Spielers basierend auf den gesammelten Erfahrungspunkten berechnet und zurückgibt.\n\nDie Level-Berechnung erfolgt nach folgendem Schema:\n- Level 1: 0 - 999 XP\n- Level 2: 1000 - 1999 XP\n- Level 3: 2000 - 2999 XP\n- Level 4: 3000 - 3999 XP\n- Level 5: 4000 - 4999 XP\n- usw.\n\nJedes weitere Level erfordert 1000 zusätzliche XP.\n\nBeispielaufrufe:\n- `berechne_level(1500)` gibt `2` zurück.\n- `berechne_level(4500)` gibt `5` zurück.\n\nImplementiere die Funktion `berechne_level(xp)`, die die oben beschriebene Berechnung durchführt.",
    "code_skeleton": "def berechne_level(xp):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_level(xp):\n    return xp // 1000 + 1\n\n# Beispielaufrufe\nprint(berechne_level(1500))  # Ausgabe: 2\nprint(berechne_level(4500))  # Ausgabe: 5",
    "unit_tests": "import unittest\nfrom main import berechne_level\n\nclass TestBerechneLevel(unittest.TestCase):\n    def test_level_1(self):\n        self.assertEqual(berechne_level(0), 1)\n        self.assertEqual(berechne_level(999), 1)\n\n    def test_level_2(self):\n        self.assertEqual(berechne_level(1000), 2)\n        self.assertEqual(berechne_level(1999), 2)\n\n    def test_level_3(self):\n        self.assertEqual(berechne_level(2000), 3)\n        self.assertEqual(berechne_level(2999), 3)\n\n    def test_level_4(self):\n        self.assertEqual(berechne_level(3000), 4)\n        self.assertEqual(berechne_level(3999), 4)\n\n    def test_level_5(self):\n        self.assertEqual(berechne_level(4000), 5)\n        self.assertEqual(berechne_level(4999), 5)\n\n    def test_high_levels(self):\n        self.assertEqual(berechne_level(10000), 11)\n        self.assertEqual(berechne_level(12345), 13)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 116,
    "programming_concept": "If-Else-Anweisungen;Operationen mit Zahlen",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerlevel\n\nSchreibe eine Funktion namens `spieler_level(punkte)`, die das Level eines Spielers basierend auf seiner Punktzahl bestimmt. Die Funktion soll eine Nachricht mit 'return' zurückgeben, die das Level des Spielers angibt.\n\nDie Level sind wie folgt definiert:\n- Weniger als 1000 Punkte: \"Anfänger\"\n- 1000 bis 4999 Punkte: \"Fortgeschrittener\"\n- 5000 bis 9999 Punkte: \"Profi\"\n- 10000 oder mehr Punkte: \"Legende\"\n\nBeispielaufrufe:\n- `spieler_level(750)` gibt \"Anfänger\" zurück.\n- `spieler_level(3200)` gibt \"Fortgeschrittener\" zurück.\n- `spieler_level(7500)` gibt \"Profi\" zurück.\n- `spieler_level(12000)` gibt \"Legende\" zurück.",
    "code_skeleton": "def spieler_level(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_level(punkte):\n    if punkte < 1000:\n        return \"Anfänger\"\n    elif punkte < 5000:\n        return \"Fortgeschrittener\"\n    elif punkte < 10000:\n        return \"Profi\"\n    else:\n        return \"Legende\"\n\n# Beispielaufrufe\nprint(spieler_level(750))    # Anfänger\nprint(spieler_level(3200))   # Fortgeschrittener\nprint(spieler_level(7500))   # Profi\nprint(spieler_level(12000))  # Legende",
    "unit_tests": "import unittest\nfrom main import spieler_level\n\nclass TestSpielerLevel(unittest.TestCase):\n    def test_anfaenger(self):\n        self.assertEqual(spieler_level(750), \"Anfänger\")\n\n    def test_fortgeschrittener(self):\n        self.assertEqual(spieler_level(3200), \"Fortgeschrittener\")\n\n    def test_profi(self):\n        self.assertEqual(spieler_level(7500), \"Profi\")\n\n    def test_legende(self):\n        self.assertEqual(spieler_level(12000), \"Legende\")\n\n    def test_grenze_anfaenger_fortgeschrittener(self):\n        self.assertEqual(spieler_level(1000), \"Fortgeschrittener\")\n\n    def test_grenze_fortgeschrittener_profi(self):\n        self.assertEqual(spieler_level(5000), \"Profi\")\n\n    def test_grenze_profi_legende(self):\n        self.assertEqual(spieler_level(10000), \"Legende\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 117,
    "programming_concept": "Boolean und None;Funktionen höherer Ordnung",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Benutzeraktivität prüfen\n\nSchreibe eine Funktion `ist_aktiv(benutzer)`, die überprüft, ob ein Benutzer in einem sozialen Netzwerk aktiv ist. Ein Benutzer wird als aktiv betrachtet, wenn er in den letzten 30 Tagen mindestens einen Beitrag gepostet hat. Die Funktion soll einen Boolean-Wert (`True` oder `False`) zurückgeben.\n\nZusätzlich soll eine Funktion `filter_aktive_benutzer(benutzer_liste, filter_funktion)` implementiert werden, die eine Liste von Benutzern und eine Filterfunktion als Argumente erhält. Diese Funktion soll eine neue Liste zurückgeben, die nur die aktiven Benutzer enthält.\n\nEin Benutzer wird durch ein Dictionary repräsentiert, das mindestens die folgenden Schlüssel enthält:\n- `name`: Der Name des Benutzers (String)\n- `letzter_beitrag`: Das Datum des letzten Beitrags in Tagen seit dem aktuellen Datum (Integer)\n\nBeispiel:\n```python\nbenutzer1 = {\"name\": \"Alice\", \"letzter_beitrag\": 10}\nbenutzer2 = {\"name\": \"Bob\", \"letzter_beitrag\": 40}\nbenutzer3 = {\"name\": \"Charlie\", \"letzter_beitrag\": 5}\n\nbenutzer_liste = [benutzer1, benutzer2, benutzer3]\n\n# Aufruf der Funktion\naktive_benutzer = filter_aktive_benutzer(benutzer_liste, ist_aktiv)\n\n# Erwartete Ausgabe: [{\"name\": \"Alice\", \"letzter_beitrag\": 10}, {\"name\": \"Charlie\", \"letzter_beitrag\": 5}]\nprint(aktive_benutzer)\n```\n\nImplementiere die Funktionen `ist_aktiv(benutzer)` und `filter_aktive_benutzer(benutzer_liste, filter_funktion)`.",
    "code_skeleton": "def ist_aktiv(benutzer):\n    ## Hier Code einfügen\n\ndef filter_aktive_benutzer(benutzer_liste, filter_funktion):\n    ## Hier Code einfügen",
    "model_solution": "def ist_aktiv(benutzer):\n    return benutzer['letzter_beitrag'] <= 30\n\ndef filter_aktive_benutzer(benutzer_liste, filter_funktion):\n    return [benutzer for benutzer in benutzer_liste if filter_funktion(benutzer)]\n\nbenutzer1 = {\"name\": \"Alice\", \"letzter_beitrag\": 10}\nbenutzer2 = {\"name\": \"Bob\", \"letzter_beitrag\": 40}\nbenutzer3 = {\"name\": \"Charlie\", \"letzter_beitrag\": 5}\n\nbenutzer_liste = [benutzer1, benutzer2, benutzer3]\n\naktive_benutzer = filter_aktive_benutzer(benutzer_liste, ist_aktiv)\n\nprint(aktive_benutzer)",
    "unit_tests": "import unittest\nfrom main import ist_aktiv, filter_aktive_benutzer\n\nclass TestSozialeMedien(unittest.TestCase):\n    def test_ist_aktiv_true(self):\n        benutzer = {\"name\": \"Alice\", \"letzter_beitrag\": 10}\n        self.assertTrue(ist_aktiv(benutzer))\n\n    def test_ist_aktiv_false(self):\n        benutzer = {\"name\": \"Bob\", \"letzter_beitrag\": 40}\n        self.assertFalse(ist_aktiv(benutzer))\n\n    def test_filter_aktive_benutzer(self):\n        benutzer1 = {\"name\": \"Alice\", \"letzter_beitrag\": 10}\n        benutzer2 = {\"name\": \"Bob\", \"letzter_beitrag\": 40}\n        benutzer3 = {\"name\": \"Charlie\", \"letzter_beitrag\": 5}\n        benutzer_liste = [benutzer1, benutzer2, benutzer3]\n        erwartete_ausgabe = [benutzer1, benutzer3]\n        self.assertEqual(filter_aktive_benutzer(benutzer_liste, ist_aktiv), erwartete_ausgabe)\n\n    def test_leere_liste(self):\n        benutzer_liste = []\n        erwartete_ausgabe = []\n        self.assertEqual(filter_aktive_benutzer(benutzer_liste, ist_aktiv), erwartete_ausgabe)\n\n    def test_alle_inaktiv(self):\n        benutzer1 = {\"name\": \"Alice\", \"letzter_beitrag\": 40}\n        benutzer2 = {\"name\": \"Bob\", \"letzter_beitrag\": 50}\n        benutzer_liste = [benutzer1, benutzer2]\n        erwartete_ausgabe = []\n        self.assertEqual(filter_aktive_benutzer(benutzer_liste, ist_aktiv), erwartete_ausgabe)\n\n    def test_alle_aktiv(self):\n        benutzer1 = {\"name\": \"Alice\", \"letzter_beitrag\": 10}\n        benutzer2 = {\"name\": \"Bob\", \"letzter_beitrag\": 20}\n        benutzer_liste = [benutzer1, benutzer2]\n        erwartete_ausgabe = [benutzer1, benutzer2]\n        self.assertEqual(filter_aktive_benutzer(benutzer_liste, ist_aktiv), erwartete_ausgabe)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 118,
    "programming_concept": "Listen;Float",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia - Durchschnittliche Punktzahl berechnen\n\nSchreibe eine Funktion namens `durchschnittliche_punktzahl(punkte)`, die eine Liste von Punktzahlen (als Float-Werte) erhält und die durchschnittliche Punktzahl der Athleten berechnet und zurückgibt. \n\nBeispielaufruf: \n```python\npunkte = [9.5, 8.7, 9.8, 7.6, 8.9]\nprint(durchschnittliche_punktzahl(punkte))  # Ausgabe: 8.9\n```\n\nDie Funktion soll die durchschnittliche Punktzahl der Athleten berechnen und als Float-Wert zurückgeben.",
    "code_skeleton": "def durchschnittliche_punktzahl(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def durchschnittliche_punktzahl(punkte):\n    return sum(punkte) / len(punkte)\n\npunkte = [9.5, 8.7, 9.8, 7.6, 8.9]\nprint(durchschnittliche_punktzahl(punkte))",
    "unit_tests": "import unittest\nfrom main import durchschnittliche_punktzahl\n\nclass TestDurchschnittlichePunktzahl(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(durchschnittliche_punktzahl([9.5, 8.7, 9.8, 7.6, 8.9]), 8.9)\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittliche_punktzahl([])\n\n    def test_ein_element(self):\n        self.assertEqual(durchschnittliche_punktzahl([10.0]), 10.0)\n\n    def test_gemischte_werte(self):\n        self.assertEqual(durchschnittliche_punktzahl([1.0, 2.0, 3.0, 4.0, 5.0]), 3.0)\n\n    def test_negative_werte(self):\n        self.assertEqual(durchschnittliche_punktzahl([-1.0, -2.0, -3.0, -4.0, -5.0]), -3.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 119,
    "programming_concept": "While-Schleifen;Boolean und None",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Streaming-Dienste und Abonnement-Status\n\nSchreibe eine Funktion namens `check_abonnement_status(user_status)`, die den Abonnement-Status eines Benutzers in einem Streaming-Dienst überprüft. Die Funktion soll eine While-Schleife verwenden, um den Status zu überprüfen, bis der Benutzer entweder ein aktives Abonnement hat oder der Status `None` ist. \n\n- Wenn der Status `True` ist, soll die Funktion \"Abonnement aktiv\" ausgeben.\n- Wenn der Status `False` ist, soll die Funktion \"Abonnement inaktiv\" ausgeben.\n- Wenn der Status `None` ist, soll die Funktion \"Status unbekannt\" ausgeben und die Schleife beenden.\n\nBeispielaufruf:\n```python\ncheck_abonnement_status([False, False, True, None])\n```\n\nErwartete Ausgabe:\n```\nAbonnement inaktiv\nAbonnement inaktiv\nAbonnement aktiv\n```",
    "code_skeleton": "def check_abonnement_status(user_status):\n    ## Hier Code einfügen",
    "model_solution": "def check_abonnement_status(user_status):\n    i = 0\n    while i < len(user_status):\n        status = user_status[i]\n        if status is True:\n            print(\"Abonnement aktiv\")\n            break\n        elif status is False:\n            print(\"Abonnement inaktiv\")\n        elif status is None:\n            print(\"Status unbekannt\")\n            break\n        i += 1\n\ncheck_abonnement_status([False, False, True, None])",
    "unit_tests": "import unittest\nfrom main import check_abonnement_status\nfrom io import StringIO\nimport sys\n\nclass TestCheckAbonnementStatus(unittest.TestCase):\n    def test_abonnement_aktiv(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        check_abonnement_status([False, False, True, None])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Abonnement inaktiv\\nAbonnement inaktiv\\nAbonnement aktiv\")\n\n    def test_abonnement_inaktiv(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        check_abonnement_status([False, None])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Abonnement inaktiv\\nStatus unbekannt\")\n\n    def test_status_unbekannt(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        check_abonnement_status([None])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"Status unbekannt\")\n\n    def test_leere_liste(self):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        check_abonnement_status([])\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue().strip(), \"\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 120,
    "programming_concept": "String;Listen",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Film-Genres\n\nSchreibe eine Funktion namens `film_genres(filme)`, die eine Liste von Filmtiteln als Eingabe erhält. Jeder Filmtitel ist ein String, der den Titel des Films und das Genre in Klammern enthält, z.B. \"Inception (Sci-Fi)\". Die Funktion soll eine Liste der Genres zurückgeben, die in der Eingabeliste vorkommen. Die Genres sollen in der Ausgabe-Liste nur einmal vorkommen, auch wenn sie in der Eingabeliste mehrfach vorhanden sind.\n\nBeispielaufruf:\n```python\nfilme = [\"Inception (Sci-Fi)\", \"Titanic (Romance)\", \"The Matrix (Sci-Fi)\", \"The Notebook (Romance)\"]\nprint(film_genres(filme))\n```\n\nErwartete Ausgabe:\n```\n['Sci-Fi', 'Romance']\n```",
    "code_skeleton": "def film_genres(filme):\n    ## Hier Code einfügen",
    "model_solution": "def film_genres(filme):\n    return list({film.split('(')[-1].strip(')') for film in filme})\n\nfilme = [\"Inception (Sci-Fi)\", \"Titanic (Romance)\", \"The Matrix (Sci-Fi)\", \"The Notebook (Romance)\"]\nprint(film_genres(filme))",
    "unit_tests": "import unittest\nfrom main import film_genres\n\nclass TestFilmGenres(unittest.TestCase):\n    def test_einfacher_fall(self):\n        filme = [\"Inception (Sci-Fi)\", \"Titanic (Romance)\", \"The Matrix (Sci-Fi)\", \"The Notebook (Romance)\"]\n        self.assertEqual(set(film_genres(filme)), {\"Sci-Fi\", \"Romance\"})\n\n    def test_leere_liste(self):\n        filme = []\n        self.assertEqual(film_genres(filme), [])\n\n    def test_ein_genre(self):\n        filme = [\"Inception (Sci-Fi)\"]\n        self.assertEqual(film_genres(filme), [\"Sci-Fi\"])\n\n    def test_mehrere_genres(self):\n        filme = [\"Inception (Sci-Fi)\", \"Titanic (Romance)\", \"Avatar (Action)\", \"The Notebook (Romance)\"]\n        self.assertEqual(set(film_genres(filme)), {\"Sci-Fi\", \"Romance\", \"Action\"})\n\n    def test_verschiedene_schreibweisen(self):\n        filme = [\"Inception (Sci-Fi)\", \"Titanic (romance)\", \"Avatar (Action)\", \"The Notebook (Romance)\"]\n        self.assertEqual(set(film_genres(filme)), {\"Sci-Fi\", \"romance\", \"Action\", \"Romance\"})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 121,
    "programming_concept": "Listen;If-Else-Anweisungen",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spieler filtern\n\nSchreibe eine Funktion namens `filter_spieler(spieler_liste)`, die eine Liste von Rugby-Spielernamen und deren Positionen als Eingabe erhält. Die Funktion soll eine neue Liste zurückgeben, die nur die Namen der Spieler enthält, die auf der Position \"Stürmer\" spielen.\n\nDie Eingabeliste hat das Format:\n```python\n[(\"Name1\", \"Position1\"), (\"Name2\", \"Position2\"), ...]\n```\n\nBeispiel:\n```python\nspieler_liste = [(\"Max\", \"Stürmer\"), (\"Tom\", \"Verteidiger\"), (\"Lukas\", \"Stürmer\"), (\"Paul\", \"Flügelspieler\")]\n```\n\nAufruf:\n```python\nfilter_spieler(spieler_liste)\n```\n\nErwartete Ausgabe:\n```python\n[\"Max\", \"Lukas\"]\n```\n\nImplementiere die Funktion `filter_spieler(spieler_liste)`, die die obige Aufgabe erfüllt.",
    "code_skeleton": "def filter_spieler(spieler_liste):\n    ## Hier Code einfügen",
    "model_solution": "def filter_spieler(spieler_liste):\n    return [name for name, position in spieler_liste if position == \"Stürmer\"]\n\nspieler_liste = [(\"Max\", \"Stürmer\"), (\"Tom\", \"Verteidiger\"), (\"Lukas\", \"Stürmer\"), (\"Paul\", \"Flügelspieler\")]\nprint(filter_spieler(spieler_liste))",
    "unit_tests": "import unittest\nfrom main import filter_spieler\n\nclass TestFilterSpieler(unittest.TestCase):\n    def test_mehrere_stuermer(self):\n        self.assertEqual(filter_spieler([(\"Max\", \"Stürmer\"), (\"Tom\", \"Verteidiger\"), (\"Lukas\", \"Stürmer\"), (\"Paul\", \"Flügelspieler\")]), [\"Max\", \"Lukas\"])\n\n    def test_keine_stuermer(self):\n        self.assertEqual(filter_spieler([(\"Tom\", \"Verteidiger\"), (\"Paul\", \"Flügelspieler\")]), [])\n\n    def test_alle_stuermer(self):\n        self.assertEqual(filter_spieler([(\"Max\", \"Stürmer\"), (\"Lukas\", \"Stürmer\")]), [\"Max\", \"Lukas\"])\n\n    def test_leere_liste(self):\n        self.assertEqual(filter_spieler([]), [])\n\n    def test_ein_stuermer(self):\n        self.assertEqual(filter_spieler([(\"Max\", \"Stürmer\")]), [\"Max\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 122,
    "programming_concept": "For-Schleifen;While-Schleifen",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Vergnügungspark - Fahrgeschäfte zählen\n\nSchreibe eine Funktion namens `zaehle_fahrgeschaefte(fahrgeschaefte)`, die eine Liste von Fahrgeschäften in einem Vergnügungspark als Argument erhält. Die Funktion soll die Anzahl der Fahrgeschäfte zählen und zurückgeben, die eine bestimmte Mindestanzahl an Fahrten pro Tag durchführen. Verwende eine For-Schleife oder While-Schleife, um die Fahrgeschäfte zu durchlaufen und die Zählung durchzuführen.\n\nDie Liste `fahrgeschaefte` enthält Tupel, wobei jedes Tupel den Namen des Fahrgeschäfts und die Anzahl der Fahrten pro Tag enthält. Die Mindestanzahl an Fahrten pro Tag ist 10.\n\nBeispielaufruf:\n```python\nfahrgeschaefte = [(\"Achterbahn\", 15), (\"Riesenrad\", 8), (\"Karussell\", 12)]\nprint(zaehle_fahrgeschaefte(fahrgeschaefte))  # Ausgabe: 2\n```\n\nIn diesem Beispiel gibt es zwei Fahrgeschäfte, die mindestens 10 Fahrten pro Tag durchführen: \"Achterbahn\" und \"Karussell\".",
    "code_skeleton": "def zaehle_fahrgeschaefte(fahrgeschaefte):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fahrgeschaefte(fahrgeschaefte):\n    return sum(1 for _, fahrten in fahrgeschaefte if fahrten >= 10)\n\nfahrgeschaefte = [(\"Achterbahn\", 15), (\"Riesenrad\", 8), (\"Karussell\", 12)]\nprint(zaehle_fahrgeschaefte(fahrgeschaefte))  # Ausgabe: 2",
    "unit_tests": "import unittest\nfrom main import zaehle_fahrgeschaefte\n\nclass TestZaehleFahrgeschaefte(unittest.TestCase):\n    def test_alle_fahrgeschaefte_zaehlen(self):\n        self.assertEqual(zaehle_fahrgeschaefte([(\"Achterbahn\", 15), (\"Riesenrad\", 8), (\"Karussell\", 12)]), 2)\n\n    def test_keine_fahrgeschaefte(self):\n        self.assertEqual(zaehle_fahrgeschaefte([]), 0)\n\n    def test_alle_unter_minimum(self):\n        self.assertEqual(zaehle_fahrgeschaefte([(\"Achterbahn\", 5), (\"Riesenrad\", 3), (\"Karussell\", 2)]), 0)\n\n    def test_alle_ueber_minimum(self):\n        self.assertEqual(zaehle_fahrgeschaefte([(\"Achterbahn\", 15), (\"Riesenrad\", 18), (\"Karussell\", 12)]), 3)\n\n    def test_genau_minimum(self):\n        self.assertEqual(zaehle_fahrgeschaefte([(\"Achterbahn\", 10), (\"Riesenrad\", 10), (\"Karussell\", 10)]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 123,
    "programming_concept": "While-Schleifen;If-Else-Anweisungen",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musik-Playlist\n\nSchreibe eine Funktion namens `spiele_playlist(lieder)`, die eine Liste von Liedern als Argument erhält. Die Funktion soll jedes Lied in der Liste abspielen, bis ein bestimmtes Lied namens \"Stop\" gefunden wird. Wenn das Lied \"Stop\" gefunden wird, soll die Wiedergabe beendet werden. Wenn das Lied \"Stop\" nicht in der Liste enthalten ist, soll die gesamte Liste abgespielt werden.\n\nBeispielaufruf:\n```python\nspiele_playlist([\"Song1\", \"Song2\", \"Stop\", \"Song3\"])\n```\n\nErwartetes Verhalten:\n- \"Song1\" wird abgespielt.\n- \"Song2\" wird abgespielt.\n- Wiedergabe wird gestoppt, da \"Stop\" gefunden wurde.",
    "code_skeleton": "def spiele_playlist(lieder):\n    ## Hier Code einfügen",
    "model_solution": "def spiele_playlist(lieder):\n    for lied in lieder:\n        if lied == \"Stop\":\n            break\n        print(f\"Spiele {lied}\")\n\nspiele_playlist([\"Song1\", \"Song2\", \"Stop\", \"Song3\"])",
    "unit_tests": "import unittest\nfrom main import spiele_playlist\nfrom io import StringIO\nimport sys\n\nclass TestSpielePlaylist(unittest.TestCase):\n    def test_playlist_mit_stop(self):\n        lieder = [\"Song1\", \"Song2\", \"Stop\", \"Song3\"]\n        expected_output = \"Spiele Song1\\nSpiele Song2\\n\"\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        spiele_playlist(lieder)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\n    def test_playlist_ohne_stop(self):\n        lieder = [\"Song1\", \"Song2\", \"Song3\"]\n        expected_output = \"Spiele Song1\\nSpiele Song2\\nSpiele Song3\\n\"\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        spiele_playlist(lieder)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\n    def test_leere_playlist(self):\n        lieder = []\n        expected_output = \"\"\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        spiele_playlist(lieder)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\n    def test_playlist_nur_stop(self):\n        lieder = [\"Stop\"]\n        expected_output = \"\"\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        spiele_playlist(lieder)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 124,
    "programming_concept": "Funktionen als Variablen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Aquarium",
    "task_description": "### Übungsaufgabe: Aquarium-Temperaturkontrolle\n\nSchreibe eine Funktion namens `kontrolliere_temperatur(temperatur)`, die überprüft, ob die Temperatur in einem Aquarium im optimalen Bereich liegt. Der optimale Temperaturbereich für das Aquarium liegt zwischen 22 und 28 Grad Celsius (einschließlich). Die Funktion soll `True` zurückgeben, wenn die Temperatur im optimalen Bereich liegt, und `False`, wenn sie außerhalb dieses Bereichs liegt.\n\nZusätzlich soll eine Funktion `ist_zu_heiss_oder_zu_kalt(temperatur)` implementiert werden, die überprüft, ob die Temperatur entweder zu heiß (über 28 Grad) oder zu kalt (unter 22 Grad) ist. Diese Funktion soll `True` zurückgeben, wenn die Temperatur außerhalb des optimalen Bereichs liegt, und `False`, wenn sie innerhalb des Bereichs liegt.\n\nBeispielaufrufe:\n- `kontrolliere_temperatur(25)` gibt `True` zurück.\n- `kontrolliere_temperatur(30)` gibt `False` zurück.\n- `ist_zu_heiss_oder_zu_kalt(18)` gibt `True` zurück.\n- `ist_zu_heiss_oder_zu_kalt(24)` gibt `False` zurück.",
    "code_skeleton": "def kontrolliere_temperatur(temperatur):\n    ## Hier Code einfügen\n\ndef ist_zu_heiss_oder_zu_kalt(temperatur):\n    ## Hier Code einfügen",
    "model_solution": "def kontrolliere_temperatur(temperatur):\n    return 22 <= temperatur <= 28\n\ndef ist_zu_heiss_oder_zu_kalt(temperatur):\n    return temperatur < 22 or temperatur > 28\n\n# Beispielaufrufe\nprint(kontrolliere_temperatur(25))  # True\nprint(kontrolliere_temperatur(30))  # False\nprint(ist_zu_heiss_oder_zu_kalt(18))  # True\nprint(ist_zu_heiss_oder_zu_kalt(24))  # False",
    "unit_tests": "import unittest\n\nfrom main import kontrolliere_temperatur, ist_zu_heiss_oder_zu_kalt\n\nclass TestAquariumTemperatur(unittest.TestCase):\n    def test_kontrolliere_temperatur_optimal(self):\n        self.assertTrue(kontrolliere_temperatur(25))\n\n    def test_kontrolliere_temperatur_zu_heiss(self):\n        self.assertFalse(kontrolliere_temperatur(30))\n\n    def test_kontrolliere_temperatur_zu_kalt(self):\n        self.assertFalse(kontrolliere_temperatur(18))\n\n    def test_ist_zu_heiss_oder_zu_kalt_zu_heiss(self):\n        self.assertTrue(ist_zu_heiss_oder_zu_kalt(30))\n\n    def test_ist_zu_heiss_oder_zu_kalt_zu_kalt(self):\n        self.assertTrue(ist_zu_heiss_oder_zu_kalt(18))\n\n    def test_ist_zu_heiss_oder_zu_kalt_optimal(self):\n        self.assertFalse(ist_zu_heiss_oder_zu_kalt(24))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 125,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);For-Schleifen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rezeptauswahl basierend auf Zutaten\n\nSchreibe eine Funktion namens `rezept_auswahl(zutaten)`, die eine Liste von Zutaten als Argument erhält und basierend auf den vorhandenen Zutaten ein Rezept auswählt. Die Funktion soll die folgenden Rezepte berücksichtigen:\n\n1. **Pasta mit Tomatensauce**:\n   - Zutaten: Nudeln, Tomaten, Knoblauch\n2. **Gemüsepfanne**:\n   - Zutaten: Paprika, Zucchini, Zwiebeln\n3. **Obstsalat**:\n   - Zutaten: Apfel, Banane, Orange\n\nDie Funktion soll überprüfen, ob alle benötigten Zutaten für ein Rezept in der übergebenen Liste enthalten sind. Wenn mehrere Rezepte möglich sind, soll das erste passende Rezept ausgewählt werden. Wenn kein Rezept möglich ist, soll die Funktion \"Kein passendes Rezept gefunden\" zurückgeben.\n\nBeispielaufruf:\n```python\nzutaten = [\"Nudeln\", \"Tomaten\", \"Knoblauch\", \"Apfel\"]\nprint(rezept_auswahl(zutaten))\n```\n\nErwartete Ausgabe:\n```\nPasta mit Tomatensauce\n```",
    "code_skeleton": "def rezept_auswahl(zutaten):\n    ## Hier Code einfügen",
    "model_solution": "def rezept_auswahl(zutaten):\n    rezepte = {\n        \"Pasta mit Tomatensauce\": {\"Nudeln\", \"Tomaten\", \"Knoblauch\"},\n        \"Gemüsepfanne\": {\"Paprika\", \"Zucchini\", \"Zwiebeln\"},\n        \"Obstsalat\": {\"Apfel\", \"Banane\", \"Orange\"}\n    }\n    for rezept, benötigte_zutaten in rezepte.items():\n        if benötigte_zutaten.issubset(zutaten):\n            return rezept\n    return \"Kein passendes Rezept gefunden\"\n\nzutaten = [\"Nudeln\", \"Tomaten\", \"Knoblauch\", \"Apfel\"]\nprint(rezept_auswahl(zutaten))",
    "unit_tests": "import unittest\nfrom main import rezept_auswahl\n\nclass TestRezeptAuswahl(unittest.TestCase):\n    def test_pasta_mit_tomatensauce(self):\n        self.assertEqual(rezept_auswahl([\"Nudeln\", \"Tomaten\", \"Knoblauch\"]), \"Pasta mit Tomatensauce\")\n\n    def test_gemuesepfanne(self):\n        self.assertEqual(rezept_auswahl([\"Paprika\", \"Zucchini\", \"Zwiebeln\"]), \"Gemüsepfanne\")\n\n    def test_obstsalat(self):\n        self.assertEqual(rezept_auswahl([\"Apfel\", \"Banane\", \"Orange\"]), \"Obstsalat\")\n\n    def test_mehrere_rezepte(self):\n        self.assertEqual(rezept_auswahl([\"Nudeln\", \"Tomaten\", \"Knoblauch\", \"Paprika\", \"Zucchini\", \"Zwiebeln\"]), \"Pasta mit Tomatensauce\")\n\n    def test_keine_passenden_rezepte(self):\n        self.assertEqual(rezept_auswahl([\"Reis\", \"Huhn\", \"Sojasauce\"]), \"Kein passendes Rezept gefunden\")\n\n    def test_leere_zutatenliste(self):\n        self.assertEqual(rezept_auswahl([]), \"Kein passendes Rezept gefunden\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 126,
    "programming_concept": "Float;Listen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Durchschnittliches Gewicht von Tieren\n\nSchreibe eine Funktion namens `durchschnittliches_gewicht(tiere)`, die eine Liste von Floats als Argument nimmt. Diese Liste repräsentiert die Gewichte verschiedener Tiere in Kilogramm. Die Funktion soll das durchschnittliche Gewicht der Tiere berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\ngewichte = [4.5, 7.2, 3.8, 5.0, 6.1]\nprint(durchschnittliches_gewicht(gewichte))  # Ausgabe: 5.32\n```\n\nHinweis: Die Ausgabe kann leicht variieren aufgrund von Rundungsdifferenzen.",
    "code_skeleton": "def durchschnittliches_gewicht(tiere):\n    ## Hier Code einfügen",
    "model_solution": "def durchschnittliches_gewicht(tiere):\n    return sum(tiere) / len(tiere)\n\ngewichte = [4.5, 7.2, 3.8, 5.0, 6.1]\nprint(durchschnittliches_gewicht(gewichte))",
    "unit_tests": "import unittest\nfrom main import durchschnittliches_gewicht\n\nclass TestDurchschnittlichesGewicht(unittest.TestCase):\n    def test_durchschnitt(self):\n        self.assertAlmostEqual(durchschnittliches_gewicht([4.5, 7.2, 3.8, 5.0, 6.1]), 5.32, places=2)\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittliches_gewicht([])\n\n    def test_ein_element(self):\n        self.assertEqual(durchschnittliches_gewicht([5.0]), 5.0)\n\n    def test_ganze_zahlen(self):\n        self.assertEqual(durchschnittliches_gewicht([1, 2, 3, 4, 5]), 3.0)\n\n    def test_gemischte_zahlen(self):\n        self.assertAlmostEqual(durchschnittliches_gewicht([1.5, 2.5, 3.5, 4.5, 5.5]), 3.5, places=2)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 127,
    "programming_concept": "Tupel;Integer",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurant-Bestellung\n\nSchreibe eine Funktion namens `bestellung_aufnehmen(bestellung)`, die ein Tupel mit zwei Elementen als Argument erhält. Das erste Element ist der Name des Gerichts (String) und das zweite Element ist die Anzahl der bestellten Portionen (Integer). Die Funktion soll eine Nachricht zurückgeben, die die Bestellung zusammenfasst.\n\nBeispielaufruf: `bestellung_aufnehmen((\"Spaghetti Carbonara\", 3))` gibt `\"Sie haben 3 Portionen Spaghetti Carbonara bestellt.\"` zurück.",
    "code_skeleton": "def bestellung_aufnehmen(bestellung):\n    ## Hier Code einfügen",
    "model_solution": "def bestellung_aufnehmen(bestellung):\n    return f\"Sie haben {bestellung[1]} Portionen {bestellung[0]} bestellt.\"\n\nprint(bestellung_aufnehmen((\"Spaghetti Carbonara\", 3)))",
    "unit_tests": "import unittest\n\nfrom main import bestellung_aufnehmen\n\nclass TestBestellungAufnehmen(unittest.TestCase):\n    def test_einfache_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen((\"Spaghetti Carbonara\", 3)), \"Sie haben 3 Portionen Spaghetti Carbonara bestellt.\")\n\n    def test_eine_portion(self):\n        self.assertEqual(bestellung_aufnehmen((\"Pizza Margherita\", 1)), \"Sie haben 1 Portion Pizza Margherita bestellt.\")\n\n    def test_null_portionen(self):\n        self.assertEqual(bestellung_aufnehmen((\"Salat\", 0)), \"Sie haben 0 Portionen Salat bestellt.\")\n\n    def test_grosse_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen((\"Burger\", 100)), \"Sie haben 100 Portionen Burger bestellt.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 128,
    "programming_concept": "Boolean und None;For-Schleifen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fische zählen\n\nSchreibe eine Funktion namens `zaehle_fische(fische)`, die eine Liste von Fischen als Eingabe erhält. Jeder Eintrag in der Liste ist entweder der Name eines Fisches (als String) oder `None`, wenn kein Fisch gefangen wurde. Die Funktion soll die Anzahl der gefangenen Fische zählen und zurückgeben. \n\nBeispielaufruf:\n```python\nfische = [\"Hecht\", None, \"Karpfen\", \"Forelle\", None, \"Barsch\"]\nprint(zaehle_fische(fische))  # Ausgabe: 4\n```\n\n### Anforderungen:\n- Die Funktion soll eine Liste von Fischen als Argument akzeptieren.\n- Die Funktion soll die Anzahl der gefangenen Fische (nicht `None` Einträge) zählen und zurückgeben.\n- Verwende eine `for`-Schleife, um durch die Liste zu iterieren.\n- Nutze Boolean-Werte, um zu überprüfen, ob ein Eintrag `None` ist oder nicht.",
    "code_skeleton": "def zaehle_fische(fische):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fische):\n    return sum(1 for fisch in fische if fisch)\n\nfische = [\"Hecht\", None, \"Karpfen\", \"Forelle\", None, \"Barsch\"]\nprint(zaehle_fische(fische))  # Ausgabe: 4",
    "unit_tests": "import unittest\n\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", None, \"Karpfen\", \"Forelle\", None, \"Barsch\"]), 4)\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_alle_none(self):\n        self.assertEqual(zaehle_fische([None, None, None]), 0)\n\n    def test_alle_fische(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\", \"Barsch\"]), 4)\n\n    def test_gemischte_liste(self):\n        self.assertEqual(zaehle_fische([None, \"Hecht\", None, \"Karpfen\", \"Forelle\", None, \"Barsch\", None]), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 129,
    "programming_concept": "Boolean und None;For-Schleifen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tiere zählen\n\nSchreibe eine Funktion namens `zaehle_tiere(tier_liste)`, die eine Liste von Tieren als Argument erhält. Die Funktion soll die Anzahl der Tiere in der Liste zählen und zurückgeben. Wenn die Liste leer ist, soll die Funktion `None` zurückgeben. \n\nBeispielaufrufe:\n\n- `zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\"])` gibt `3` zurück.\n- `zaehle_tiere([])` gibt `None` zurück.\n\nVerwende eine `for`-Schleife, um die Tiere in der Liste zu zählen.",
    "code_skeleton": "def zaehle_tiere(tier_liste):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_tiere(tier_liste):\n    if not tier_liste:\n        return None\n    return len(tier_liste)\n\nprint(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\"]))  # Ausgabe: 3\nprint(zaehle_tiere([]))  # Ausgabe: None",
    "unit_tests": "import unittest\n\nfrom main import zaehle_tiere\n\nclass TestZaehleTiere(unittest.TestCase):\n    def test_mehrere_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\"]), 3)\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_tiere([]), None)\n\n    def test_ein_tier(self):\n        self.assertEqual(zaehle_tiere([\"Hund\"]), 1)\n\n    def test_zwei_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\"]), 2)\n\n    def test_viele_tiere(self):\n        self.assertEqual(zaehle_tiere([\"Hund\", \"Katze\", \"Vogel\", \"Fisch\", \"Maus\"]), 5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 130,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);String",
    "context": "Vergnügungspark",
    "task_description": "### Übungsaufgabe: Eintrittskontrolle im Vergnügungspark\n\nSchreibe eine Funktion namens `eintritt_erlaubt(alter, groesse)`, die überprüft, ob eine Person in eine bestimmte Attraktion im Vergnügungspark darf. Die Funktion soll zwei Parameter entgegennehmen: `alter` (ein Integer) und `groesse` (ein Float, der die Größe in Metern angibt).\n\nDie Bedingungen für den Eintritt sind:\n- Die Person muss mindestens 12 Jahre alt sein.\n- Die Person muss mindestens 1.40 Meter groß sein.\n\nDie Funktion soll `True` zurückgeben, wenn beide Bedingungen erfüllt sind, und `False`, wenn eine oder beide Bedingungen nicht erfüllt sind.\n\nBeispielaufrufe:\n- `eintritt_erlaubt(14, 1.50)` gibt `True` zurück.\n- `eintritt_erlaubt(10, 1.50)` gibt `False` zurück.\n- `eintritt_erlaubt(14, 1.35)` gibt `False` zurück.",
    "code_skeleton": "def eintritt_erlaubt(alter, groesse):\n    ## Hier Code einfügen",
    "model_solution": "def eintritt_erlaubt(alter, groesse):\n    return alter >= 12 and groesse >= 1.4\n\nprint(eintritt_erlaubt(14, 1.50))  # True\nprint(eintritt_erlaubt(10, 1.50))  # False\nprint(eintritt_erlaubt(14, 1.35))  # False",
    "unit_tests": "import unittest\nfrom main import eintritt_erlaubt\n\nclass TestEintrittErlaubt(unittest.TestCase):\n    def test_erlaubt(self):\n        self.assertTrue(eintritt_erlaubt(14, 1.50))\n\n    def test_zu_jung(self):\n        self.assertFalse(eintritt_erlaubt(10, 1.50))\n\n    def test_zu_klein(self):\n        self.assertFalse(eintritt_erlaubt(14, 1.35))\n\n    def test_grenze_alter(self):\n        self.assertTrue(eintritt_erlaubt(12, 1.50))\n\n    def test_grenze_groesse(self):\n        self.assertTrue(eintritt_erlaubt(14, 1.40))\n\n    def test_grenze_beide(self):\n        self.assertTrue(eintritt_erlaubt(12, 1.40))\n\n    def test_unter_grenze_alter(self):\n        self.assertFalse(eintritt_erlaubt(11, 1.40))\n\n    def test_unter_grenze_groesse(self):\n        self.assertFalse(eintritt_erlaubt(12, 1.39))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 131,
    "programming_concept": "For-Schleifen;If-Else-Anweisungen",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurant-Bestellungen\n\nSchreibe eine Funktion namens `bestellung_ueberpruefen(bestellungen)`, die eine Liste von Bestellungen als Argument erhält. Jede Bestellung ist ein Dictionary mit den Schlüsseln \"gericht\" und \"anzahl\". Die Funktion soll die Bestellungen durchgehen und überprüfen, ob die Anzahl der bestellten Gerichte größer als 0 ist. Wenn die Anzahl größer als 0 ist, soll die Funktion eine Nachricht ausgeben, die besagt, dass die Bestellung akzeptiert wurde. Andernfalls soll die Funktion eine Nachricht ausgeben, dass die Bestellung abgelehnt wurde.\n\nBeispielaufruf:\n```python\nbestellungen = [\n    {\"gericht\": \"Pizza\", \"anzahl\": 2},\n    {\"gericht\": \"Salat\", \"anzahl\": 0},\n    {\"gericht\": \"Pasta\", \"anzahl\": 3}\n]\nbestellung_ueberpruefen(bestellungen)\n```\n\nErwartete Ausgabe:\n```\nBestellung für Pizza akzeptiert.\nBestellung für Salat abgelehnt.\nBestellung für Pasta akzeptiert.\n```",
    "code_skeleton": "def bestellung_ueberpruefen(bestellungen):\n    ## Hier Code einfügen",
    "model_solution": "def bestellung_ueberpruefen(bestellungen):\n    for b in bestellungen:\n        if b[\"anzahl\"] > 0:\n            print(f\"Bestellung für {b['gericht']} akzeptiert.\")\n        else:\n            print(f\"Bestellung für {b['gericht']} abgelehnt.\")\n\nbestellungen = [\n    {\"gericht\": \"Pizza\", \"anzahl\": 2},\n    {\"gericht\": \"Salat\", \"anzahl\": 0},\n    {\"gericht\": \"Pasta\", \"anzahl\": 3}\n]\nbestellung_ueberpruefen(bestellungen)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import bestellung_ueberpruefen\n\nclass TestBestellungUeberpruefen(unittest.TestCase):\n    def test_alle_bestellungen_akzeptiert(self):\n        bestellungen = [\n            {\"gericht\": \"Pizza\", \"anzahl\": 2},\n            {\"gericht\": \"Pasta\", \"anzahl\": 3}\n        ]\n        expected_output = \"Bestellung für Pizza akzeptiert.\\nBestellung für Pasta akzeptiert.\\n\"\n        self._run_test(bestellungen, expected_output)\n\n    def test_alle_bestellungen_abgelehnt(self):\n        bestellungen = [\n            {\"gericht\": \"Salat\", \"anzahl\": 0},\n            {\"gericht\": \"Suppe\", \"anzahl\": 0}\n        ]\n        expected_output = \"Bestellung für Salat abgelehnt.\\nBestellung für Suppe abgelehnt.\\n\"\n        self._run_test(bestellungen, expected_output)\n\n    def test_gemischte_bestellungen(self):\n        bestellungen = [\n            {\"gericht\": \"Pizza\", \"anzahl\": 2},\n            {\"gericht\": \"Salat\", \"anzahl\": 0},\n            {\"gericht\": \"Pasta\", \"anzahl\": 3}\n        ]\n        expected_output = \"Bestellung für Pizza akzeptiert.\\nBestellung für Salat abgelehnt.\\nBestellung für Pasta akzeptiert.\\n\"\n        self._run_test(bestellungen, expected_output)\n\n    def test_leere_bestellungsliste(self):\n        bestellungen = []\n        expected_output = \"\"\n        self._run_test(bestellungen, expected_output)\n\n    def _run_test(self, bestellungen, expected_output):\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        bestellung_ueberpruefen(bestellungen)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 132,
    "programming_concept": "Rekursion;Funktionen als Variablen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Rekursive Berechnung von Basketballpunkten\n\nSchreibe eine rekursive Funktion namens `berechne_punkte(spieler_punkte)`, die die Gesamtpunktzahl eines Basketballspielers berechnet. Die Funktion soll eine Liste von Punkten als Argument erhalten, wobei jeder Eintrag in der Liste die Punkte eines einzelnen Spiels darstellt. Die Funktion soll die Punkte aller Spiele summieren und das Ergebnis zurückgeben.\n\nBeispielaufruf:\n```python\npunkte = [10, 15, 20, 5]\ngesamtpunkte = berechne_punkte(punkte)\nprint(gesamtpunkte)  # Ausgabe: 50\n```\n\n### Anforderungen:\n- Die Funktion `berechne_punkte` soll rekursiv implementiert werden.\n- Die Funktion soll die Punkte aller Spiele in der Liste summieren und das Ergebnis zurückgeben.\n- Die Funktion soll keine Eingaben über die Standardeingabe erwarten.\n\n### Beispiel:\n```python\npunkte = [12, 8, 25, 10]\ngesamtpunkte = berechne_punkte(punkte)\nprint(gesamtpunkte)  # Ausgabe: 55\n```\n\nImplementiere die Funktion `berechne_punkte(spieler_punkte)` in Python.",
    "code_skeleton": "def berechne_punkte(spieler_punkte):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punkte(spieler_punkte):\n    if not spieler_punkte:\n        return 0\n    return spieler_punkte[0] + berechne_punkte(spieler_punkte[1:])\n\npunkte = [12, 8, 25, 10]\ngesamtpunkte = berechne_punkte(punkte)\nprint(gesamtpunkte)  # Ausgabe: 55",
    "unit_tests": "import unittest\nfrom main import berechne_punkte\n\nclass TestBerechnePunkte(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertEqual(berechne_punkte([]), 0)\n\n    def test_ein_spiel(self):\n        self.assertEqual(berechne_punkte([10]), 10)\n\n    def test_mehrere_spiele(self):\n        self.assertEqual(berechne_punkte([10, 15, 20, 5]), 50)\n\n    def test_negativ_punkte(self):\n        self.assertEqual(berechne_punkte([10, -5, 20, -10]), 15)\n\n    def test_grosse_zahlen(self):\n        self.assertEqual(berechne_punkte([1000, 2000, 3000, 4000]), 10000)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 133,
    "programming_concept": "Rekursion;For-Schleifen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Punktestand\n\nSchreibe eine Funktion namens `berechne_punktestand(spieler_punkte)`, die eine Liste von Punkten, die von verschiedenen Basketballspielern in einem Spiel erzielt wurden, als Argument erhält. Die Funktion soll rekursiv die Summe aller Punkte berechnen und zurückgeben. Verwende zusätzlich eine For-Schleife, um die Punkte der einzelnen Spieler auszugeben.\n\nBeispiel:\n```python\nspieler_punkte = [12, 15, 10, 8, 20]\n```\n\nAufruf:\n```python\nberechne_punktestand(spieler_punkte)\n```\n\nErwartete Ausgabe:\n```\nSpieler 1 hat 12 Punkte erzielt.\nSpieler 2 hat 15 Punkte erzielt.\nSpieler 3 hat 10 Punkte erzielt.\nSpieler 4 hat 8 Punkte erzielt.\nSpieler 5 hat 20 Punkte erzielt.\n```\n\nRückgabewert:\n```\n65\n```",
    "code_skeleton": "def berechne_punktestand(spieler_punkte):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punktestand(spieler_punkte):\n    def summe(punkte):\n        if not punkte:\n            return 0\n        return punkte[0] + summe(punkte[1:])\n    \n    for i, punkte in enumerate(spieler_punkte, 1):\n        print(f\"Spieler {i} hat {punkte} Punkte erzielt.\")\n    \n    return summe(spieler_punkte)\n\nspieler_punkte = [12, 15, 10, 8, 20]\nprint(berechne_punktestand(spieler_punkte))",
    "unit_tests": "import unittest\nfrom main import berechne_punktestand\n\nclass TestBerechnePunktestand(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(berechne_punktestand([12, 15, 10, 8, 20]), 65)\n\n    def test_leere_liste(self):\n        self.assertEqual(berechne_punktestand([]), 0)\n\n    def test_ein_element(self):\n        self.assertEqual(berechne_punktestand([25]), 25)\n\n    def test_negativ_und_positiv(self):\n        self.assertEqual(berechne_punktestand([-5, 10, -3, 8]), 10)\n\n    def test_grosse_zahlen(self):\n        self.assertEqual(berechne_punktestand([1000, 2000, 3000, 4000]), 10000)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 134,
    "programming_concept": "Funktionen als Variablen;Boolean und None",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustiere und Funktionen\n\nSchreibe eine Funktion namens `ist_haustier(name)`, die überprüft, ob der übergebene Name zu einer Liste von bekannten Haustieren gehört. Die Liste der bekannten Haustiere ist: `[\"Hund\", \"Katze\", \"Hamster\", \"Papagei\", \"Goldfisch\"]`. Die Funktion soll `True` zurückgeben, wenn der Name in der Liste enthalten ist, und `False`, wenn nicht.\n\nZusätzlich soll eine Funktion `ist_haustier_oder_none(name)` implementiert werden, die `ist_haustier(name)` aufruft und `None` zurückgibt, wenn der Name nicht in der Liste der bekannten Haustiere enthalten ist.\n\nBeispielaufrufe:\n- `ist_haustier(\"Hund\")` gibt `True` zurück.\n- `ist_haustier(\"Elefant\")` gibt `False` zurück.\n- `ist_haustier_oder_none(\"Katze\")` gibt `True` zurück.\n- `ist_haustier_oder_none(\"Elefant\")` gibt `None` zurück.",
    "code_skeleton": "def ist_haustier(name):\n    ## Hier Code einfügen\n\ndef ist_haustier_oder_none(name):\n    ## Hier Code einfügen",
    "model_solution": "def ist_haustier(name):\n    return name in [\"Hund\", \"Katze\", \"Hamster\", \"Papagei\", \"Goldfisch\"]\n\ndef ist_haustier_oder_none(name):\n    return ist_haustier(name) or None\n\n# Beispielaufrufe\nprint(ist_haustier(\"Hund\"))  # True\nprint(ist_haustier(\"Elefant\"))  # False\nprint(ist_haustier_oder_none(\"Katze\"))  # True\nprint(ist_haustier_oder_none(\"Elefant\"))  # None",
    "unit_tests": "import unittest\nfrom main import ist_haustier, ist_haustier_oder_none\n\nclass TestIstHaustier(unittest.TestCase):\n    def test_hund(self):\n        self.assertTrue(ist_haustier(\"Hund\"))\n\n    def test_elefant(self):\n        self.assertFalse(ist_haustier(\"Elefant\"))\n\n    def test_katze(self):\n        self.assertTrue(ist_haustier(\"Katze\"))\n\n    def test_goldfisch(self):\n        self.assertTrue(ist_haustier(\"Goldfisch\"))\n\n    def test_leerer_string(self):\n        self.assertFalse(ist_haustier(\"\"))\n\nclass TestIstHaustierOderNone(unittest.TestCase):\n    def test_hund(self):\n        self.assertTrue(ist_haustier_oder_none(\"Hund\"))\n\n    def test_elefant(self):\n        self.assertIsNone(ist_haustier_oder_none(\"Elefant\"))\n\n    def test_katze(self):\n        self.assertTrue(ist_haustier_oder_none(\"Katze\"))\n\n    def test_goldfisch(self):\n        self.assertTrue(ist_haustier_oder_none(\"Goldfisch\"))\n\n    def test_leerer_string(self):\n        self.assertIsNone(ist_haustier_oder_none(\"\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 135,
    "programming_concept": "Listen;String",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Beliebte Serien auf Streaming-Diensten\n\nSchreibe eine Funktion namens `beliebte_serien(streaming_dienst)`, die eine Liste von Serien zurückgibt, die auf dem angegebenen Streaming-Dienst verfügbar sind. Die Funktion soll eine Liste von Strings als Eingabe erhalten, wobei jeder String den Namen eines Streaming-Dienstes darstellt. Die Funktion soll eine Liste von Seriennamen zurückgeben, die auf dem angegebenen Streaming-Dienst verfügbar sind.\n\nVerwende die folgenden Daten:\n\n- Netflix: [\"Stranger Things\", \"The Crown\", \"Black Mirror\"]\n- Amazon Prime: [\"The Boys\", \"The Marvelous Mrs. Maisel\", \"Fleabag\"]\n- Disney+: [\"The Mandalorian\", \"WandaVision\", \"Loki\"]\n\nBeispielaufruf:\n```python\nbeliebte_serien(\"Netflix\")\n```\nsollte die Liste `[\"Stranger Things\", \"The Crown\", \"Black Mirror\"]` zurückgeben.",
    "code_skeleton": "def beliebte_serien(streaming_dienst):\n    ## Hier Code einfügen",
    "model_solution": "def beliebte_serien(streaming_dienst):\n    serien = {\n        \"Netflix\": [\"Stranger Things\", \"The Crown\", \"Black Mirror\"],\n        \"Amazon Prime\": [\"The Boys\", \"The Marvelous Mrs. Maisel\", \"Fleabag\"],\n        \"Disney+\": [\"The Mandalorian\", \"WandaVision\", \"Loki\"]\n    }\n    return serien.get(streaming_dienst, [])\n\n# Beispielaufruf\nprint(beliebte_serien(\"Netflix\"))",
    "unit_tests": "import unittest\nfrom main import beliebte_serien\n\nclass TestBeliebteSerien(unittest.TestCase):\n    def test_netflix(self):\n        self.assertEqual(beliebte_serien(\"Netflix\"), [\"Stranger Things\", \"The Crown\", \"Black Mirror\"])\n\n    def test_amazon_prime(self):\n        self.assertEqual(beliebte_serien(\"Amazon Prime\"), [\"The Boys\", \"The Marvelous Mrs. Maisel\", \"Fleabag\"])\n\n    def test_disney_plus(self):\n        self.assertEqual(beliebte_serien(\"Disney+\"), [\"The Mandalorian\", \"WandaVision\", \"Loki\"])\n\n    def test_unbekannter_dienst(self):\n        self.assertEqual(beliebte_serien(\"Hulu\"), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 136,
    "programming_concept": "String;Integer",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus\n\nSchreibe eine Funktion namens `beziehungsstatus(name, jahre)`, die den Beziehungsstatus einer Person basierend auf der Anzahl der Jahre in der Beziehung ausgibt. Die Funktion soll zwei Parameter entgegennehmen: `name` (ein String) und `jahre` (ein Integer). \n\nDie Funktion soll folgende Nachrichten zurückgeben:\n- Wenn `jahre` weniger als 1 ist: \"`[Name] ist frisch verliebt!`\"\n- Wenn `jahre` zwischen 1 und 5 liegt: \"`[Name] ist in einer stabilen Beziehung.`\"\n- Wenn `jahre` mehr als 5 ist: \"`[Name] ist in einer langjährigen Beziehung.`\"\n\nBeispielaufruf:\n```python\nprint(beziehungsstatus(\"Anna\", 3))  # Ausgabe: \"Anna ist in einer stabilen Beziehung.\"\n```",
    "code_skeleton": "def beziehungsstatus(name, jahre):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(name, jahre):\n    if jahre < 1:\n        return f\"{name} ist frisch verliebt!\"\n    elif 1 <= jahre <= 5:\n        return f\"{name} ist in einer stabilen Beziehung.\"\n    else:\n        return f\"{name} ist in einer langjährigen Beziehung.\"\n\nprint(beziehungsstatus(\"Anna\", 3))  # Beispielaufruf",
    "unit_tests": "import unittest\n\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_frisch_verliebt(self):\n        self.assertEqual(beziehungsstatus(\"Anna\", 0), \"Anna ist frisch verliebt!\")\n        self.assertEqual(beziehungsstatus(\"Max\", -1), \"Max ist frisch verliebt!\")\n\n    def test_stabile_beziehung(self):\n        self.assertEqual(beziehungsstatus(\"Anna\", 1), \"Anna ist in einer stabilen Beziehung.\")\n        self.assertEqual(beziehungsstatus(\"Max\", 5), \"Max ist in einer stabilen Beziehung.\")\n        self.assertEqual(beziehungsstatus(\"Chris\", 3), \"Chris ist in einer stabilen Beziehung.\")\n\n    def test_langjaehrige_beziehung(self):\n        self.assertEqual(beziehungsstatus(\"Anna\", 6), \"Anna ist in einer langjährigen Beziehung.\")\n        self.assertEqual(beziehungsstatus(\"Max\", 10), \"Max ist in einer langjährigen Beziehung.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 137,
    "programming_concept": "While-Schleifen;Boolean und None",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Training\n\nSchreibe eine Funktion namens `basketball_training()`, die eine While-Schleife verwendet, um die Anzahl der erfolgreichen Würfe eines Spielers zu zählen. Die Funktion soll eine Liste von Würfen als Argument erhalten, wobei jeder Wurf entweder `True` (erfolgreich) oder `False` (nicht erfolgreich) ist. Die Schleife soll durch die Liste iterieren und die Anzahl der erfolgreichen Würfe zählen. Wenn die Liste leer ist, soll die Funktion `None` zurückgeben. Andernfalls soll die Funktion die Anzahl der erfolgreichen Würfe zurückgeben.\n\nBeispielaufruf:\n```python\nbasketball_training([True, False, True, True, False])\n```\nDieser Aufruf soll `3` zurückgeben, da es drei erfolgreiche Würfe gibt.",
    "code_skeleton": "def basketball_training(throws):\n    ## Hier Code einfügen",
    "model_solution": "def basketball_training(throws):\n    if not throws:\n        return None\n    count = 0\n    i = 0\n    while i < len(throws):\n        if throws[i]:\n            count += 1\n        i += 1\n    return count\n\n# Beispielaufruf\nprint(basketball_training([True, False, True, True, False]))",
    "unit_tests": "import unittest\nfrom main import basketball_training\n\nclass TestBasketballTraining(unittest.TestCase):\n    def test_empty_list(self):\n        self.assertIsNone(basketball_training([]))\n\n    def test_all_successful(self):\n        self.assertEqual(basketball_training([True, True, True]), 3)\n\n    def test_all_unsuccessful(self):\n        self.assertEqual(basketball_training([False, False, False]), 0)\n\n    def test_mixed_results(self):\n        self.assertEqual(basketball_training([True, False, True, True, False]), 3)\n\n    def test_single_successful(self):\n        self.assertEqual(basketball_training([True]), 1)\n\n    def test_single_unsuccessful(self):\n        self.assertEqual(basketball_training([False]), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 138,
    "programming_concept": "Boolean und None;String",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus überprüfen\n\nSchreibe eine Funktion namens `beziehungsstatus(status)`, die den Beziehungsstatus einer Person überprüft und eine entsprechende Nachricht zurückgibt. Die Funktion soll einen String `status` als Argument nehmen und je nach Eingabe eine passende Nachricht zurückgeben.\n\n- Wenn der `status` \"vergeben\" ist, soll die Funktion \"Herzlichen Glückwunsch zur Beziehung!\" zurückgeben.\n- Wenn der `status` \"single\" ist, soll die Funktion \"Genieße deine Freiheit!\" zurückgeben.\n- Wenn der `status` \"kompliziert\" ist, soll die Funktion \"Beziehungen können manchmal schwierig sein.\" zurückgeben.\n- Für alle anderen Eingaben soll die Funktion `None` zurückgeben.\n\nBeispielaufrufe:\n- `beziehungsstatus(\"vergeben\")` gibt \"Herzlichen Glückwunsch zur Beziehung!\" zurück.\n- `beziehungsstatus(\"single\")` gibt \"Genieße deine Freiheit!\" zurück.\n- `beziehungsstatus(\"kompliziert\")` gibt \"Beziehungen können manchmal schwierig sein.\" zurück.\n- `beziehungsstatus(\"unbekannt\")` gibt `None` zurück.",
    "code_skeleton": "def beziehungsstatus(status):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(status):\n    if status == \"vergeben\":\n        return \"Herzlichen Glückwunsch zur Beziehung!\"\n    elif status == \"single\":\n        return \"Genieße deine Freiheit!\"\n    elif status == \"kompliziert\":\n        return \"Beziehungen können manchmal schwierig sein.\"\n    else:\n        return None\n\n# Beispielaufrufe\nprint(beziehungsstatus(\"vergeben\"))\nprint(beziehungsstatus(\"single\"))\nprint(beziehungsstatus(\"kompliziert\"))\nprint(beziehungsstatus(\"unbekannt\"))",
    "unit_tests": "import unittest\n\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_vergeben(self):\n        self.assertEqual(beziehungsstatus(\"vergeben\"), \"Herzlichen Glückwunsch zur Beziehung!\")\n\n    def test_single(self):\n        self.assertEqual(beziehungsstatus(\"single\"), \"Genieße deine Freiheit!\")\n\n    def test_kompliziert(self):\n        self.assertEqual(beziehungsstatus(\"kompliziert\"), \"Beziehungen können manchmal schwierig sein.\")\n\n    def test_unbekannt(self):\n        self.assertIsNone(beziehungsstatus(\"unbekannt\"))\n\n    def test_leerer_string(self):\n        self.assertIsNone(beziehungsstatus(\"\"))\n\n    def test_none(self):\n        self.assertIsNone(beziehungsstatus(None))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 139,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);While-Schleifen",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus überprüfen\n\nSchreibe eine Funktion namens `beziehungsstatus(pruefungen)`, die eine Liste von Prüfungen (als Tupel) erhält. Jedes Tupel enthält zwei Elemente: den Namen einer Person und deren Beziehungsstatus (als String). Die Funktion soll die Anzahl der Personen in jeder der folgenden Kategorien zählen: \"Single\", \"In einer Beziehung\", \"Verheiratet\" und \"Es ist kompliziert\". Die Funktion soll ein Dictionary zurückgeben, das die Anzahl der Personen in jeder Kategorie enthält.\n\nBeispielaufruf:\n```python\npruefungen = [(\"Anna\", \"Single\"), (\"Ben\", \"In einer Beziehung\"), (\"Clara\", \"Verheiratet\"), (\"David\", \"Es ist kompliziert\"), (\"Eva\", \"Single\")]\nprint(beziehungsstatus(pruefungen))\n```\n\nErwartete Ausgabe:\n```python\n{\n    \"Single\": 2,\n    \"In einer Beziehung\": 1,\n    \"Verheiratet\": 1,\n    \"Es ist kompliziert\": 1\n}\n```",
    "code_skeleton": "def beziehungsstatus(pruefungen):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(pruefungen):\n    status_dict = {\"Single\": 0, \"In einer Beziehung\": 0, \"Verheiratet\": 0, \"Es ist kompliziert\": 0}\n    for _, status in pruefungen:\n        if status in status_dict:\n            status_dict[status] += 1\n    return status_dict\n\npruefungen = [(\"Anna\", \"Single\"), (\"Ben\", \"In einer Beziehung\"), (\"Clara\", \"Verheiratet\"), (\"David\", \"Es ist kompliziert\"), (\"Eva\", \"Single\")]\nprint(beziehungsstatus(pruefungen))",
    "unit_tests": "import unittest\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_alle_kategorien(self):\n        pruefungen = [(\"Anna\", \"Single\"), (\"Ben\", \"In einer Beziehung\"), (\"Clara\", \"Verheiratet\"), (\"David\", \"Es ist kompliziert\"), (\"Eva\", \"Single\")]\n        expected = {\"Single\": 2, \"In einer Beziehung\": 1, \"Verheiratet\": 1, \"Es ist kompliziert\": 1}\n        self.assertEqual(beziehungsstatus(pruefungen), expected)\n\n    def test_nur_single(self):\n        pruefungen = [(\"Anna\", \"Single\"), (\"Ben\", \"Single\"), (\"Clara\", \"Single\")]\n        expected = {\"Single\": 3, \"In einer Beziehung\": 0, \"Verheiratet\": 0, \"Es ist kompliziert\": 0}\n        self.assertEqual(beziehungsstatus(pruefungen), expected)\n\n    def test_leere_liste(self):\n        pruefungen = []\n        expected = {\"Single\": 0, \"In einer Beziehung\": 0, \"Verheiratet\": 0, \"Es ist kompliziert\": 0}\n        self.assertEqual(beziehungsstatus(pruefungen), expected)\n\n    def test_alle_verheiratet(self):\n        pruefungen = [(\"Anna\", \"Verheiratet\"), (\"Ben\", \"Verheiratet\"), (\"Clara\", \"Verheiratet\")]\n        expected = {\"Single\": 0, \"In einer Beziehung\": 0, \"Verheiratet\": 3, \"Es ist kompliziert\": 0}\n        self.assertEqual(beziehungsstatus(pruefungen), expected)\n\n    def test_alle_kompliziert(self):\n        pruefungen = [(\"Anna\", \"Es ist kompliziert\"), (\"Ben\", \"Es ist kompliziert\"), (\"Clara\", \"Es ist kompliziert\")]\n        expected = {\"Single\": 0, \"In einer Beziehung\": 0, \"Verheiratet\": 0, \"Es ist kompliziert\": 3}\n        self.assertEqual(beziehungsstatus(pruefungen), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 140,
    "programming_concept": "Funktionen höherer Ordnung;String",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Funktionen höherer Ordnung und Strings in der Virtuellen Realität\n\nIn der virtuellen Realität (VR) ist es wichtig, dass Objekte und Umgebungen korrekt benannt und kategorisiert werden. Schreibe eine Funktion `filter_vr_objects(objects, criteria)`, die eine Liste von VR-Objekten und eine Filterfunktion als Parameter erhält. Die Funktion soll eine neue Liste zurückgeben, die nur die Objekte enthält, die den Kriterien der Filterfunktion entsprechen.\n\nDie VR-Objekte sind als Strings in der Liste `objects` gespeichert. Die `criteria`-Funktion ist eine Funktion höherer Ordnung, die einen String als Argument nimmt und einen Boolean-Wert zurückgibt.\n\nBeispielaufruf:\n```python\ndef is_environment(obj):\n    return \"Environment\" in obj\n\nvr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\nfiltered_objects = filter_vr_objects(vr_objects, is_environment)\nprint(filtered_objects)  # Ausgabe: [\"Environment_Forest\", \"Environment_Desert\"]\n```\n\nImplementiere die Funktion `filter_vr_objects(objects, criteria)`.",
    "code_skeleton": "def filter_vr_objects(objects, criteria):\n    ## Hier Code einfügen",
    "model_solution": "def filter_vr_objects(objects, criteria):\n    return [obj for obj in objects if criteria(obj)]\n\ndef is_environment(obj):\n    return \"Environment\" in obj\n\nvr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\nfiltered_objects = filter_vr_objects(vr_objects, is_environment)\nprint(filtered_objects)  # Ausgabe: [\"Environment_Forest\", \"Environment_Desert\"]",
    "unit_tests": "import unittest\n\nfrom main import filter_vr_objects\n\nclass TestFilterVrObjects(unittest.TestCase):\n    def test_filter_environments(self):\n        def is_environment(obj):\n            return \"Environment\" in obj\n        vr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\n        self.assertEqual(filter_vr_objects(vr_objects, is_environment), [\"Environment_Forest\", \"Environment_Desert\"])\n\n    def test_filter_objects(self):\n        def is_object(obj):\n            return \"Object\" in obj\n        vr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\n        self.assertEqual(filter_vr_objects(vr_objects, is_object), [\"Object_Tree\", \"Object_Rock\"])\n\n    def test_empty_list(self):\n        def is_environment(obj):\n            return \"Environment\" in obj\n        vr_objects = []\n        self.assertEqual(filter_vr_objects(vr_objects, is_environment), [])\n\n    def test_no_match(self):\n        def is_water(obj):\n            return \"Water\" in obj\n        vr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\n        self.assertEqual(filter_vr_objects(vr_objects, is_water), [])\n\n    def test_all_match(self):\n        def is_any(obj):\n            return True\n        vr_objects = [\"Environment_Forest\", \"Object_Tree\", \"Environment_Desert\", \"Object_Rock\"]\n        self.assertEqual(filter_vr_objects(vr_objects, is_any), vr_objects)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 141,
    "programming_concept": "String;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Spielerbewertung\n\nSchreibe eine Funktion namens `bewerte_spieler(punkte, assists, rebounds)`, die die Leistung eines Basketballspielers basierend auf seinen Spielstatistiken bewertet. Die Funktion soll drei Parameter entgegennehmen:\n\n- `punkte`: Anzahl der erzielten Punkte (int)\n- `assists`: Anzahl der Assists (int)\n- `rebounds`: Anzahl der Rebounds (int)\n\nDie Bewertung erfolgt nach folgenden Kriterien:\n\n- Wenn der Spieler mehr als 20 Punkte erzielt hat und mehr als 5 Assists gegeben hat, soll die Funktion \"Hervorragende Leistung!\" zurückgeben.\n- Wenn der Spieler mehr als 15 Punkte erzielt hat und mehr als 10 Rebounds geholt hat, soll die Funktion \"Starke Leistung!\" zurückgeben.\n- Wenn der Spieler mehr als 10 Punkte erzielt hat oder mehr als 5 Assists gegeben hat, soll die Funktion \"Gute Leistung!\" zurückgeben.\n- In allen anderen Fällen soll die Funktion \"Durchschnittliche Leistung\" zurückgeben.\n\nBeispielaufrufe:\n\n```python\nbewerte_spieler(25, 6, 8)  # gibt \"Hervorragende Leistung!\" zurück\nbewerte_spieler(18, 3, 12)  # gibt \"Starke Leistung!\" zurück\nbewerte_spieler(12, 6, 4)  # gibt \"Gute Leistung!\" zurück\nbewerte_spieler(8, 4, 3)  # gibt \"Durchschnittliche Leistung\" zurück\n```",
    "code_skeleton": "def bewerte_spieler(punkte, assists, rebounds):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(punkte, assists, rebounds):\n    if punkte > 20 and assists > 5:\n        return \"Hervorragende Leistung!\"\n    elif punkte > 15 and rebounds > 10:\n        return \"Starke Leistung!\"\n    elif punkte > 10 or assists > 5:\n        return \"Gute Leistung!\"\n    else:\n        return \"Durchschnittliche Leistung\"\n\n# Beispielaufrufe\nprint(bewerte_spieler(25, 6, 8))  # Hervorragende Leistung!\nprint(bewerte_spieler(18, 3, 12))  # Starke Leistung!\nprint(bewerte_spieler(12, 6, 4))  # Gute Leistung!\nprint(bewerte_spieler(8, 4, 3))  # Durchschnittliche Leistung",
    "unit_tests": "import unittest\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler(25, 6, 8), \"Hervorragende Leistung!\")\n\n    def test_starke_leistung(self):\n        self.assertEqual(bewerte_spieler(18, 3, 12), \"Starke Leistung!\")\n\n    def test_gute_leistung_punkte(self):\n        self.assertEqual(bewerte_spieler(12, 4, 4), \"Gute Leistung!\")\n\n    def test_gute_leistung_assists(self):\n        self.assertEqual(bewerte_spieler(8, 6, 3), \"Gute Leistung!\")\n\n    def test_durchschnittliche_leistung(self):\n        self.assertEqual(bewerte_spieler(8, 4, 3), \"Durchschnittliche Leistung\")\n\n    def test_grenzwert_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler(21, 6, 5), \"Hervorragende Leistung!\")\n\n    def test_grenzwert_starke_leistung(self):\n        self.assertEqual(bewerte_spieler(16, 4, 11), \"Starke Leistung!\")\n\n    def test_grenzwert_gute_leistung(self):\n        self.assertEqual(bewerte_spieler(11, 6, 4), \"Gute Leistung!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 142,
    "programming_concept": "While-Schleifen;If-Else-Anweisungen",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Filmempfehlung basierend auf Bewertungen\n\nSchreibe eine Funktion namens `film_empfehlung(bewertungen)`, die eine Liste von Bewertungen (Zahlen von 1 bis 5) als Argument erhält. Die Funktion soll die durchschnittliche Bewertung berechnen und basierend auf dieser Bewertung eine Empfehlung ausgeben.\n\n- Wenn die durchschnittliche Bewertung 4 oder höher ist, soll die Funktion \"Sehr empfehlenswert!\" zurückgeben.\n- Wenn die durchschnittliche Bewertung zwischen 3 und 4 liegt, soll die Funktion \"Empfehlenswert\" zurückgeben.\n- Wenn die durchschnittliche Bewertung zwischen 2 und 3 liegt, soll die Funktion \"Durchschnittlich\" zurückgeben.\n- Wenn die durchschnittliche Bewertung unter 2 liegt, soll die Funktion \"Nicht empfehlenswert\" zurückgeben.\n\nBeispielaufruf:\n```python\nprint(film_empfehlung([5, 4, 3, 4, 5]))  # Ausgabe: \"Sehr empfehlenswert!\"\n```",
    "code_skeleton": "def film_empfehlung(bewertungen):\n    ## Hier Code einfügen",
    "model_solution": "def film_empfehlung(bewertungen):\n    avg = sum(bewertungen) / len(bewertungen)\n    if avg >= 4:\n        return \"Sehr empfehlenswert!\"\n    elif avg >= 3:\n        return \"Empfehlenswert\"\n    elif avg >= 2:\n        return \"Durchschnittlich\"\n    else:\n        return \"Nicht empfehlenswert\"\n\nprint(film_empfehlung([5, 4, 3, 4, 5]))",
    "unit_tests": "import unittest\nfrom main import film_empfehlung\n\nclass TestFilmEmpfehlung(unittest.TestCase):\n    def test_sehr_empfehlenswert(self):\n        self.assertEqual(film_empfehlung([5, 4, 4, 5, 5]), \"Sehr empfehlenswert!\")\n\n    def test_empfehlenswert(self):\n        self.assertEqual(film_empfehlung([3, 3, 4, 3, 3]), \"Empfehlenswert\")\n\n    def test_durchschnittlich(self):\n        self.assertEqual(film_empfehlung([2, 2, 3, 2, 2]), \"Durchschnittlich\")\n\n    def test_nicht_empfehlenswert(self):\n        self.assertEqual(film_empfehlung([1, 1, 2, 1, 1]), \"Nicht empfehlenswert\")\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            film_empfehlung([])\n\n    def test_ein_element(self):\n        self.assertEqual(film_empfehlung([5]), \"Sehr empfehlenswert!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 143,
    "programming_concept": "Listen;Rekursion",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Follower-Zählung in sozialen Medien\n\nIn sozialen Medien ist es oft wichtig, die Anzahl der Follower eines Benutzers zu kennen. Schreibe eine rekursive Funktion `zaehle_follower(follower_liste)`, die die Anzahl der Follower in einer verschachtelten Liste zählt. Die Liste kann sowohl einzelne Follower als auch weitere Listen von Followern enthalten.\n\nBeispiel:\n```python\nfollower_liste = [\"Anna\", [\"Ben\", \"Clara\"], \"David\", [\"Eva\", [\"Frank\", \"Grace\"]]]\n```\n\nIn diesem Beispiel hat der Benutzer insgesamt 6 Follower.\n\nImplementiere die Funktion `zaehle_follower(follower_liste)`, die die Anzahl der Follower in der verschachtelten Liste zurückgibt.\n\nBeispielaufruf:\n```python\nprint(zaehle_follower(follower_liste))  # Ausgabe: 6\n```",
    "code_skeleton": "def zaehle_follower(follower_liste):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_follower(follower_liste):\n    if not follower_liste:\n        return 0\n    if isinstance(follower_liste[0], list):\n        return zaehle_follower(follower_liste[0]) + zaehle_follower(follower_liste[1:])\n    return 1 + zaehle_follower(follower_liste[1:])\n\nfollower_liste = [\"Anna\", [\"Ben\", \"Clara\"], \"David\", [\"Eva\", [\"Frank\", \"Grace\"]]]\nprint(zaehle_follower(follower_liste))  # Ausgabe: 6",
    "unit_tests": "import unittest\n\nfrom main import zaehle_follower\n\nclass TestZaehleFollower(unittest.TestCase):\n    def test_einfache_liste(self):\n        self.assertEqual(zaehle_follower([\"Anna\", \"Ben\", \"Clara\"]), 3)\n\n    def test_verschachtelte_liste(self):\n        self.assertEqual(zaehle_follower([\"Anna\", [\"Ben\", \"Clara\"], \"David\", [\"Eva\", [\"Frank\", \"Grace\"]]]), 6)\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_follower([]), 0)\n\n    def test_ein_follower(self):\n        self.assertEqual(zaehle_follower([\"Anna\"]), 1)\n\n    def test_tief_verschachtelte_liste(self):\n        self.assertEqual(zaehle_follower([\"Anna\", [\"Ben\", [\"Clara\", [\"David\", [\"Eva\"]]]]]), 5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 144,
    "programming_concept": "Float;While-Schleifen",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musik-Playlist\n\nSchreibe eine Funktion namens `playlist_dauer(lieder)`, die eine Liste von Liedern als Eingabe erhält. Jedes Lied ist durch seine Dauer in Minuten als Float-Wert dargestellt. Die Funktion soll die Gesamtdauer der Playlist berechnen und zurückgeben. Verwende eine `while`-Schleife, um die Gesamtdauer zu berechnen.\n\nBeispielaufruf:\n```python\nlieder = [3.5, 4.0, 2.75, 5.25]\nprint(playlist_dauer(lieder))  # Ausgabe: 15.5\n```\n\n### Anforderungen:\n- Die Funktion soll eine `while`-Schleife verwenden.\n- Die Funktion soll die Gesamtdauer der Playlist als Float-Wert zurückgeben.",
    "code_skeleton": "def playlist_dauer(lieder):\n    ## Hier Code einfügen",
    "model_solution": "def playlist_dauer(lieder):\n    i, gesamt = 0, 0.0\n    while i < len(lieder):\n        gesamt += lieder[i]\n        i += 1\n    return gesamt\n\nlieder = [3.5, 4.0, 2.75, 5.25]\nprint(playlist_dauer(lieder))",
    "unit_tests": "import unittest\nfrom main import playlist_dauer\n\nclass TestPlaylistDauer(unittest.TestCase):\n    def test_einfache_playlist(self):\n        self.assertEqual(playlist_dauer([3.5, 4.0, 2.75, 5.25]), 15.5)\n\n    def test_leere_playlist(self):\n        self.assertEqual(playlist_dauer([]), 0.0)\n\n    def test_ein_lied(self):\n        self.assertEqual(playlist_dauer([4.5]), 4.5)\n\n    def test_gemischte_dauern(self):\n        self.assertEqual(playlist_dauer([1.0, 2.5, 3.75, 4.25]), 11.5)\n\n    def test_grosse_playlist(self):\n        self.assertEqual(playlist_dauer([1.0] * 1000), 1000.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 145,
    "programming_concept": "Funktionen als Variablen;If-Else-Anweisungen",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus überprüfen\n\nSchreibe eine Funktion namens `beziehungsstatus(status)`, die den aktuellen Beziehungsstatus einer Person überprüft und eine entsprechende Nachricht zurückgibt. Die Funktion soll eine der folgenden Nachrichten zurückgeben, basierend auf dem übergebenen Status:\n\n- Wenn der Status \"vergeben\" ist, soll die Nachricht \"Herzlichen Glückwunsch zur Beziehung!\" zurückgegeben werden.\n- Wenn der Status \"single\" ist, soll die Nachricht \"Genieße deine Freiheit!\" zurückgegeben werden.\n- Wenn der Status \"kompliziert\" ist, soll die Nachricht \"Beziehungen können manchmal schwierig sein.\" zurückgegeben werden.\n- Für alle anderen Status soll die Nachricht \"Unbekannter Beziehungsstatus.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `beziehungsstatus(\"vergeben\")` gibt \"Herzlichen Glückwunsch zur Beziehung!\" zurück.\n- `beziehungsstatus(\"single\")` gibt \"Genieße deine Freiheit!\" zurück.\n- `beziehungsstatus(\"kompliziert\")` gibt \"Beziehungen können manchmal schwierig sein.\" zurück.\n- `beziehungsstatus(\"verwitwet\")` gibt \"Unbekannter Beziehungsstatus.\" zurück.",
    "code_skeleton": "def beziehungsstatus(status):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(status):\n    if status == \"vergeben\":\n        return \"Herzlichen Glückwunsch zur Beziehung!\"\n    elif status == \"single\":\n        return \"Genieße deine Freiheit!\"\n    elif status == \"kompliziert\":\n        return \"Beziehungen können manchmal schwierig sein.\"\n    else:\n        return \"Unbekannter Beziehungsstatus.\"\n\n# Beispielaufrufe\nprint(beziehungsstatus(\"vergeben\"))\nprint(beziehungsstatus(\"single\"))\nprint(beziehungsstatus(\"kompliziert\"))\nprint(beziehungsstatus(\"verwitwet\"))",
    "unit_tests": "import unittest\n\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_vergeben(self):\n        self.assertEqual(beziehungsstatus(\"vergeben\"), \"Herzlichen Glückwunsch zur Beziehung!\")\n\n    def test_single(self):\n        self.assertEqual(beziehungsstatus(\"single\"), \"Genieße deine Freiheit!\")\n\n    def test_kompliziert(self):\n        self.assertEqual(beziehungsstatus(\"kompliziert\"), \"Beziehungen können manchmal schwierig sein.\")\n\n    def test_unbekannt(self):\n        self.assertEqual(beziehungsstatus(\"verwitwet\"), \"Unbekannter Beziehungsstatus.\")\n\n    def test_leerer_string(self):\n        self.assertEqual(beziehungsstatus(\"\"), \"Unbekannter Beziehungsstatus.\")\n\n    def test_none(self):\n        self.assertEqual(beziehungsstatus(None), \"Unbekannter Beziehungsstatus.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 146,
    "programming_concept": "Listen;Tupel",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Gartenarbeit mit Listen und Tupeln\n\nSchreibe eine Funktion namens `pflanzen_info(pflanzen_liste)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel enthält den Namen einer Pflanze und die Anzahl der Pflanzen im Garten. Die Funktion soll eine neue Liste zurückgeben, die nur die Namen der Pflanzen enthält, die mehr als 5 Mal im Garten vorhanden sind.\n\nBeispielaufruf:\n```python\npflanzen_liste = [(\"Tomate\", 10), (\"Gurke\", 3), (\"Karotte\", 7), (\"Salat\", 2)]\nprint(pflanzen_info(pflanzen_liste))\n```\n\nErwartete Ausgabe:\n```\n['Tomate', 'Karotte']\n```",
    "code_skeleton": "def pflanzen_info(pflanzen_liste):\n    ## Hier Code einfügen",
    "model_solution": "def pflanzen_info(pflanzen_liste):\n    return [name for name, anzahl in pflanzen_liste if anzahl > 5]\n\npflanzen_liste = [(\"Tomate\", 10), (\"Gurke\", 3), (\"Karotte\", 7), (\"Salat\", 2)]\nprint(pflanzen_info(pflanzen_liste))",
    "unit_tests": "import unittest\nfrom main import pflanzen_info\n\nclass TestPflanzenInfo(unittest.TestCase):\n    def test_mehr_als_fuenf(self):\n        self.assertEqual(pflanzen_info([(\"Tomate\", 10), (\"Gurke\", 3), (\"Karotte\", 7), (\"Salat\", 2)]), [\"Tomate\", \"Karotte\"])\n\n    def test_keine_pflanzen(self):\n        self.assertEqual(pflanzen_info([]), [])\n\n    def test_alle_weniger_als_fuenf(self):\n        self.assertEqual(pflanzen_info([(\"Tomate\", 1), (\"Gurke\", 2), (\"Karotte\", 3), (\"Salat\", 4)]), [])\n\n    def test_alle_mehr_als_fuenf(self):\n        self.assertEqual(pflanzen_info([(\"Tomate\", 6), (\"Gurke\", 7), (\"Karotte\", 8), (\"Salat\", 9)]), [\"Tomate\", \"Gurke\", \"Karotte\", \"Salat\"])\n\n    def test_genau_fuenf(self):\n        self.assertEqual(pflanzen_info([(\"Tomate\", 5), (\"Gurke\", 5), (\"Karotte\", 5), (\"Salat\", 5)]), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 147,
    "programming_concept": "Tupel;For-Schleifen",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tiere und ihre Lebensräume\n\nSchreibe eine Funktion namens `tier_lebensraum(tiere)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel enthält den Namen eines Tieres und seinen Lebensraum. Die Funktion soll eine Liste der Tiere zurückgeben, die im Wald leben.\n\nBeispielaufruf:\n```python\ntiere = [(\"Löwe\", \"Savanne\"), (\"Fuchs\", \"Wald\"), (\"Elefant\", \"Savanne\"), (\"Hirsch\", \"Wald\")]\nprint(tier_lebensraum(tiere))\n```\n\nErwartete Ausgabe:\n```\n['Fuchs', 'Hirsch']\n```",
    "code_skeleton": "def tier_lebensraum(tiere):\n    ## Hier Code einfügen",
    "model_solution": "def tier_lebensraum(tiere):\n    return [tier for tier, lebensraum in tiere wenn lebensraum == \"Wald\"]\n\ntiere = [(\"Löwe\", \"Savanne\"), (\"Fuchs\", \"Wald\"), (\"Elefant\", \"Savanne\"), (\"Hirsch\", \"Wald\")]\nprint(tier_lebensraum(tiere))",
    "unit_tests": "import unittest\n\nfrom main import tier_lebensraum\n\nclass TestTierLebensraum(unittest.TestCase):\n    def test_lebensraum_wald(self):\n        tiere = [(\"Löwe\", \"Savanne\"), (\"Fuchs\", \"Wald\"), (\"Elefant\", \"Savanne\"), (\"Hirsch\", \"Wald\")]\n        self.assertEqual(tier_lebensraum(tiere), [\"Fuchs\", \"Hirsch\"])\n\n    def test_keine_tiere_im_wald(self):\n        tiere = [(\"Löwe\", \"Savanne\"), (\"Elefant\", \"Savanne\")]\n        self.assertEqual(tier_lebensraum(tiere), [])\n\n    def test_alle_tiere_im_wald(self):\n        tiere = [(\"Fuchs\", \"Wald\"), (\"Hirsch\", \"Wald\")]\n        self.assertEqual(tier_lebensraum(tiere), [\"Fuchs\", \"Hirsch\"])\n\n    def test_leere_liste(self):\n        tiere = []\n        self.assertEqual(tier_lebensraum(tiere), [])\n\n    def test_verschiedene_lebensraeume(self):\n        tiere = [(\"Löwe\", \"Savanne\"), (\"Fuchs\", \"Wald\"), (\"Pinguin\", \"Antarktis\"), (\"Hirsch\", \"Wald\"), (\"Känguru\", \"Australien\")]\n        self.assertEqual(tier_lebensraum(tiere), [\"Fuchs\", \"Hirsch\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 148,
    "programming_concept": "Integer;String",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Psychische Gesundheit\n\nSchreibe eine Funktion namens `stimmungs_analyse(stimmung)`, die eine Stimmung als String entgegennimmt und eine entsprechende Nachricht zurückgibt. Die Stimmung kann entweder \"glücklich\", \"traurig\" oder \"gestresst\" sein. \n\n- Bei \"glücklich\" soll die Funktion \"Das ist großartig! Mach weiter so!\" zurückgeben.\n- Bei \"traurig\" soll die Funktion \"Es ist okay, traurig zu sein. Sprich mit jemandem darüber.\" zurückgeben.\n- Bei \"gestresst\" soll die Funktion \"Versuche, dir eine Pause zu gönnen und zu entspannen.\" zurückgeben.\n\nBeispielaufrufe:\n- `stimmungs_analyse(\"glücklich\")` gibt \"Das ist großartig! Mach weiter so!\" zurück.\n- `stimmungs_analyse(\"traurig\")` gibt \"Es ist okay, traurig zu sein. Sprich mit jemandem darüber.\" zurück.\n- `stimmungs_analyse(\"gestresst\")` gibt \"Versuche, dir eine Pause zu gönnen und zu entspannen.\" zurück.",
    "code_skeleton": "def stimmungs_analyse(stimmung):\n    ## Hier Code einfügen",
    "model_solution": "def stimmungs_analyse(stimmung):\n    if stimmung == \"glücklich\":\n        return \"Das ist großartig! Mach weiter so!\"\n    elif stimmung == \"traurig\":\n        return \"Es ist okay, traurig zu sein. Sprich mit jemandem darüber.\"\n    elif stimmung == \"gestresst\":\n        return \"Versuche, dir eine Pause zu gönnen und zu entspannen.\"\n\nprint(stimmungs_analyse(\"glücklich\"))\nprint(stimmungs_analyse(\"traurig\"))\nprint(stimmungs_analyse(\"gestresst\"))",
    "unit_tests": "import unittest\nfrom main import stimmungs_analyse\n\nclass TestStimmungsAnalyse(unittest.TestCase):\n    def test_gluecklich(self):\n        self.assertEqual(stimmungs_analyse(\"glücklich\"), \"Das ist großartig! Mach weiter so!\")\n\n    def test_traurig(self):\n        self.assertEqual(stimmungs_analyse(\"traurig\"), \"Es ist okay, traurig zu sein. Sprich mit jemandem darüber.\")\n\n    def test_gestresst(self):\n        self.assertEqual(stimmungs_analyse(\"gestresst\"), \"Versuche, dir eine Pause zu gönnen und zu entspannen.\")\n\n    def test_unbekannte_stimmung(self):\n        self.assertIsNone(stimmungs_analyse(\"unbekannt\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 149,
    "programming_concept": "String;Operationen mit Zahlen",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillenspiegel\n\nSchreibe eine Funktion namens `medaillenspiegel(land, gold, silber, bronze)`, die die Anzahl der gewonnenen Medaillen eines Landes bei den Olympischen Spielen berechnet und eine entsprechende Nachricht zurückgibt.\n\nDie Funktion soll folgende Parameter haben:\n- `land` (String): Der Name des Landes.\n- `gold` (int): Die Anzahl der gewonnenen Goldmedaillen.\n- `silber` (int): Die Anzahl der gewonnenen Silbermedaillen.\n- `bronze` (int): Die Anzahl der gewonnenen Bronzemedaillen.\n\nDie Funktion soll die Gesamtzahl der Medaillen berechnen und eine Nachricht im folgenden Format zurückgeben:\n```\n[Land] hat insgesamt [Gesamtzahl] Medaillen gewonnen: [Gold] Gold, [Silber] Silber, [Bronze] Bronze.\n```\n\nBeispielaufruf:\n```python\nprint(medaillenspiegel(\"Deutschland\", 10, 5, 7))\n```\n\nBeispielausgabe:\n```\nDeutschland hat insgesamt 22 Medaillen gewonnen: 10 Gold, 5 Silber, 7 Bronze.\n```",
    "code_skeleton": "def medaillenspiegel(land, gold, silber, bronze):\n    ## Hier Code einfügen",
    "model_solution": "def medaillenspiegel(land, gold, silber, bronze):\n    gesamt = gold + silber + bronze\n    return f\"{land} hat insgesamt {gesamt} Medaillen gewonnen: {gold} Gold, {silber} Silber, {bronze} Bronze.\"\n\nprint(medaillenspiegel(\"Deutschland\", 10, 5, 7))",
    "unit_tests": "import unittest\nfrom main import medaillenspiegel\n\nclass TestMedaillenspiegel(unittest.TestCase):\n    def test_deutschland(self):\n        self.assertEqual(medaillenspiegel(\"Deutschland\", 10, 5, 7), \"Deutschland hat insgesamt 22 Medaillen gewonnen: 10 Gold, 5 Silber, 7 Bronze.\")\n\n    def test_usa(self):\n        self.assertEqual(medaillenspiegel(\"USA\", 15, 10, 5), \"USA hat insgesamt 30 Medaillen gewonnen: 15 Gold, 10 Silber, 5 Bronze.\")\n\n    def test_china(self):\n        self.assertEqual(medaillenspiegel(\"China\", 8, 12, 6), \"China hat insgesamt 26 Medaillen gewonnen: 8 Gold, 12 Silber, 6 Bronze.\")\n\n    def test_null_medaillen(self):\n        self.assertEqual(medaillenspiegel(\"Niemandsland\", 0, 0, 0), \"Niemandsland hat insgesamt 0 Medaillen gewonnen: 0 Gold, 0 Silber, 0 Bronze.\")\n\n    def test_randfall(self):\n        self.assertEqual(medaillenspiegel(\"Testland\", 1, 0, 0), \"Testland hat insgesamt 1 Medaille gewonnen: 1 Gold, 0 Silber, 0 Bronze.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 150,
    "programming_concept": "Boolean und None;Rekursion",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Filmempfehlung basierend auf Bewertungen\n\nSchreibe eine rekursive Funktion `empfehle_film(filme, bewertung)`, die eine Liste von Filmen und eine Bewertung als Parameter erhält. Jeder Film in der Liste ist ein Dictionary mit den Schlüsseln `titel` und `bewertung`. Die Funktion soll den ersten Film zurückgeben, dessen Bewertung größer oder gleich der übergebenen Bewertung ist. Wenn kein solcher Film gefunden wird, soll die Funktion `None` zurückgeben.\n\nBeispielaufruf:\n```python\nfilme = [\n    {\"titel\": \"Film A\", \"bewertung\": 7.5},\n    {\"titel\": \"Film B\", \"bewertung\": 8.0},\n    {\"titel\": \"Film C\", \"bewertung\": 6.0}\n]\nprint(empfehle_film(filme, 7.0))  # Gibt {\"titel\": \"Film A\", \"bewertung\": 7.5} zurück\nprint(empfehle_film(filme, 8.5))  # Gibt None zurück\n```\n\nImplementiere die Funktion `empfehle_film(filme, bewertung)`.",
    "code_skeleton": "def empfehle_film(filme, bewertung):\n    ## Hier Code einfügen",
    "model_solution": "def empfehle_film(filme, bewertung):\n    if not filme:\n        return None\n    if filme[0]['bewertung'] >= bewertung:\n        return filme[0]\n    return empfehle_film(filme[1:], bewertung)\n\nfilme = [\n    {\"titel\": \"Film A\", \"bewertung\": 7.5},\n    {\"titel\": \"Film B\", \"bewertung\": 8.0},\n    {\"titel\": \"Film C\", \"bewertung\": 6.0}\n]\nprint(empfehle_film(filme, 7.0))  # Gibt {\"titel\": \"Film A\", \"bewertung\": 7.5} zurück\nprint(empfehle_film(filme, 8.5))  # Gibt None zurück",
    "unit_tests": "import unittest\n\nfrom main import empfehle_film\n\nclass TestEmpfehleFilm(unittest.TestCase):\n    def test_film_gefunden(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 7.5},\n            {\"titel\": \"Film B\", \"bewertung\": 8.0},\n            {\"titel\": \"Film C\", \"bewertung\": 6.0}\n        ]\n        self.assertEqual(empfehle_film(filme, 7.0), {\"titel\": \"Film A\", \"bewertung\": 7.5})\n\n    def test_keine_film_gefunden(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 7.5},\n            {\"titel\": \"Film B\", \"bewertung\": 8.0},\n            {\"titel\": \"Film C\", \"bewertung\": 6.0}\n        ]\n        self.assertIsNone(empfehle_film(filme, 8.5))\n\n    def test_leere_liste(self):\n        filme = []\n        self.assertIsNone(empfehle_film(filme, 7.0))\n\n    def test_alle_filme_unter_bewertung(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 5.5},\n            {\"titel\": \"Film B\", \"bewertung\": 6.0},\n            {\"titel\": \"Film C\", \"bewertung\": 4.0}\n        ]\n        self.assertIsNone(empfehle_film(filme, 7.0))\n\n    def test_erste_film_gefunden(self):\n        filme = [\n            {\"titel\": \"Film A\", \"bewertung\": 7.0},\n            {\"titel\": \"Film B\", \"bewertung\": 8.0},\n            {\"titel\": \"Film C\", \"bewertung\": 6.0}\n        ]\n        self.assertEqual(empfehle_film(filme, 7.0), {\"titel\": \"Film A\", \"bewertung\": 7.0})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 151,
    "programming_concept": "String;Integer;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fangquote beim Angeln\n\nSchreibe eine Funktion namens `fangquote(fischart, gewicht)`, die überprüft, ob ein gefangener Fisch den Mindestanforderungen entspricht. Die Funktion soll zwei Parameter entgegennehmen: `fischart` (String) und `gewicht` (Integer). \n\nDie Mindestanforderungen sind wie folgt:\n- Für \"Hecht\" muss das Gewicht mindestens 5 kg betragen.\n- Für \"Zander\" muss das Gewicht mindestens 3 kg betragen.\n- Für \"Barsch\" muss das Gewicht mindestens 1 kg betragen.\n\nDie Funktion soll `True` zurückgeben, wenn der Fisch den Mindestanforderungen entspricht, und `False`, wenn nicht.\n\nBeispielaufrufe:\n- `fangquote(\"Hecht\", 6)` gibt `True` zurück.\n- `fangquote(\"Zander\", 2)` gibt `False` zurück.",
    "code_skeleton": "def fangquote(fischart, gewicht):\n    ## Hier Code einfügen",
    "model_solution": "def fangquote(fischart, gewicht):\n    mindestgewicht = {\"Hecht\": 5, \"Zander\": 3, \"Barsch\": 1}\n    return gewicht >= mindestgewicht.get(fischart, float('inf'))\n\n# Beispielaufrufe\nprint(fangquote(\"Hecht\", 6))  # True\nprint(fangquote(\"Zander\", 2))  # False",
    "unit_tests": "import unittest\nfrom main import fangquote\n\nclass TestFangquote(unittest.TestCase):\n    def test_hecht_ueber_mindestgewicht(self):\n        self.assertTrue(fangquote(\"Hecht\", 6))\n\n    def test_hecht_unter_mindestgewicht(self):\n        self.assertFalse(fangquote(\"Hecht\", 4))\n\n    def test_zander_ueber_mindestgewicht(self):\n        self.assertTrue(fangquote(\"Zander\", 4))\n\n    def test_zander_unter_mindestgewicht(self):\n        self.assertFalse(fangquote(\"Zander\", 2))\n\n    def test_barsch_ueber_mindestgewicht(self):\n        self.assertTrue(fangquote(\"Barsch\", 2))\n\n    def test_barsch_unter_mindestgewicht(self):\n        self.assertFalse(fangquote(\"Barsch\", 0.5))\n\n    def test_unbekannte_fischart(self):\n        self.assertFalse(fangquote(\"Karpfen\", 10))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 152,
    "programming_concept": "Operationen mit Zahlen;String;Float",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillenrechner\n\nSchreibe eine Funktion namens `medaillen_rechner(gold, silber, bronze)`, die die Gesamtpunktzahl eines Landes bei den Olympischen Spielen berechnet. Die Punkteverteilung ist wie folgt:\n\n- Goldmedaille: 3 Punkte\n- Silbermedaille: 2 Punkte\n- Bronzemedaille: 1 Punkt\n\nDie Funktion soll die Gesamtpunktzahl berechnen und als Fließkommazahl (Float) zurückgeben. \n\nBeispielaufruf: \n```python\nmedaillen_rechner(5, 3, 2)\n```\nDieser Aufruf sollte die Gesamtpunktzahl für 5 Gold-, 3 Silber- und 2 Bronzemedaillen berechnen und zurückgeben.",
    "code_skeleton": "def medaillen_rechner(gold, silber, bronze):\n    ## Hier Code einfügen",
    "model_solution": "def medaillen_rechner(gold, silber, bronze):\n    return float(3 * gold + 2 * silber + 1 * bronze)\n\nprint(medaillen_rechner(5, 3, 2))",
    "unit_tests": "import unittest\nfrom main import medaillen_rechner\n\nclass TestMedaillenRechner(unittest.TestCase):\n    def test_alle_medaillen(self):\n        self.assertEqual(medaillen_rechner(5, 3, 2), 5*3 + 3*2 + 2*1)\n\n    def test_keine_medaillen(self):\n        self.assertEqual(medaillen_rechner(0, 0, 0), 0.0)\n\n    def test_nur_gold(self):\n        self.assertEqual(medaillen_rechner(10, 0, 0), 10*3)\n\n    def test_nur_silber(self):\n        self.assertEqual(medaillen_rechner(0, 10, 0), 10*2)\n\n    def test_nur_bronze(self):\n        self.assertEqual(medaillen_rechner(0, 0, 10), 10*1)\n\n    def test_mixed_medaillen(self):\n        self.assertEqual(medaillen_rechner(1, 1, 1), 3 + 2 + 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 153,
    "programming_concept": "For-Schleifen;If-Else-Anweisungen;Operationen mit Zahlen",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustierfutter-Berechnung\n\nSchreibe eine Funktion namens `berechne_futterbedarf(haustiere)`, die eine Liste von Haustieren und deren Gewichten (in Kilogramm) als Argument erhält. Die Funktion soll den täglichen Futterbedarf für jedes Haustier berechnen und eine Liste mit den Ergebnissen zurückgeben. \n\nDer tägliche Futterbedarf wird wie folgt berechnet:\n- Für Hunde: 5% des Körpergewichts\n- Für Katzen: 3% des Körpergewichts\n- Für andere Haustiere: 2% des Körpergewichts\n\nDie Liste der Haustiere wird als Liste von Tupeln übergeben, wobei jedes Tupel den Namen des Haustiers und sein Gewicht enthält. Beispiel: `[(\"Hund\", 20), (\"Katze\", 5), (\"Hamster\", 0.5)]`\n\nBeispielaufruf:\n```python\nhaustiere = [(\"Hund\", 20), (\"Katze\", 5), (\"Hamster\", 0.5)]\nprint(berechne_futterbedarf(haustiere))\n```\n\nErwartete Ausgabe:\n```python\n[1.0, 0.15, 0.01]\n```",
    "code_skeleton": "def berechne_futterbedarf(haustiere):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_futterbedarf(haustiere):\n    return [gewicht * (0.05 if tier == \"Hund\" else 0.03 if tier == \"Katze\" else 0.02) for tier, gewicht in haustiere]\n\nhaustiere = [(\"Hund\", 20), (\"Katze\", 5), (\"Hamster\", 0.5)]\nprint(berechne_futterbedarf(haustiere))",
    "unit_tests": "import unittest\nfrom main import berechne_futterbedarf\n\nclass TestBerechneFutterbedarf(unittest.TestCase):\n    def test_hunde_und_katzen(self):\n        self.assertEqual(berechne_futterbedarf([(\"Hund\", 20), (\"Katze\", 5)]), [1.0, 0.15])\n\n    def test_hamster(self):\n        self.assertEqual(berechne_futterbedarf([(\"Hamster\", 0.5)]), [0.01])\n\n    def test_gemischte_haustiere(self):\n        self.assertEqual(berechne_futterbedarf([(\"Hund\", 20), (\"Katze\", 5), (\"Hamster\", 0.5)]), [1.0, 0.15, 0.01])\n\n    def test_leere_liste(self):\n        self.assertEqual(berechne_futterbedarf([]), [])\n\n    def test_unbekanntes_haustier(self):\n        self.assertEqual(berechne_futterbedarf([(\"Papagei\", 1)]), [0.02])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 154,
    "programming_concept": "If-Else-Anweisungen;Funktionen als Variablen;Boolean und None",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Aktivität\n\nSchreibe eine Funktion namens `sport_aktivitaet(aktivitaet)`, die eine sportliche Aktivität als String entgegennimmt und eine entsprechende Nachricht zurückgibt. Die Funktion soll die folgenden Bedingungen prüfen:\n\n- Wenn die Aktivität \"Laufen\" ist, soll die Nachricht \"Laufen ist eine großartige Möglichkeit, fit zu bleiben!\" zurückgegeben werden.\n- Wenn die Aktivität \"Schwimmen\" ist, soll die Nachricht \"Schwimmen trainiert den ganzen Körper!\" zurückgegeben werden.\n- Wenn die Aktivität \"Radfahren\" ist, soll die Nachricht \"Radfahren ist gut für die Ausdauer!\" zurückgegeben werden.\n- Für alle anderen Aktivitäten soll die Nachricht \"Das ist auch eine tolle Sportart!\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `sport_aktivitaet(\"Laufen\")` gibt \"Laufen ist eine großartige Möglichkeit, fit zu bleiben!\" zurück.\n- `sport_aktivitaet(\"Schwimmen\")` gibt \"Schwimmen trainiert den ganzen Körper!\" zurück.\n- `sport_aktivitaet(\"Basketball\")` gibt \"Das ist auch eine tolle Sportart!\" zurück.",
    "code_skeleton": "def sport_aktivitaet(aktivitaet):\n    ## Hier Code einfügen",
    "model_solution": "def sport_aktivitaet(aktivitaet):\n    if aktivitaet == \"Laufen\":\n        return \"Laufen ist eine großartige Möglichkeit, fit zu bleiben!\"\n    elif aktivitaet == \"Schwimmen\":\n        return \"Schwimmen trainiert den ganzen Körper!\"\n    elif aktivitaet == \"Radfahren\":\n        return \"Radfahren ist gut für die Ausdauer!\"\n    else:\n        return \"Das ist auch eine tolle Sportart!\"\n\n# Beispielaufrufe\nprint(sport_aktivitaet(\"Laufen\"))\nprint(sport_aktivitaet(\"Schwimmen\"))\nprint(sport_aktivitaet(\"Basketball\"))",
    "unit_tests": "import unittest\nfrom main import sport_aktivitaet\n\nclass TestSportAktivitaet(unittest.TestCase):\n    def test_laufen(self):\n        self.assertEqual(sport_aktivitaet(\"Laufen\"), \"Laufen ist eine großartige Möglichkeit, fit zu bleiben!\")\n\n    def test_schwimmen(self):\n        self.assertEqual(sport_aktivitaet(\"Schwimmen\"), \"Schwimmen trainiert den ganzen Körper!\")\n\n    def test_radfahren(self):\n        self.assertEqual(sport_aktivitaet(\"Radfahren\"), \"Radfahren ist gut für die Ausdauer!\")\n\n    def test_andere_aktivitaet(self):\n        self.assertEqual(sport_aktivitaet(\"Basketball\"), \"Das ist auch eine tolle Sportart!\")\n        self.assertEqual(sport_aktivitaet(\"Yoga\"), \"Das ist auch eine tolle Sportart!\")\n        self.assertEqual(sport_aktivitaet(\"Tennis\"), \"Das ist auch eine tolle Sportart!\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 155,
    "programming_concept": "Boolean und None;Operationen mit Zahlen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus überprüfen\n\nSchreibe eine Funktion namens `beziehungsstatus(alter, beziehungsdauer)`, die den Beziehungsstatus einer Person basierend auf ihrem Alter und der Dauer ihrer aktuellen Beziehung überprüft. Die Funktion soll eine entsprechende Nachricht mit `return` zurückgeben.\n\n- Wenn die Person jünger als 18 Jahre ist, soll die Funktion \"Zu jung für eine ernsthafte Beziehung.\" zurückgeben.\n- Wenn die Person 18 Jahre oder älter ist und die Beziehungsdauer weniger als 1 Jahr beträgt, soll die Funktion \"Frisch verliebt!\" zurückgeben.\n- Wenn die Person 18 Jahre oder älter ist und die Beziehungsdauer zwischen 1 und 5 Jahren liegt, soll die Funktion \"In einer stabilen Beziehung.\" zurückgeben.\n- Wenn die Person 18 Jahre oder älter ist und die Beziehungsdauer mehr als 5 Jahre beträgt, soll die Funktion \"Langzeitbeziehung.\" zurückgeben.\n\nBeispielaufrufe:\n- `beziehungsstatus(16, 0.5)` gibt \"Zu jung für eine ernsthafte Beziehung.\" zurück.\n- `beziehungsstatus(25, 0.8)` gibt \"Frisch verliebt!\" zurück.\n- `beziehungsstatus(30, 3)` gibt \"In einer stabilen Beziehung.\" zurück.\n- `beziehungsstatus(40, 6)` gibt \"Langzeitbeziehung.\" zurück.",
    "code_skeleton": "def beziehungsstatus(alter, beziehungsdauer):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(alter, beziehungsdauer):\n    if alter < 18:\n        return \"Zu jung für eine ernsthafte Beziehung.\"\n    elif beziehungsdauer < 1:\n        return \"Frisch verliebt!\"\n    elif beziehungsdauer <= 5:\n        return \"In einer stabilen Beziehung.\"\n    else:\n        return \"Langzeitbeziehung.\"\n\n# Beispielaufrufe\nprint(beziehungsstatus(16, 0.5))\nprint(beziehungsstatus(25, 0.8))\nprint(beziehungsstatus(30, 3))\nprint(beziehungsstatus(40, 6))",
    "unit_tests": "import unittest\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_zu_jung(self):\n        self.assertEqual(beziehungsstatus(16, 0.5), \"Zu jung für eine ernsthafte Beziehung.\")\n\n    def test_frisch_verliebt(self):\n        self.assertEqual(beziehungsstatus(25, 0.8), \"Frisch verliebt!\")\n\n    def test_stabile_beziehung(self):\n        self.assertEqual(beziehungsstatus(30, 3), \"In einer stabilen Beziehung.\")\n\n    def test_langzeitbeziehung(self):\n        self.assertEqual(beziehungsstatus(40, 6), \"Langzeitbeziehung.\")\n\n    def test_grenze_18_jahre(self):\n        self.assertEqual(beziehungsstatus(18, 0.5), \"Frisch verliebt!\")\n\n    def test_grenze_1_jahr(self):\n        self.assertEqual(beziehungsstatus(25, 1), \"In einer stabilen Beziehung.\")\n\n    def test_grenze_5_jahre(self):\n        self.assertEqual(beziehungsstatus(30, 5), \"In einer stabilen Beziehung.\")\n\n    def test_grenze_5_jahre_ueberschritten(self):\n        self.assertEqual(beziehungsstatus(30, 5.1), \"Langzeitbeziehung.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 156,
    "programming_concept": "If-Else-Anweisungen;Funktionen höherer Ordnung;String",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spieler Bewertung\n\nSchreibe eine Funktion namens `bewerte_spieler(name, punkte)`, die den Namen eines Rugby-Spielers und seine erzielten Punkte als Argumente entgegennimmt. Die Funktion soll den Spieler basierend auf seinen Punkten bewerten und eine entsprechende Nachricht zurückgeben.\n\n- Wenn der Spieler mehr als 20 Punkte erzielt hat, soll die Nachricht lauten: \"Hervorragend, [Name]! Du bist ein Star-Spieler!\"\n- Wenn der Spieler zwischen 10 und 20 Punkte erzielt hat (einschließlich 10 und 20), soll die Nachricht lauten: \"Gut gemacht, [Name]! Du hast solide gespielt.\"\n- Wenn der Spieler weniger als 10 Punkte erzielt hat, soll die Nachricht lauten: \"Kopf hoch, [Name]! Übung macht den Meister.\"\n\nBeispielaufruf:\n```python\nbewerte_spieler(\"Max\", 25)\n```\nsoll die Nachricht \"Hervorragend, Max! Du bist ein Star-Spieler!\" zurückgeben.",
    "code_skeleton": "def bewerte_spieler(name, punkte):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(name, punkte):\n    if punkte > 20:\n        print(f\"Hervorragend, {name}! Du bist ein Star-Spieler!\")\n    elif 10 <= punkte <= 20:\n        print(f\"Gut gemacht, {name}! Du hast solide gespielt.\")\n    else:\n        print(f\"Kopf hoch, {name}! Übung macht den Meister.\")\n\n# Beispielaufruf\nbewerte_spieler(\"Max\", 25)",
    "unit_tests": "import unittest\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragend(self):\n        self.assertEqual(bewerte_spieler(\"Max\", 25), \"Hervorragend, Max! Du bist ein Star-Spieler!\")\n\n    def test_gut_gemacht(self):\n        self.assertEqual(bewerte_spieler(\"Anna\", 15), \"Gut gemacht, Anna! Du hast solide gespielt.\")\n\n    def test_kopf_hoch(self):\n        self.assertEqual(bewerte_spieler(\"Tom\", 5), \"Kopf hoch, Tom! Übung macht den Meister.\")\n\n    def test_grenze_20(self):\n        self.assertEqual(bewerte_spieler(\"Lena\", 20), \"Gut gemacht, Lena! Du hast solide gespielt.\")\n\n    def test_grenze_10(self):\n        self.assertEqual(bewerte_spieler(\"Paul\", 10), \"Gut gemacht, Paul! Du hast solide gespielt.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 157,
    "programming_concept": "Funktionen als Variablen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Listen",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Virtuelle Realität - Benutzerverwaltung\n\nIn einem virtuellen Realitätssystem sollen Benutzer verwaltet werden. Jeder Benutzer hat einen Namen und ein Alter. Schreibe eine Funktion `benutzer_verwalten(benutzer_liste)`, die eine Liste von Benutzernamen und deren Alter als Eingabe erhält und folgende Aufgaben erfüllt:\n\n1. **Erstelle eine Liste der Benutzer, die älter als 18 Jahre sind.**\n2. **Erstelle eine Liste der Benutzer, die jünger oder gleich 18 Jahre alt sind.**\n3. **Gib die Anzahl der Benutzer in jeder Liste zurück.**\n\nDie Funktion soll ein Dictionary zurückgeben, das die Anzahl der Benutzer in den beiden Listen enthält. Das Dictionary soll die folgenden Schlüssel haben: `\"erwachsene\"` und `\"minderjaehrige\"`.\n\nBeispielaufruf:\n```python\nbenutzer_liste = [(\"Alice\", 22), (\"Bob\", 17), (\"Charlie\", 19), (\"Diana\", 15)]\nergebnis = benutzer_verwalten(benutzer_liste)\nprint(ergebnis)  # Ausgabe: {\"erwachsene\": 2, \"minderjaehrige\": 2}\n```\n\nImplementiere die Funktion `benutzer_verwalten(benutzer_liste)`, um die oben genannten Anforderungen zu erfüllen.",
    "code_skeleton": "def benutzer_verwalten(benutzer_liste):\n    ## Hier Code einfügen",
    "model_solution": "def benutzer_verwalten(benutzer_liste):\n    erwachsene = [b for b in benutzer_liste if b[1] > 18]\n    minderjaehrige = [b for b in benutzer_liste if b[1] <= 18]\n    return {\"erwachsene\": len(erwachsene), \"minderjaehrige\": len(minderjaehrige)}\n\nbenutzer_liste = [(\"Alice\", 22), (\"Bob\", 17), (\"Charlie\", 19), (\"Diana\", 15)]\nergebnis = benutzer_verwalten(benutzer_liste)\nprint(ergebnis)",
    "unit_tests": "import unittest\nfrom main import benutzer_verwalten\n\nclass TestBenutzerVerwalten(unittest.TestCase):\n    def test_gemischte_benutzer(self):\n        benutzer_liste = [(\"Alice\", 22), (\"Bob\", 17), (\"Charlie\", 19), (\"Diana\", 15)]\n        self.assertEqual(benutzer_verwalten(benutzer_liste), {\"erwachsene\": 2, \"minderjaehrige\": 2})\n\n    def test_nur_erwachsene(self):\n        benutzer_liste = [(\"Alice\", 22), (\"Charlie\", 19)]\n        self.assertEqual(benutzer_verwalten(benutzer_liste), {\"erwachsene\": 2, \"minderjaehrige\": 0})\n\n    def test_nur_minderjaehrige(self):\n        benutzer_liste = [(\"Bob\", 17), (\"Diana\", 15)]\n        self.assertEqual(benutzer_verwalten(benutzer_liste), {\"erwachsene\": 0, \"minderjaehrige\": 2})\n\n    def test_leere_liste(self):\n        benutzer_liste = []\n        self.assertEqual(benutzer_verwalten(benutzer_liste), {\"erwachsene\": 0, \"minderjaehrige\": 0})\n\n    def test_grenzwert_18(self):\n        benutzer_liste = [(\"Alice\", 18), (\"Bob\", 18)]\n        self.assertEqual(benutzer_verwalten(benutzer_liste), {\"erwachsene\": 0, \"minderjaehrige\": 2})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 158,
    "programming_concept": "Operationen mit Zahlen;String;Boolean und None",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillenspiegel\n\nSchreibe eine Funktion namens `medaillen_spiegel(gold, silber, bronze)`, die die Anzahl der gewonnenen Medaillen eines Landes bei den Olympischen Spielen entgegennimmt und eine entsprechende Nachricht zurückgibt.\n\n- Wenn das Land keine Medaillen gewonnen hat (alle Werte sind 0), soll die Funktion \"Keine Medaillen gewonnen.\" zurückgeben.\n- Wenn das Land mindestens eine Goldmedaille gewonnen hat, soll die Funktion \"Goldmedaillen: [Anzahl]\" zurückgeben.\n- Wenn das Land mindestens eine Silbermedaille gewonnen hat, soll die Funktion \"Silbermedaillen: [Anzahl]\" zurückgeben.\n- Wenn das Land mindestens eine Bronzemedaille gewonnen hat, soll die Funktion \"Bronzemedaillen: [Anzahl]\" zurückgeben.\n\nBeispielaufrufe:\n- `medaillen_spiegel(0, 0, 0)` gibt \"Keine Medaillen gewonnen.\" zurück.\n- `medaillen_spiegel(1, 0, 0)` gibt \"Goldmedaillen: 1\" zurück.\n- `medaillen_spiegel(0, 2, 0)` gibt \"Silbermedaillen: 2\" zurück.\n- `medaillen_spiegel(0, 0, 3)` gibt \"Bronzemedaillen: 3\" zurück.\n- `medaillen_spiegel(1, 2, 3)` gibt \"Goldmedaillen: 1\\nSilbermedaillen: 2\\nBronzemedaillen: 3\" zurück.",
    "code_skeleton": "def medaillen_spiegel(gold, silber, bronze):\n    ## Hier Code einfügen",
    "model_solution": "def medaillen_spiegel(gold, silber, bronze):\n    if gold == silber == bronze == 0:\n        return \"Keine Medaillen gewonnen.\"\n    result = []\n    if gold > 0:\n        result.append(f\"Goldmedaillen: {gold}\")\n    if silber > 0:\n        result.append(f\"Silbermedaillen: {silber}\")\n    if bronze > 0:\n        result.append(f\"Bronzemedaillen: {bronze}\")\n    return \"\\n\".join(result)\n\n# Beispielaufrufe\nprint(medaillen_spiegel(0, 0, 0))\nprint(medaillen_spiegel(1, 0, 0))\nprint(medaillen_spiegel(0, 2, 0))\nprint(medaillen_spiegel(0, 0, 3))\nprint(medaillen_spiegel(1, 2, 3))",
    "unit_tests": "import unittest\nfrom main import medaillen_spiegel\n\nclass TestMedaillenSpiegel(unittest.TestCase):\n    def test_keine_medaillen(self):\n        self.assertEqual(medaillen_spiegel(0, 0, 0), \"Keine Medaillen gewonnen.\")\n\n    def test_nur_gold(self):\n        self.assertEqual(medaillen_spiegel(1, 0, 0), \"Goldmedaillen: 1\")\n\n    def test_nur_silber(self):\n        self.assertEqual(medaillen_spiegel(0, 2, 0), \"Silbermedaillen: 2\")\n\n    def test_nur_bronze(self):\n        self.assertEqual(medaillen_spiegel(0, 0, 3), \"Bronzemedaillen: 3\")\n\n    def test_gold_silber_bronze(self):\n        self.assertEqual(medaillen_spiegel(1, 2, 3), \"Goldmedaillen: 1\\nSilbermedaillen: 2\\nBronzemedaillen: 3\")\n\n    def test_gold_und_silber(self):\n        self.assertEqual(medaillen_spiegel(1, 2, 0), \"Goldmedaillen: 1\\nSilbermedaillen: 2\")\n\n    def test_gold_und_bronze(self):\n        self.assertEqual(medaillen_spiegel(1, 0, 3), \"Goldmedaillen: 1\\nBronzemedaillen: 3\")\n\n    def test_silber_und_bronze(self):\n        self.assertEqual(medaillen_spiegel(0, 2, 3), \"Silbermedaillen: 2\\nBronzemedaillen: 3\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 159,
    "programming_concept": "If-Else-Anweisungen;Float;While-Schleifen",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Beitragsbewertung\n\nSchreibe eine Funktion namens `bewerte_beitrag(likes, dislikes)`, die die Bewertung eines Beitrags auf einer sozialen Medienplattform berechnet. Die Bewertung soll als ein Float-Wert zwischen -1.0 und 1.0 zurückgegeben werden, wobei:\n\n- Eine Bewertung von 1.0 bedeutet, dass der Beitrag nur Likes und keine Dislikes hat.\n- Eine Bewertung von -1.0 bedeutet, dass der Beitrag nur Dislikes und keine Likes hat.\n- Eine Bewertung von 0.0 bedeutet, dass der Beitrag gleich viele Likes und Dislikes hat.\n\nDie Funktion soll die folgenden Schritte ausführen:\n\n1. Berechne die Gesamtanzahl der Bewertungen (Likes + Dislikes).\n2. Berechne den Bewertungswert als `(Likes - Dislikes) / Gesamtanzahl der Bewertungen`.\n3. Gib den Bewertungswert zurück.\n\nFalls die Gesamtanzahl der Bewertungen 0 ist, soll die Funktion eine Bewertung von 0.0 zurückgeben.\n\nBeispielaufrufe:\n- `bewerte_beitrag(100, 50)` gibt `0.3333333333333333` zurück.\n- `bewerte_beitrag(0, 0)` gibt `0.0` zurück.\n- `bewerte_beitrag(20, 80)` gibt `-0.6` zurück.",
    "code_skeleton": "def bewerte_beitrag(likes, dislikes):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_beitrag(likes, dislikes):\n    gesamt = likes + dislikes\n    return (likes - dislikes) / gesamt if gesamt != 0 else 0.0\n\n# Beispielaufrufe\nprint(bewerte_beitrag(100, 50))\nprint(bewerte_beitrag(0, 0))\nprint(bewerte_beitrag(20, 80))",
    "unit_tests": "import unittest\n\nfrom main import bewerte_beitrag\n\nclass TestBewerteBeitrag(unittest.TestCase):\n    def test_nur_likes(self):\n        self.assertEqual(bewerte_beitrag(100, 0), 1.0)\n\n    def test_nur_dislikes(self):\n        self.assertEqual(bewerte_beitrag(0, 100), -1.0)\n\n    def test_gleiche_anzahl(self):\n        self.assertEqual(bewerte_beitrag(50, 50), 0.0)\n\n    def test_mehr_likes(self):\n        self.assertAlmostEqual(bewerte_beitrag(75, 25), 0.5)\n\n    def test_mehr_dislikes(self):\n        self.assertAlmostEqual(bewerte_beitrag(25, 75), -0.5)\n\n    def test_keine_bewertungen(self):\n        self.assertEqual(bewerte_beitrag(0, 0), 0.0)\n\n    def test_gemischte_bewertungen(self):\n        self.assertAlmostEqual(bewerte_beitrag(100, 50), 0.3333333333333333)\n        self.assertAlmostEqual(bewerte_beitrag(20, 80), -0.6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 160,
    "programming_concept": "While-Schleifen;Rekursion;Operationen mit Zahlen",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Olympia-Medaillenzähler\n\nSchreibe eine Funktion namens `medaillen_zaehler(anzahl_gold, anzahl_silber, anzahl_bronze)`, die die Gesamtzahl der Medaillen berechnet, die ein Land bei den Olympischen Spielen gewonnen hat. Die Funktion soll die Anzahl der Gold-, Silber- und Bronzemedaillen als Argumente entgegennehmen und die Gesamtzahl der Medaillen zurückgeben.\n\nZusätzlich soll die Funktion eine weitere Funktion `medaillen_zaehler_rekursiv(anzahl_gold, anzahl_silber, anzahl_bronze)` aufrufen, die die gleiche Berechnung rekursiv durchführt.\n\nBeispielaufruf:\n```python\nmedaillen_zaehler(10, 5, 8)\n```\nDieser Aufruf sollte die Gesamtzahl der Medaillen zurückgeben, die das Land gewonnen hat.",
    "code_skeleton": "def medaillen_zaehler(anzahl_gold, anzahl_silber, anzahl_bronze):\n    ## Hier Code einfügen\n\ndef medaillen_zaehler_rekursiv(anzahl_gold, anzahl_silber, anzahl_bronze):\n    ## Hier Code einfügen",
    "model_solution": "def medaillen_zaehler(anzahl_gold, anzahl_silber, anzahl_bronze):\n    return anzahl_gold + anzahl_silber + anzahl_bronze\n\ndef medaillen_zaehler_rekursiv(anzahl_gold, anzahl_silber, anzahl_bronze):\n    if anzahl_gold == 0 and anzahl_silber == 0 and anzahl_bronze == 0:\n        return 0\n    return (1 if anzahl_gold > 0 else 0) + (1 if anzahl_silber > 0 else 0) + (1 if anzahl_bronze > 0 else 0) + medaillen_zaehler_rekursiv(max(0, anzahl_gold-1), max(0, anzahl_silber-1), max(0, anzahl_bronze-1))\n\nprint(medaillen_zaehler(10, 5, 8))\nprint(medaillen_zaehler_rekursiv(10, 5, 8))",
    "unit_tests": "import unittest\nfrom main import medaillen_zaehler, medaillen_zaehler_rekursiv\n\nclass TestMedaillenZaehler(unittest.TestCase):\n    def test_alle_medaillen(self):\n        self.assertEqual(medaillen_zaehler(10, 5, 8), 23)\n        self.assertEqual(medaillen_zaehler_rekursiv(10, 5, 8), 23)\n\n    def test_keine_medaillen(self):\n        self.assertEqual(medaillen_zaehler(0, 0, 0), 0)\n        self.assertEqual(medaillen_zaehler_rekursiv(0, 0, 0), 0)\n\n    def test_nur_gold(self):\n        self.assertEqual(medaillen_zaehler(5, 0, 0), 5)\n        self.assertEqual(medaillen_zaehler_rekursiv(5, 0, 0), 5)\n\n    def test_nur_silber(self):\n        self.assertEqual(medaillen_zaehler(0, 7, 0), 7)\n        self.assertEqual(medaillen_zaehler_rekursiv(0, 7, 0), 7)\n\n    def test_nur_bronze(self):\n        self.assertEqual(medaillen_zaehler(0, 0, 3), 3)\n        self.assertEqual(medaillen_zaehler_rekursiv(0, 0, 3), 3)\n\n    def test_randbedingungen(self):\n        self.assertEqual(medaillen_zaehler(1, 1, 1), 3)\n        self.assertEqual(medaillen_zaehler_rekursiv(1, 1, 1), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 161,
    "programming_concept": "Funktionen als Variablen;Integer;Rekursion",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Psychische Gesundheit - Rekursive Berechnung des Wohlbefindens\n\nSchreibe eine Funktion namens `berechne_wohlbefinden(tage)`, die das Wohlbefinden einer Person über eine bestimmte Anzahl von Tagen berechnet. Das Wohlbefinden wird durch eine einfache rekursive Formel definiert:\n\n- An einem bestimmten Tag `n` ist das Wohlbefinden die Summe des Wohlbefindens der beiden vorherigen Tage `n-1` und `n-2`.\n- Das Wohlbefinden am ersten Tag (`n=1`) beträgt 1.\n- Das Wohlbefinden am zweiten Tag (`n=2`) beträgt 1.\n\nDie Funktion soll die Anzahl der Tage `tage` als Argument nehmen und das Wohlbefinden am letzten Tag zurückgeben.\n\nBeispielaufruf: `berechne_wohlbefinden(5)` gibt `5` zurück.\n\n### Kontext\n\nIn der Psychologie wird oft untersucht, wie sich das Wohlbefinden einer Person über die Zeit entwickelt. Diese Aufgabe simuliert eine einfache Modellierung des Wohlbefindens, bei der das Wohlbefinden an einem bestimmten Tag von den vorherigen Tagen abhängt.",
    "code_skeleton": "def berechne_wohlbefinden(tage):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_wohlbefinden(tage):\n    if tage <= 2:\n        return 1\n    return berechne_wohlbefinden(tage-1) + berechne_wohlbefinden(tage-2)\n\nprint(berechne_wohlbefinden(5))",
    "unit_tests": "import unittest\nfrom main import berechne_wohlbefinden\n\nclass TestBerechneWohlbefinden(unittest.TestCase):\n    def test_wohlbefinden_tag_1(self):\n        self.assertEqual(berechne_wohlbefinden(1), 1)\n\n    def test_wohlbefinden_tag_2(self):\n        self.assertEqual(berechne_wohlbefinden(2), 1)\n\n    def test_wohlbefinden_tag_3(self):\n        self.assertEqual(berechne_wohlbefinden(3), 2)\n\n    def test_wohlbefinden_tag_5(self):\n        self.assertEqual(berechne_wohlbefinden(5), 5)\n\n    def test_wohlbefinden_tag_10(self):\n        self.assertEqual(berechne_wohlbefinden(10), 55)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 162,
    "programming_concept": "Funktionen höherer Ordnung;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Operationen mit Zahlen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Leistungen bewerten\n\nSchreibe eine Funktion namens `bewerte_leistung(punkte)`, die eine Punktzahl als Argument erhält und eine entsprechende Bewertung zurückgibt. Die Bewertung erfolgt nach folgenden Kriterien:\n\n- Wenn die Punktzahl größer oder gleich 90 ist, soll die Funktion \"Hervorragend\" zurückgeben.\n- Wenn die Punktzahl zwischen 75 und 89 liegt (einschließlich), soll die Funktion \"Gut\" zurückgeben.\n- Wenn die Punktzahl zwischen 50 und 74 liegt (einschließlich), soll die Funktion \"Befriedigend\" zurückgeben.\n- Wenn die Punktzahl kleiner als 50 ist, soll die Funktion \"Verbesserungswürdig\" zurückgeben.\n\nBeispielaufrufe:\n\n```python\nprint(bewerte_leistung(95))  # Ausgabe: Hervorragend\nprint(bewerte_leistung(80))  # Ausgabe: Gut\nprint(bewerte_leistung(60))  # Ausgabe: Befriedigend\nprint(bewerte_leistung(45))  # Ausgabe: Verbesserungswürdig\n```",
    "code_skeleton": "def bewerte_leistung(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_leistung(punkte):\n    if punkte >= 90:\n        return \"Hervorragend\"\n    elif punkte >= 75:\n        return \"Gut\"\n    elif punkte >= 50:\n        return \"Befriedigend\"\n    else:\n        return \"Verbesserungswürdig\"\n\nprint(bewerte_leistung(95))  # Ausgabe: Hervorragend\nprint(bewerte_leistung(80))  # Ausgabe: Gut\nprint(bewerte_leistung(60))  # Ausgabe: Befriedigend\nprint(bewerte_leistung(45))  # Ausgabe: Verbesserungswürdig",
    "unit_tests": "import unittest\nfrom main import bewerte_leistung\n\nclass TestBewerteLeistung(unittest.TestCase):\n    def test_hervorragend(self):\n        self.assertEqual(bewerte_leistung(95), \"Hervorragend\")\n        self.assertEqual(bewerte_leistung(90), \"Hervorragend\")\n\n    def test_gut(self):\n        self.assertEqual(bewerte_leistung(80), \"Gut\")\n        self.assertEqual(bewerte_leistung(75), \"Gut\")\n\n    def test_befriedigend(self):\n        self.assertEqual(bewerte_leistung(60), \"Befriedigend\")\n        self.assertEqual(bewerte_leistung(50), \"Befriedigend\")\n\n    def test_verbesserungswuerdig(self):\n        self.assertEqual(bewerte_leistung(45), \"Verbesserungswürdig\")\n        self.assertEqual(bewerte_leistung(0), \"Verbesserungswürdig\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 163,
    "programming_concept": "Integer;String;Boolean und None",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustier-Informationen\n\nSchreibe eine Funktion namens `haustier_info(name, alter, art)`, die Informationen über ein Haustier entgegennimmt und eine entsprechende Nachricht zurückgibt. \n\n- `name` ist ein String, der den Namen des Haustiers enthält.\n- `alter` ist ein Integer, der das Alter des Haustiers in Jahren angibt.\n- `art` ist ein String, der die Art des Haustiers beschreibt (z.B. \"Hund\", \"Katze\").\n\nDie Funktion soll die folgenden Bedingungen erfüllen:\n1. Wenn der Name des Haustiers nicht angegeben ist (None), soll die Funktion \"Kein Name angegeben\" zurückgeben.\n2. Wenn das Alter des Haustiers kleiner als 0 ist, soll die Funktion \"Ungültiges Alter\" zurückgeben.\n3. Wenn die Art des Haustiers \"Hund\" ist, soll die Funktion \"Das Haustier ist ein Hund namens [Name] und ist [Alter] Jahre alt.\" zurückgeben.\n4. Wenn die Art des Haustiers \"Katze\" ist, soll die Funktion \"Das Haustier ist eine Katze namens [Name] und ist [Alter] Jahre alt.\" zurückgeben.\n5. Für alle anderen Arten von Haustieren soll die Funktion \"Das Haustier ist ein [Art] namens [Name] und ist [Alter] Jahre alt.\" zurückgeben.\n\nBeispielaufrufe:\n- `haustier_info(\"Bello\", 5, \"Hund\")` gibt \"Das Haustier ist ein Hund namens Bello und ist 5 Jahre alt.\" zurück.\n- `haustier_info(None, 3, \"Katze\")` gibt \"Kein Name angegeben\" zurück.\n- `haustier_info(\"Mimi\", -1, \"Katze\")` gibt \"Ungültiges Alter\" zurück.",
    "code_skeleton": "def haustier_info(name, alter, art):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_info(name, alter, art):\n    if name is None:\n        return \"Kein Name angegeben\"\n    if alter < 0:\n        return \"Ungültiges Alter\"\n    if art == \"Hund\":\n        return f\"Das Haustier ist ein Hund namens {name} und ist {alter} Jahre alt.\"\n    if art == \"Katze\":\n        return f\"Das Haustier ist eine Katze namens {name} und ist {alter} Jahre alt.\"\n    return f\"Das Haustier ist ein {art} namens {name} und ist {alter} Jahre alt.\"\n\n# Beispielaufrufe\nprint(haustier_info(\"Bello\", 5, \"Hund\"))\nprint(haustier_info(None, 3, \"Katze\"))\nprint(haustier_info(\"Mimi\", -1, \"Katze\"))",
    "unit_tests": "import unittest\nfrom main import haustier_info\n\nclass TestHaustierInfo(unittest.TestCase):\n    def test_hund(self):\n        self.assertEqual(haustier_info(\"Bello\", 5, \"Hund\"), \"Das Haustier ist ein Hund namens Bello und ist 5 Jahre alt.\")\n\n    def test_katze(self):\n        self.assertEqual(haustier_info(\"Mimi\", 3, \"Katze\"), \"Das Haustier ist eine Katze namens Mimi und ist 3 Jahre alt.\")\n\n    def test_keine_name(self):\n        self.assertEqual(haustier_info(None, 3, \"Katze\"), \"Kein Name angegeben\")\n\n    def test_ungueltiges_alter(self):\n        self.assertEqual(haustier_info(\"Mimi\", -1, \"Katze\"), \"Ungültiges Alter\")\n\n    def test_andere_art(self):\n        self.assertEqual(haustier_info(\"Tweety\", 2, \"Vogel\"), \"Das Haustier ist ein Vogel namens Tweety und ist 2 Jahre alt.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 164,
    "programming_concept": "Tupel;Float;Funktionen höherer Ordnung",
    "context": "Gartenarbeit",
    "task_description": "### Übungsaufgabe: Gartenarbeit mit Python\n\nSchreibe eine Funktion namens `berechne_flaechen(tupel_liste, funktion)`, die eine Liste von Tupeln und eine Funktion als Argumente entgegennimmt. Jedes Tupel in der Liste repräsentiert die Länge und Breite eines rechteckigen Gartenbeets in Metern. Die Funktion, die als zweites Argument übergeben wird, soll auf jedes Tupel angewendet werden, um die Fläche des jeweiligen Gartenbeets zu berechnen. Die Funktion `berechne_flaechen` soll eine Liste der berechneten Flächen zurückgeben.\n\nBeispielaufruf:\n```python\ndef flaeche(tupel):\n    return tupel[0] * tupel[1]\n\ngartenbeete = [(2.5, 3.0), (4.0, 1.5), (3.5, 2.0)]\nprint(berechne_flaechen(gartenbeete, flaeche))\n```\n\nErwartete Ausgabe:\n```\n[7.5, 6.0, 7.0]\n```\n\nImplementiere die Funktion `berechne_flaechen(tupel_liste, funktion)`.",
    "code_skeleton": "def berechne_flaechen(tupel_liste, funktion):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_flaechen(tupel_liste, funktion):\n    return [funktion(t) for t in tupel_liste]\n\ndef flaeche(tupel):\n    return tupel[0] * tupel[1]\n\ngartenbeete = [(2.5, 3.0), (4.0, 1.5), (3.5, 2.0)]\nprint(berechne_flaechen(gartenbeete, flaeche))",
    "unit_tests": "import unittest\nfrom main import berechne_flaechen\n\ndef flaeche(tupel):\n    return tupel[0] * tupel[1]\n\nclass TestBerechneFlaechen(unittest.TestCase):\n    def test_einfache_flaechen(self):\n        gartenbeete = [(2.5, 3.0), (4.0, 1.5), (3.5, 2.0)]\n        self.assertEqual(berechne_flaechen(gartenbeete, flaeche), [7.5, 6.0, 7.0])\n\n    def test_leere_liste(self):\n        gartenbeete = []\n        self.assertEqual(berechne_flaechen(gartenbeete, flaeche), [])\n\n    def test_ein_element(self):\n        gartenbeete = [(5.0, 5.0)]\n        self.assertEqual(berechne_flaechen(gartenbeete, flaeche), [25.0])\n\n    def test_null_flaeche(self):\n        gartenbeete = [(0, 5.0), (5.0, 0)]\n        self.assertEqual(berechne_flaechen(gartenbeete, flaeche), [0.0, 0.0])\n\n    def test_negative_werte(self):\n        gartenbeete = [(-2.0, 3.0), (4.0, -1.5)]\n        self.assertEqual(berechne_flaechen(gartenbeete, flaeche), [-6.0, -6.0])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 165,
    "programming_concept": "Boolean und None;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Float",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungsstatus überprüfen\n\nSchreibe eine Funktion namens `beziehungsstatus(alter, beziehungsdauer, gemeinsame_interessen)`, die den Beziehungsstatus basierend auf dem Alter der Person, der Dauer der Beziehung (in Jahren) und der Anzahl der gemeinsamen Interessen überprüft. Die Funktion soll folgende Regeln anwenden:\n\n1. Wenn das Alter der Person unter 18 ist, soll die Funktion `None` zurückgeben.\n2. Wenn die Beziehungsdauer weniger als 1 Jahr beträgt und die Anzahl der gemeinsamen Interessen weniger als 3 ist, soll die Funktion `False` zurückgeben.\n3. Wenn die Beziehungsdauer 1 Jahr oder mehr beträgt und die Anzahl der gemeinsamen Interessen 3 oder mehr ist, soll die Funktion `True` zurückgeben.\n4. In allen anderen Fällen soll die Funktion `False` zurückgeben.\n\nBeispielaufrufe:\n- `beziehungsstatus(17, 2, 5)` gibt `None` zurück.\n- `beziehungsstatus(25, 0.5, 2)` gibt `False` zurück.\n- `beziehungsstatus(30, 2, 4)` gibt `True` zurück.\n- `beziehungsstatus(22, 1, 2)` gibt `False` zurück.",
    "code_skeleton": "def beziehungsstatus(alter, beziehungsdauer, gemeinsame_interessen):\n    ## Hier Code einfügen",
    "model_solution": "def beziehungsstatus(alter, beziehungsdauer, gemeinsame_interessen):\n    if alter < 18:\n        return None\n    if beziehungsdauer >= 1 and gemeinsame_interessen >= 3:\n        return True\n    return False\n\nprint(beziehungsstatus(17, 2, 5))  # None\nprint(beziehungsstatus(25, 0.5, 2))  # False\nprint(beziehungsstatus(30, 2, 4))  # True\nprint(beziehungsstatus(22, 1, 2))  # False",
    "unit_tests": "import unittest\n\nfrom main import beziehungsstatus\n\nclass TestBeziehungsstatus(unittest.TestCase):\n    def test_unter_18(self):\n        self.assertIsNone(beziehungsstatus(17, 2, 5))\n\n    def test_kurze_beziehung_wenige_interessen(self):\n        self.assertFalse(beziehungsstatus(25, 0.5, 2))\n\n    def test_lange_beziehung_viele_interessen(self):\n        self.assertTrue(beziehungsstatus(30, 2, 4))\n\n    def test_lange_beziehung_wenige_interessen(self):\n        self.assertFalse(beziehungsstatus(22, 1, 2))\n\n    def test_kurze_beziehung_viele_interessen(self):\n        self.assertFalse(beziehungsstatus(25, 0.5, 3))\n\n    def test_grenzfall_18_jahre(self):\n        self.assertFalse(beziehungsstatus(18, 0.5, 2))\n\n    def test_grenzfall_1_jahr(self):\n        self.assertTrue(beziehungsstatus(25, 1, 3))\n\n    def test_grenzfall_3_interessen(self):\n        self.assertTrue(beziehungsstatus(25, 1, 3))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 166,
    "programming_concept": "Integer;For-Schleifen;Funktionen höherer Ordnung",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Beliebteste Filme auf Streaming-Diensten\n\nSchreibe eine Funktion namens `beliebteste_filme(filme, bewertungen)`, die eine Liste von Filmen und eine Liste von Bewertungen als Argumente erhält. Jeder Film in der Liste `filme` hat eine entsprechende Bewertung in der Liste `bewertungen` an der gleichen Position. Die Funktion soll die Filme zurückgeben, die eine Bewertung von 8 oder höher haben.\n\nVerwende eine For-Schleife, um durch die Listen zu iterieren, und eine Funktion höherer Ordnung, um die gefilterten Filme zurückzugeben.\n\nBeispielaufruf:\n```python\nfilme = [\"Film A\", \"Film B\", \"Film C\", \"Film D\"]\nbewertungen = [7, 9, 8, 6]\nprint(beliebteste_filme(filme, bewertungen))\n```\n\nErwartete Ausgabe:\n```\n['Film B', 'Film C']\n```",
    "code_skeleton": "def beliebteste_filme(filme, bewertungen):\n    ## Hier Code einfügen",
    "model_solution": "def beliebteste_filme(filme, bewertungen):\n    return [film for film, bewertung in zip(filme, bewertungen) if bewertung >= 8]\n\nfilme = [\"Film A\", \"Film B\", \"Film C\", \"Film D\"]\nbewertungen = [7, 9, 8, 6]\nprint(beliebteste_filme(filme, bewertungen))",
    "unit_tests": "import unittest\nfrom main import beliebteste_filme\n\nclass TestBeliebtesteFilme(unittest.TestCase):\n    def test_alle_filme_beliebt(self):\n        filme = [\"Film A\", \"Film B\", \"Film C\"]\n        bewertungen = [8, 9, 10]\n        self.assertEqual(beliebteste_filme(filme, bewertungen), [\"Film A\", \"Film B\", \"Film C\"])\n\n    def test_keine_filme_beliebt(self):\n        filme = [\"Film A\", \"Film B\", \"Film C\"]\n        bewertungen = [7, 6, 5]\n        self.assertEqual(beliebteste_filme(filme, bewertungen), [])\n\n    def test_gemischte_bewertungen(self):\n        filme = [\"Film A\", \"Film B\", \"Film C\", \"Film D\"]\n        bewertungen = [7, 9, 8, 6]\n        self.assertEqual(beliebteste_filme(filme, bewertungen), [\"Film B\", \"Film C\"])\n\n    def test_leere_liste(self):\n        filme = []\n        bewertungen = []\n        self.assertEqual(beliebteste_filme(filme, bewertungen), [])\n\n    def test_grenzwert_bewertung(self):\n        filme = [\"Film A\", \"Film B\", \"Film C\"]\n        bewertungen = [8, 7, 8]\n        self.assertEqual(beliebteste_filme(filme, bewertungen), [\"Film A\", \"Film C\"])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 167,
    "programming_concept": "Funktionen als Variablen;Rekursion;Tupel",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Rezeptverwaltung mit Rekursion und Tupeln\n\nSchreibe eine Funktion `kochrezept(rezept)`, die ein Rezept als Eingabe erhält und die Zutaten und Zubereitungsschritte rekursiv durchläuft. Das Rezept wird als verschachteltes Tupel übergeben, wobei jedes Element entweder eine Zutat (als String) oder ein weiterer Zubereitungsschritt (als Tupel) ist. Die Funktion soll die Zutaten und Schritte in der richtigen Reihenfolge ausgeben.\n\nBeispiel:\n\n```python\nrezept = (\n    \"Zutaten vorbereiten\",\n    (\n        \"Tomaten schneiden\",\n        \"Zwiebeln hacken\",\n        (\n            \"Knoblauch schälen\",\n            \"Knoblauch hacken\"\n        )\n    ),\n    \"Alles in die Pfanne geben\",\n    \"Mit Salz und Pfeffer würzen\"\n)\n\nkochrezept(rezept)\n```\n\nErwartete Ausgabe:\n\n```\nZutaten vorbereiten\nTomaten schneiden\nZwiebeln hacken\nKnoblauch schälen\nKnoblauch hacken\nAlles in die Pfanne geben\nMit Salz und Pfeffer würzen\n```\n\nImplementiere die Funktion `kochrezept(rezept)`, die das Rezept rekursiv durchläuft und die Schritte in der richtigen Reihenfolge ausgibt.",
    "code_skeleton": "def kochrezept(rezept):\n    ## Hier Code einfügen",
    "model_solution": "def kochrezept(rezept):\n    for schritt in rezept:\n        if isinstance(schritt, tuple):\n            kochrezept(schritt)\n        else:\n            print(schritt)\n\nrezept = (\n    \"Zutaten vorbereiten\",\n    (\n        \"Tomaten schneiden\",\n        \"Zwiebeln hacken\",\n        (\n            \"Knoblauch schälen\",\n            \"Knoblauch hacken\"\n        )\n    ),\n    \"Alles in die Pfanne geben\",\n    \"Mit Salz und Pfeffer würzen\"\n)\n\nkochrezept(rezept)",
    "unit_tests": "import unittest\nfrom io import StringIO\nimport sys\nfrom main import kochrezept\n\nclass TestKochrezept(unittest.TestCase):\n    def setUp(self):\n        self.rezept = (\n            \"Zutaten vorbereiten\",\n            (\n                \"Tomaten schneiden\",\n                \"Zwiebeln hacken\",\n                (\n                    \"Knoblauch schälen\",\n                    \"Knoblauch hacken\"\n                )\n            ),\n            \"Alles in die Pfanne geben\",\n            \"Mit Salz und Pfeffer würzen\"\n        )\n\n    def test_kochrezept(self):\n        expected_output = (\n            \"Zutaten vorbereiten\\n\"\n            \"Tomaten schneiden\\n\"\n            \"Zwiebeln hacken\\n\"\n            \"Knoblauch schälen\\n\"\n            \"Knoblauch hacken\\n\"\n            \"Alles in die Pfanne geben\\n\"\n            \"Mit Salz und Pfeffer würzen\\n\"\n        )\n        captured_output = StringIO()\n        sys.stdout = captured_output\n        kochrezept(self.rezept)\n        sys.stdout = sys.__stdout__\n        self.assertEqual(captured_output.getvalue(), expected_output)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 168,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Rekursion;For-Schleifen",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Beliebteste Serie auf einem Streaming-Dienst\n\nSchreibe eine Funktion `beliebteste_serie(serien_liste)`, die eine Liste von Serien und deren Bewertungen als Eingabe erhält und die Serie mit der höchsten Bewertung zurückgibt. Jede Serie in der Liste ist ein Dictionary mit den Schlüsseln `name` und `bewertung`. Die Funktion soll rekursiv die Serie mit der höchsten Bewertung finden.\n\nBeispielaufruf:\n```python\nserien = [\n    {\"name\": \"Serie A\", \"bewertung\": 8.5},\n    {\"name\": \"Serie B\", \"bewertung\": 9.0},\n    {\"name\": \"Serie C\", \"bewertung\": 7.8}\n]\nprint(beliebteste_serie(serien))  # Ausgabe: \"Serie B\"\n```\n\nImplementiere die Funktion so, dass sie die höchste Bewertung rekursiv ermittelt und den Namen der Serie mit der höchsten Bewertung zurückgibt.",
    "code_skeleton": "def beliebteste_serie(serien_liste):\n    ## Hier Code einfügen",
    "model_solution": "def beliebteste_serie(serien_liste):\n    if len(serien_liste) == 1:\n        return serien_liste[0]['name']\n    rest_beste = beliebteste_serie(serien_liste[1:])\n    return serien_liste[0]['name'] if serien_liste[0]['bewertung'] > next(s['bewertung'] for s in serien_liste if s['name'] == rest_beste) else rest_beste\n\nserien = [\n    {\"name\": \"Serie A\", \"bewertung\": 8.5},\n    {\"name\": \"Serie B\", \"bewertung\": 9.0},\n    {\"name\": \"Serie C\", \"bewertung\": 7.8}\n]\nprint(beliebteste_serie(serien))  # Ausgabe: \"Serie B\"",
    "unit_tests": "import unittest\nfrom main import beliebteste_serie\n\nclass TestBeliebtesteSerie(unittest.TestCase):\n    def test_einfacher_fall(self):\n        serien = [\n            {\"name\": \"Serie A\", \"bewertung\": 8.5},\n            {\"name\": \"Serie B\", \"bewertung\": 9.0},\n            {\"name\": \"Serie C\", \"bewertung\": 7.8}\n        ]\n        self.assertEqual(beliebteste_serie(serien), \"Serie B\")\n\n    def test_alle_gleiche_bewertung(self):\n        serien = [\n            {\"name\": \"Serie A\", \"bewertung\": 8.0},\n            {\"name\": \"Serie B\", \"bewertung\": 8.0},\n            {\"name\": \"Serie C\", \"bewertung\": 8.0}\n        ]\n        self.assertEqual(beliebteste_serie(serien), \"Serie A\")\n\n    def test_eine_serie(self):\n        serien = [\n            {\"name\": \"Serie A\", \"bewertung\": 8.5}\n        ]\n        self.assertEqual(beliebteste_serie(serien), \"Serie A\")\n\n    def test_leere_liste(self):\n        serien = []\n        with self.assertRaises(IndexError):\n            beliebteste_serie(serien)\n\n    def test_negative_bewertungen(self):\n        serien = [\n            {\"name\": \"Serie A\", \"bewertung\": -1.0},\n            {\"name\": \"Serie B\", \"bewertung\": -2.0},\n            {\"name\": \"Serie C\", \"bewertung\": -3.0}\n        ]\n        self.assertEqual(beliebteste_serie(serien), \"Serie A\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 169,
    "programming_concept": "Integer;For-Schleifen;Funktionen höherer Ordnung",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musiknoten zählen\n\nSchreibe eine Funktion namens `zaehle_noten(musikstueck)`, die eine Liste von Integern als Argument erhält. Jeder Integer in der Liste repräsentiert eine Note in einem Musikstück. Die Funktion soll die Anzahl der Vorkommen jeder Note zählen und das Ergebnis als Dictionary zurückgeben, wobei die Schlüssel die Noten und die Werte die Anzahl der Vorkommen sind.\n\nBeispielaufruf:\n```python\nmusikstueck = [60, 62, 64, 60, 62, 60, 65, 67, 60]\nprint(zaehle_noten(musikstueck))\n```\n\nErwartete Ausgabe:\n```python\n{60: 4, 62: 2, 64: 1, 65: 1, 67: 1}\n```\n\nImplementiere die Funktion `zaehle_noten(musikstueck)` so, dass sie die Anzahl der Vorkommen jeder Note in der Liste korrekt zählt und als Dictionary zurückgibt.",
    "code_skeleton": "def zaehle_noten(musikstueck):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_noten(musikstueck):\n    return {note: musikstueck.count(note) for note in set(musikstueck)}\n\nmusikstueck = [60, 62, 64, 60, 62, 60, 65, 67, 60]\nprint(zaehle_noten(musikstueck))",
    "unit_tests": "import unittest\n\nfrom main import zaehle_noten\n\nclass TestZaehleNoten(unittest.TestCase):\n    def test_einfaches_stueck(self):\n        self.assertEqual(zaehle_noten([60, 62, 64, 60, 62, 60, 65, 67, 60]), {60: 4, 62: 2, 64: 1, 65: 1, 67: 1})\n\n    def test_leeres_stueck(self):\n        self.assertEqual(zaehle_noten([]), {})\n\n    def test_eine_note(self):\n        self.assertEqual(zaehle_noten([60]), {60: 1})\n\n    def test_alle_noten_einmal(self):\n        self.assertEqual(zaehle_noten([60, 61, 62, 63, 64, 65, 66, 67]), {60: 1, 61: 1, 62: 1, 63: 1, 64: 1, 65: 1, 66: 1, 67: 1})\n\n    def test_alle_noten_mehrfach(self):\n        self.assertEqual(zaehle_noten([60, 60, 61, 61, 62, 62, 63, 63, 64, 64, 65, 65, 66, 66, 67, 67]), {60: 2, 61: 2, 62: 2, 63: 2, 64: 2, 65: 2, 66: 2, 67: 2})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 170,
    "programming_concept": "Listen;While-Schleifen;Funktionen als Variablen",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Streaming-Dienste und Serien\n\nSchreibe eine Funktion `filter_serien(serien_liste, bewertung)`, die eine Liste von Serien und eine Mindestbewertung als Parameter erhält. Die Funktion soll alle Serien aus der Liste zurückgeben, die eine Bewertung gleich oder höher der angegebenen Mindestbewertung haben.\n\nDie Serienliste ist eine Liste von Tupeln, wobei jedes Tupel den Namen der Serie und ihre Bewertung enthält. Die Bewertung ist eine Zahl zwischen 1 und 10.\n\nVerwende eine `while`-Schleife, um durch die Liste zu iterieren und die Serien zu filtern.\n\nBeispiel:\n\n```python\nserien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\nprint(filter_serien(serien, 8.5))\n```\n\nErwartete Ausgabe:\n\n```\n[('Breaking Bad', 9.5), ('Stranger Things', 8.7), ('The Office', 8.9)]\n```",
    "code_skeleton": "def filter_serien(serien_liste, bewertung):\n    ## Hier Code einfügen",
    "model_solution": "def filter_serien(serien_liste, bewertung):\n    result = []\n    i = 0\n    while i < len(serien_liste):\n        if serien_liste[i][1] >= bewertung:\n            result.append(serien_liste[i])\n        i += 1\n    return result\n\nserien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\nprint(filter_serien(serien, 8.5))",
    "unit_tests": "import unittest\nfrom main import filter_serien\n\nclass TestFilterSerien(unittest.TestCase):\n    def test_alle_serien(self):\n        serien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\n        self.assertEqual(filter_serien(serien, 8.0), serien)\n\n    def test_keine_serien(self):\n        serien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\n        self.assertEqual(filter_serien(serien, 10.0), [])\n\n    def test_einige_serien(self):\n        serien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\n        self.assertEqual(filter_serien(serien, 8.5), [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9)])\n\n    def test_leere_liste(self):\n        serien = []\n        self.assertEqual(filter_serien(serien, 8.5), [])\n\n    def test_grenze_bewertung(self):\n        serien = [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9), (\"Friends\", 8.0)]\n        self.assertEqual(filter_serien(serien, 8.7), [(\"Breaking Bad\", 9.5), (\"Stranger Things\", 8.7), (\"The Office\", 8.9)])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 171,
    "programming_concept": "If-Else-Anweisungen;For-Schleifen;Tupel",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Statistiken\n\nSchreibe eine Funktion namens `bewerte_spieler(spieler_statistiken)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel enthält den Namen eines Spielers und die Anzahl der erzielten Punkte in einem Spiel. Die Funktion soll die Spieler bewerten und eine entsprechende Nachricht zurückgeben.\n\n- Wenn ein Spieler mehr als 20 Punkte erzielt hat, soll die Nachricht \"Hervorragend, [Name]!\" lauten.\n- Wenn ein Spieler zwischen 10 und 20 Punkte erzielt hat, soll die Nachricht \"Gut gemacht, [Name]!\" lauten.\n- Wenn ein Spieler weniger als 10 Punkte erzielt hat, soll die Nachricht \"Weiter so, [Name]!\" lauten.\n\nBeispielaufruf:\n```python\nspieler_statistiken = [(\"Anna\", 25), (\"Ben\", 15), (\"Chris\", 8)]\nbewerte_spieler(spieler_statistiken)\n```\n\nErwartete Ausgabe:\n```\nHervorragend, Anna!\nGut gemacht, Ben!\nWeiter so, Chris!\n```",
    "code_skeleton": "def bewerte_spieler(spieler_statistiken):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(spieler_statistiken):\n    for name, punkte in spieler_statistiken:\n        if punkte > 20:\n            print(f\"Hervorragend, {name}!\")\n        elif 10 <= punkte <= 20:\n            print(f\"Gut gemacht, {name}!\")\n        else:\n            print(f\"Weiter so, {name}!\")\n\nspieler_statistiken = [(\"Anna\", 25), (\"Ben\", 15), (\"Chris\", 8)]\nbewerte_spieler(spieler_statistiken)",
    "unit_tests": "import unittest\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragend(self):\n        spieler_statistiken = [(\"Anna\", 25)]\n        expected_output = \"Hervorragend, Anna!\\n\"\n        with self.assertLogs(level='INFO') as log:\n            bewerte_spieler(spieler_statistiken)\n            self.assertEqual(log.output, [expected_output])\n\n    def test_gut_gemacht(self):\n        spieler_statistiken = [(\"Ben\", 15)]\n        expected_output = \"Gut gemacht, Ben!\\n\"\n        with self.assertLogs(level='INFO') as log:\n            bewerte_spieler(spieler_statistiken)\n            self.assertEqual(log.output, [expected_output])\n\n    def test_weiter_so(self):\n        spieler_statistiken = [(\"Chris\", 8)]\n        expected_output = \"Weiter so, Chris!\\n\"\n        with self.assertLogs(level='INFO') as log:\n            bewerte_spieler(spieler_statistiken)\n            self.assertEqual(log.output, [expected_output])\n\n    def test_gemischte_bewertungen(self):\n        spieler_statistiken = [(\"Anna\", 25), (\"Ben\", 15), (\"Chris\", 8)]\n        expected_output = [\n            \"Hervorragend, Anna!\\n\",\n            \"Gut gemacht, Ben!\\n\",\n            \"Weiter so, Chris!\\n\"\n        ]\n        with self.assertLogs(level='INFO') as log:\n            bewerte_spieler(spieler_statistiken)\n            self.assertEqual(log.output, expected_output)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 172,
    "programming_concept": "Float;Funktionen höherer Ordnung;Integer",
    "context": "Tiere",
    "task_description": "### Übungsaufgabe: Tiere und ihre Eigenschaften\n\nSchreibe eine Funktion namens `tier_info(tier, eigenschaft)`, die Informationen über verschiedene Tiere und ihre Eigenschaften zurückgibt. Die Funktion soll zwei Parameter akzeptieren: `tier` (ein String) und `eigenschaft` (ein String). \n\nDie Funktion soll die folgenden Tiere und Eigenschaften unterstützen:\n\n- Hund:\n  - \"gewicht\" (Float): Gibt das durchschnittliche Gewicht eines Hundes in Kilogramm zurück.\n  - \"beine\" (Integer): Gibt die Anzahl der Beine eines Hundes zurück.\n- Katze:\n  - \"gewicht\" (Float): Gibt das durchschnittliche Gewicht einer Katze in Kilogramm zurück.\n  - \"beine\" (Integer): Gibt die Anzahl der Beine einer Katze zurück.\n- Vogel:\n  - \"gewicht\" (Float): Gibt das durchschnittliche Gewicht eines Vogels in Kilogramm zurück.\n  - \"beine\" (Integer): Gibt die Anzahl der Beine eines Vogels zurück.\n\nBeispielaufrufe:\n- `tier_info(\"Hund\", \"gewicht\")` soll das durchschnittliche Gewicht eines Hundes zurückgeben.\n- `tier_info(\"Katze\", \"beine\")` soll die Anzahl der Beine einer Katze zurückgeben.\n\nImplementiere die Funktion so, dass sie die entsprechenden Werte zurückgibt.",
    "code_skeleton": "def tier_info(tier, eigenschaft):\n    ## Hier Code einfügen",
    "model_solution": "def tier_info(tier, eigenschaft):\n    daten = {\n        \"Hund\": {\"gewicht\": 30.0, \"beine\": 4},\n        \"Katze\": {\"gewicht\": 4.5, \"beine\": 4},\n        \"Vogel\": {\"gewicht\": 0.1, \"beine\": 2}\n    }\n    return daten[tier][eigenschaft]\n\nprint(tier_info(\"Hund\", \"gewicht\"))\nprint(tier_info(\"Katze\", \"beine\"))\nprint(tier_info(\"Vogel\", \"gewicht\"))",
    "unit_tests": "import unittest\nfrom main import tier_info\n\nclass TestTierInfo(unittest.TestCase):\n    def test_hund_gewicht(self):\n        self.assertEqual(tier_info(\"Hund\", \"gewicht\"), 30.0)\n\n    def test_hund_beine(self):\n        self.assertEqual(tier_info(\"Hund\", \"beine\"), 4)\n\n    def test_katze_gewicht(self):\n        self.assertEqual(tier_info(\"Katze\", \"gewicht\"), 4.5)\n\n    def test_katze_beine(self):\n        self.assertEqual(tier_info(\"Katze\", \"beine\"), 4)\n\n    def test_vogel_gewicht(self):\n        self.assertEqual(tier_info(\"Vogel\", \"gewicht\"), 0.1)\n\n    def test_vogel_beine(self):\n        self.assertEqual(tier_info(\"Vogel\", \"beine\"), 2)\n\n    def test_unbekanntes_tier(self):\n        with self.assertRaises(KeyError):\n            tier_info(\"Elefant\", \"gewicht\")\n\n    def test_unbekannte_eigenschaft(self):\n        with self.assertRaises(KeyError):\n            tier_info(\"Hund\", \"farbe\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 173,
    "programming_concept": "Operationen mit Zahlen;Tupel;For-Schleifen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Leistungen analysieren\n\nSchreibe eine Funktion namens `analyse_leistungen(leistungen)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel enthält den Namen eines Sportlers und seine erzielte Punktzahl in einem Wettkampf. Die Funktion soll die durchschnittliche Punktzahl aller Sportler berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nleistungen = [(\"Anna\", 15), (\"Ben\", 20), (\"Clara\", 18), (\"David\", 22)]\ndurchschnitt = analyse_leistungen(leistungen)\nprint(durchschnitt)  # Erwartete Ausgabe: 18.75\n```\n\n**Hinweis:** Die Funktion soll keine Eingaben über die Standardeingabe erwarten.",
    "code_skeleton": "def analyse_leistungen(leistungen):\n    ## Hier Code einfügen",
    "model_solution": "def analyse_leistungen(leistungen):\n    return sum(p for _, p in leistungen) / len(leistungen)\n\nleistungen = [(\"Anna\", 15), (\"Ben\", 20), (\"Clara\", 18), (\"David\", 22)]\ndurchschnitt = analyse_leistungen(leistungen)\nprint(durchschnitt)  # Erwartete Ausgabe: 18.75",
    "unit_tests": "import unittest\n\nfrom main import analyse_leistungen\n\nclass TestAnalyseLeistungen(unittest.TestCase):\n    def test_durchschnitt(self):\n        leistungen = [(\"Anna\", 15), (\"Ben\", 20), (\"Clara\", 18), (\"David\", 22)]\n        self.assertEqual(analyse_leistungen(leistungen), 18.75)\n\n    def test_leere_liste(self):\n        leistungen = []\n        with self.assertRaises(ZeroDivisionError):\n            analyse_leistungen(leistungen)\n\n    def test_ein_sportler(self):\n        leistungen = [(\"Anna\", 15)]\n        self.assertEqual(analyse_leistungen(leistungen), 15)\n\n    def test_negative_punkte(self):\n        leistungen = [(\"Anna\", -5), (\"Ben\", 10)]\n        self.assertEqual(analyse_leistungen(leistungen), 2.5)\n\n    def test_gemischte_punkte(self):\n        leistungen = [(\"Anna\", 0), (\"Ben\", 10), (\"Clara\", 20)]\n        self.assertEqual(analyse_leistungen(leistungen), 10)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 174,
    "programming_concept": "Funktionen als Variablen;Float;For-Schleifen",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Berechnung des durchschnittlichen Stresslevels\n\nIn dieser Aufgabe sollst du eine Funktion implementieren, die das durchschnittliche Stresslevel einer Person über eine Woche berechnet. Das Stresslevel wird als Liste von Fließkommazahlen (Float) für jeden Tag der Woche angegeben.\n\nSchreibe eine Funktion namens `durchschnittliches_stresslevel(stresslevel_liste)`, die eine Liste von Fließkommazahlen als Argument nimmt und das durchschnittliche Stresslevel berechnet und zurückgibt. \n\nBeispielaufruf:\n```python\nstresslevel = [3.5, 4.0, 2.8, 5.1, 3.3, 4.2, 3.9]\nprint(durchschnittliches_stresslevel(stresslevel))  # Erwartete Ausgabe: 3.9714285714285715\n```\n\n### Anforderungen:\n1. Die Funktion soll eine Liste von Fließkommazahlen als Eingabe akzeptieren.\n2. Die Funktion soll das durchschnittliche Stresslevel als Fließkommazahl zurückgeben.\n3. Verwende eine `for`-Schleife, um die Summe der Stresslevel zu berechnen.\n4. Berechne den Durchschnitt, indem du die Summe durch die Anzahl der Tage teilst.\n\n### Kontext:\nDas Stresslevel einer Person kann stark variieren und ist ein wichtiger Indikator für die psychische Gesundheit. Durch die Berechnung des durchschnittlichen Stresslevels über eine Woche hinweg kann man besser verstehen, wie gestresst eine Person im Durchschnitt ist und ob Maßnahmen zur Stressbewältigung notwendig sind.",
    "code_skeleton": "def durchschnittliches_stresslevel(stresslevel_liste):\n    ## Hier Code einfügen",
    "model_solution": "def durchschnittliches_stresslevel(stresslevel_liste):\n    return sum(stresslevel_liste) / len(stresslevel_liste)\n\nstresslevel = [3.5, 4.0, 2.8, 5.1, 3.3, 4.2, 3.9]\nprint(durchschnittliches_stresslevel(stresslevel))",
    "unit_tests": "import unittest\nfrom main import durchschnittliches_stresslevel\n\nclass TestDurchschnittlichesStresslevel(unittest.TestCase):\n    def test_durchschnitt(self):\n        self.assertAlmostEqual(durchschnittliches_stresslevel([3.5, 4.0, 2.8, 5.1, 3.3, 4.2, 3.9]), 3.9714285714285715)\n\n    def test_leere_liste(self):\n        with self.assertRaises(ZeroDivisionError):\n            durchschnittliches_stresslevel([])\n\n    def test_ein_element(self):\n        self.assertEqual(durchschnittliches_stresslevel([4.0]), 4.0)\n\n    def test_negative_werte(self):\n        self.assertAlmostEqual(durchschnittliches_stresslevel([-1.0, -2.0, -3.0]), -2.0)\n\n    def test_gemischte_werte(self):\n        self.assertAlmostEqual(durchschnittliches_stresslevel([1.0, -1.0, 1.0, -1.0]), 0.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 175,
    "programming_concept": "Funktionen als Variablen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Listen",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustier-Filter\n\nSchreibe eine Funktion namens `filter_haustiere(haustiere, kriterium)`, die eine Liste von Haustieren und ein Kriterium als Parameter erhält. Die Funktion soll eine neue Liste zurückgeben, die nur die Haustiere enthält, die dem Kriterium entsprechen.\n\nDie Haustiere sind als Wörter in einer Liste gegeben, z.B. `[\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]`.\n\nDas Kriterium ist eine Funktion, die ein Haustier als Argument nimmt und einen Boolean-Wert zurückgibt. Zum Beispiel könnte ein Kriterium eine Funktion sein, die überprüft, ob der Name des Haustiers mit einem bestimmten Buchstaben beginnt.\n\nBeispielaufruf:\n```python\nhaustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\nkriterium = lambda haustier: haustier.startswith(\"H\")\nprint(filter_haustiere(haustiere, kriterium))  # Ausgabe: [\"Hund\", \"Hamster\"]\n```\n\nImplementiere die Funktion `filter_haustiere(haustiere, kriterium)`, sodass sie die oben beschriebene Funktionalität erfüllt.",
    "code_skeleton": "def filter_haustiere(haustiere, kriterium):\n    ## Hier Code einfügen",
    "model_solution": "def filter_haustiere(haustiere, kriterium):\n    return [haustier for haustier in haustiere if kriterium(haustier)]\n\nhaustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\nkriterium = lambda haustier: haustier.startswith(\"H\")\nprint(filter_haustiere(haustiere, kriterium))  # Ausgabe: [\"Hund\", \"Hamster\"]",
    "unit_tests": "import unittest\nfrom main import filter_haustiere\n\nclass TestFilterHaustiere(unittest.TestCase):\n    def test_haustiere_mit_h(self):\n        haustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\n        kriterium = lambda haustier: haustier.startswith(\"H\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [\"Hund\", \"Hamster\"])\n\n    def test_haustiere_mit_k(self):\n        haustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\n        kriterium = lambda haustier: haustier.startswith(\"K\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [\"Katze\"])\n\n    def test_haustiere_mit_v(self):\n        haustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\n        kriterium = lambda haustier: haustier.startswith(\"V\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [\"Vogel\"])\n\n    def test_haustiere_mit_f(self):\n        haustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\n        kriterium = lambda haustier: haustier.startswith(\"F\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [\"Fisch\"])\n\n    def test_leere_liste(self):\n        haustiere = []\n        kriterium = lambda haustier: haustier.startswith(\"H\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [])\n\n    def test_keine_haustiere_erfüllen_kriterium(self):\n        haustiere = [\"Hund\", \"Katze\", \"Hamster\", \"Vogel\", \"Fisch\"]\n        kriterium = lambda haustier: haustier.startswith(\"Z\")\n        self.assertEqual(filter_haustiere(haustiere, kriterium), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 176,
    "programming_concept": "If-Else-Anweisungen;Tupel;Float",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spielergewicht\n\nSchreibe eine Funktion namens `spieler_gewicht(spieler)`, die ein Tupel als Argument erhält. Das Tupel enthält den Namen des Spielers und sein Gewicht in Kilogramm als Float. Die Funktion soll überprüfen, ob das Gewicht des Spielers über oder unter 100 kg liegt und eine entsprechende Nachricht zurückgeben.\n\n- Wenn das Gewicht des Spielers 100 kg oder mehr beträgt, soll die Nachricht lauten: \"`[Name] ist ein schwerer Spieler.`\"\n- Wenn das Gewicht des Spielers unter 100 kg liegt, soll die Nachricht lauten: \"`[Name] ist ein leichter Spieler.`\"\n\nBeispielaufruf:\n```python\nspieler_gewicht((\"Max\", 105.5))  # gibt \"Max ist ein schwerer Spieler.\" zurück\nspieler_gewicht((\"Tom\", 95.0))   # gibt \"Tom ist ein leichter Spieler.\" zurück\n```",
    "code_skeleton": "def spieler_gewicht(spieler):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_gewicht(spieler):\n    name, gewicht = spieler\n    if gewicht >= 100:\n        print(f\"{name} ist ein schwerer Spieler.\")\n    else:\n        print(f\"{name} ist ein leichter Spieler.\")\n\nspieler_gewicht((\"Max\", 105.5))\nspieler_gewicht((\"Tom\", 95.0))",
    "unit_tests": "import unittest\nfrom main import spieler_gewicht\n\nclass TestSpielerGewicht(unittest.TestCase):\n    def test_schwerer_spieler(self):\n        self.assertEqual(spieler_gewicht((\"Max\", 105.5)), \"Max ist ein schwerer Spieler.\")\n\n    def test_leichter_spieler(self):\n        self.assertEqual(spieler_gewicht((\"Tom\", 95.0)), \"Tom ist ein leichter Spieler.\")\n\n    def test_grenze_schwerer_spieler(self):\n        self.assertEqual(spieler_gewicht((\"John\", 100.0)), \"John ist ein schwerer Spieler.\")\n\n    def test_grenze_leichter_spieler(self):\n        self.assertEqual(spieler_gewicht((\"Alex\", 99.9)), \"Alex ist ein leichter Spieler.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 177,
    "programming_concept": "String;Funktionen als Variablen;Listen",
    "context": "Streaming-Dienste",
    "task_description": "### Übungsaufgabe: Streaming-Dienste\n\nSchreibe eine Funktion namens `filtere_genres(filme, genre)`, die eine Liste von Filmen und ein Genre als Parameter erhält. Jeder Film ist ein Dictionary mit den Schlüsseln \"titel\" und \"genre\". Die Funktion soll eine neue Liste zurückgeben, die nur die Filme enthält, die dem angegebenen Genre entsprechen.\n\nBeispielaufruf:\n```python\nfilme = [\n    {\"titel\": \"Film A\", \"genre\": \"Action\"},\n    {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n    {\"titel\": \"Film C\", \"genre\": \"Action\"},\n    {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n]\n\nergebnis = filtere_genres(filme, \"Action\")\n# ergebnis sollte [{\"titel\": \"Film A\", \"genre\": \"Action\"}, {\"titel\": \"Film C\", \"genre\": \"Action\"}] sein\n```\n\nImplementiere die Funktion `filtere_genres(filme, genre)`, sodass sie die oben beschriebene Funktionalität erfüllt.",
    "code_skeleton": "def filtere_genres(filme, genre):\n    ## Hier Code einfügen",
    "model_solution": "def filtere_genres(filme, genre):\n    return [film for film in filme if film['genre'] == genre]\n\nfilme = [\n    {\"titel\": \"Film A\", \"genre\": \"Action\"},\n    {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n    {\"titel\": \"Film C\", \"genre\": \"Action\"},\n    {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n]\n\nergebnis = filtere_genres(filme, \"Action\")\nprint(ergebnis)",
    "unit_tests": "import unittest\nfrom main import filtere_genres\n\nclass TestFiltereGenres(unittest.TestCase):\n    def test_action_genre(self):\n        filme = [\n            {\"titel\": \"Film A\", \"genre\": \"Action\"},\n            {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n            {\"titel\": \"Film C\", \"genre\": \"Action\"},\n            {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n        ]\n        self.assertEqual(filtere_genres(filme, \"Action\"), [\n            {\"titel\": \"Film A\", \"genre\": \"Action\"},\n            {\"titel\": \"Film C\", \"genre\": \"Action\"}\n        ])\n\n    def test_drama_genre(self):\n        filme = [\n            {\"titel\": \"Film A\", \"genre\": \"Action\"},\n            {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n            {\"titel\": \"Film C\", \"genre\": \"Action\"},\n            {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n        ]\n        self.assertEqual(filtere_genres(filme, \"Drama\"), [\n            {\"titel\": \"Film B\", \"genre\": \"Drama\"}\n        ])\n\n    def test_komoedie_genre(self):\n        filme = [\n            {\"titel\": \"Film A\", \"genre\": \"Action\"},\n            {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n            {\"titel\": \"Film C\", \"genre\": \"Action\"},\n            {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n        ]\n        self.assertEqual(filtere_genres(filme, \"Komödie\"), [\n            {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n        ])\n\n    def test_leeres_ergebnis(self):\n        filme = [\n            {\"titel\": \"Film A\", \"genre\": \"Action\"},\n            {\"titel\": \"Film B\", \"genre\": \"Drama\"},\n            {\"titel\": \"Film C\", \"genre\": \"Action\"},\n            {\"titel\": \"Film D\", \"genre\": \"Komödie\"}\n        ]\n        self.assertEqual(filtere_genres(filme, \"Horror\"), [])\n\n    def test_leere_filmliste(self):\n        filme = []\n        self.assertEqual(filtere_genres(filme, \"Action\"), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 178,
    "programming_concept": "Boolean und None;For-Schleifen;Operationen mit Zahlen",
    "context": "Virtuelle Realität",
    "task_description": "### Übungsaufgabe: Virtuelle Realität - Berechnung der Sichtbarkeit\n\nIn der virtuellen Realität ist es wichtig, die Sichtbarkeit von Objekten zu berechnen, um die Leistung zu optimieren. Schreibe eine Funktion `sichtbarkeit_berechnen(objekte)`, die eine Liste von Objekten erhält. Jedes Objekt ist durch eine Zahl repräsentiert, die die Entfernung des Objekts vom Betrachter angibt. \n\nDie Funktion soll die Anzahl der Objekte zurückgeben, die innerhalb einer bestimmten Sichtweite liegen. Die Sichtweite beträgt 100 Einheiten. Wenn die Liste leer ist, soll die Funktion `None` zurückgeben.\n\nBeispielaufruf:\n```python\nobjekte = [50, 150, 30, 200, 90]\nsichtbarkeit_berechnen(objekte)\n```\nErwartete Rückgabe:\n```\n3\n```\n\n### Anforderungen:\n- Implementiere die Funktion `sichtbarkeit_berechnen(objekte)`.\n- Die Funktion soll die Anzahl der Objekte innerhalb der Sichtweite von 100 Einheiten zurückgeben.\n- Wenn die Liste leer ist, soll die Funktion `None` zurückgeben.",
    "code_skeleton": "def sichtbarkeit_berechnen(objekte):\n    ## Hier Code einfügen",
    "model_solution": "def sichtbarkeit_berechnen(objekte):\n    if not objekte:\n        return None\n    return sum(1 for obj in objekte if obj <= 100)\n\nobjekte = [50, 150, 30, 200, 90]\nprint(sichtbarkeit_berechnen(objekte))",
    "unit_tests": "import unittest\nfrom main import sichtbarkeit_berechnen\n\nclass TestSichtbarkeitBerechnen(unittest.TestCase):\n    def test_leere_liste(self):\n        self.assertIsNone(sichtbarkeit_berechnen([]))\n\n    def test_alle_objekte_in_sichtweite(self):\n        self.assertEqual(sichtbarkeit_berechnen([10, 20, 30, 40, 50]), 5)\n\n    def test_keine_objekte_in_sichtweite(self):\n        self.assertEqual(sichtbarkeit_berechnen([110, 120, 130, 140, 150]), 0)\n\n    def test_gemischte_objekte(self):\n        self.assertEqual(sichtbarkeit_berechnen([50, 150, 30, 200, 90]), 3)\n\n    def test_grenzwert_sichtweite(self):\n        self.assertEqual(sichtbarkeit_berechnen([100, 101, 99, 102, 98]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 179,
    "programming_concept": "For-Schleifen;While-Schleifen;If-Else-Anweisungen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fische zählen\n\nSchreibe eine Funktion namens `zaehle_fische(fisch_liste)`, die eine Liste von Fischen als Eingabe erhält. Die Funktion soll die Anzahl der Fische in der Liste zählen und dabei zwischen \"Karpfen\" und \"Hecht\" unterscheiden. \n\n- Wenn der Fisch ein \"Karpfen\" ist, soll er zur Karpfen-Zählung hinzugefügt werden.\n- Wenn der Fisch ein \"Hecht\" ist, soll er zur Hecht-Zählung hinzugefügt werden.\n- Alle anderen Fische sollen ignoriert werden.\n\nDie Funktion soll ein Dictionary zurückgeben, das die Anzahl der Karpfen und Hechte enthält. \n\nBeispielaufruf:\n```python\nfische = [\"Karpfen\", \"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Karpfen\"]\nprint(zaehle_fische(fische))\n```\n\nErwartete Ausgabe:\n```python\n{\"Karpfen\": 3, \"Hecht\": 2}\n```",
    "code_skeleton": "def zaehle_fische(fisch_liste):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fisch_liste):\n    zaehlung = {\"Karpfen\": 0, \"Hecht\": 0}\n    for fisch in fisch_liste:\n        if fisch in zaehlung:\n            zaehlung[fisch] += 1\n    return zaehlung\n\nfische = [\"Karpfen\", \"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Karpfen\"]\nprint(zaehle_fische(fische))",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_gemischte_fische(self):\n        self.assertEqual(zaehle_fische([\"Karpfen\", \"Hecht\", \"Karpfen\", \"Forelle\", \"Hecht\", \"Karpfen\"]), {\"Karpfen\": 3, \"Hecht\": 2})\n\n    def test_nur_karpfen(self):\n        self.assertEqual(zaehle_fische([\"Karpfen\", \"Karpfen\", \"Karpfen\"]), {\"Karpfen\": 3, \"Hecht\": 0})\n\n    def test_nur_hechte(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Hecht\", \"Hecht\"]), {\"Karpfen\": 0, \"Hecht\": 3})\n\n    def test_keine_fische(self):\n        self.assertEqual(zaehle_fische([]), {\"Karpfen\": 0, \"Hecht\": 0})\n\n    def test_ignorierte_fische(self):\n        self.assertEqual(zaehle_fische([\"Forelle\", \"Barsch\", \"Wels\"]), {\"Karpfen\": 0, \"Hecht\": 0})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 180,
    "programming_concept": "Tupel;Operationen mit Zahlen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Musik",
    "task_description": "### Übungsaufgabe: Musik-Playlist-Analyse\n\nSchreibe eine Funktion namens `analyse_playlist(playlist)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel repräsentiert einen Song und enthält zwei Elemente: den Namen des Songs (String) und die Dauer des Songs in Sekunden (Integer).\n\nDie Funktion soll die folgenden Aufgaben erfüllen:\n1. Überprüfen, ob die Playlist mindestens 5 Songs enthält. Wenn nicht, soll die Funktion \"Zu wenige Songs in der Playlist\" zurückgeben.\n2. Den längsten Song in der Playlist finden und seinen Namen zurückgeben.\n3. Den kürzesten Song in der Playlist finden und seinen Namen zurückgeben.\n4. Die durchschnittliche Dauer der Songs in der Playlist berechnen und zurückgeben.\n\nBeispielaufruf:\n```python\nplaylist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\nanalyse_playlist(playlist)\n```\n\nErwartete Rückgabe:\n```python\n(\"Längster Song: Song C\", \"Kürzester Song: Song D\", \"Durchschnittliche Dauer: 196.0 Sekunden\")\n```",
    "code_skeleton": "def analyse_playlist(playlist):\n    ## Hier Code einfügen",
    "model_solution": "def analyse_playlist(playlist):\n    if len(playlist) < 5:\n        return \"Zu wenige Songs in der Playlist\"\n    longest = max(playlist, key=lambda x: x[1])\n    shortest = min(playlist, key=lambda x: x[1])\n    avg_duration = sum(song[1] for song in playlist) / len(playlist)\n    return (f\"Längster Song: {longest[0]}\", f\"Kürzester Song: {shortest[0]}\", f\"Durchschnittliche Dauer: {avg_duration:.1f} Sekunden\")\n\nplaylist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\nprint(analyse_playlist(playlist))",
    "unit_tests": "import unittest\nfrom main import analyse_playlist\n\nclass TestAnalysePlaylist(unittest.TestCase):\n    def test_zu_wenige_songs(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180)]\n        self.assertEqual(analyse_playlist(playlist), \"Zu wenige Songs in der Playlist\")\n\n    def test_längster_song(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\n        result = analyse_playlist(playlist)\n        self.assertIn(\"Längster Song: Song C\", result)\n\n    def test_kürzester_song(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\n        result = analyse_playlist(playlist)\n        self.assertIn(\"Kürzester Song: Song D\", result)\n\n    def test_durchschnittliche_dauer(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\n        result = analyse_playlist(playlist)\n        self.assertIn(\"Durchschnittliche Dauer: 196.0 Sekunden\", result)\n\n    def test_genau_fünf_songs(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200)]\n        result = analyse_playlist(playlist)\n        self.assertEqual(result, (\"Längster Song: Song C\", \"Kürzester Song: Song D\", \"Durchschnittliche Dauer: 196.0 Sekunden\"))\n\n    def test_mehr_als_fünf_songs(self):\n        playlist = [(\"Song A\", 210), (\"Song B\", 180), (\"Song C\", 240), (\"Song D\", 150), (\"Song E\", 200), (\"Song F\", 300)]\n        result = analyse_playlist(playlist)\n        self.assertEqual(result, (\"Längster Song: Song F\", \"Kürzester Song: Song D\", \"Durchschnittliche Dauer: 213.3 Sekunden\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 181,
    "programming_concept": "For-Schleifen;Rekursion;Operationen mit Zahlen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Punkteberechnung\n\nSchreibe eine Funktion namens `punkte_berechnung(spieler_punkte)`, die eine Liste von Punkten, die verschiedene Spieler in einem Turnier erzielt haben, als Argument erhält. Die Funktion soll die Gesamtpunktzahl aller Spieler berechnen und zurückgeben. Verwende eine For-Schleife, um die Punkte zu summieren. Implementiere zusätzlich eine rekursive Funktion `max_punkte(punkte_liste)`, die die höchste Punktzahl in der Liste findet und zurückgibt.\n\nBeispielaufruf:\n```python\nspieler_punkte = [10, 20, 15, 30, 25]\ngesamtpunkte = punkte_berechnung(spieler_punkte)\nhoechste_punktzahl = max_punkte(spieler_punkte)\nprint(\"Gesamtpunkte:\", gesamtpunkte)  # Ausgabe: Gesamtpunkte: 100\nprint(\"Höchste Punktzahl:\", hoechste_punktzahl)  # Ausgabe: Höchste Punktzahl: 30\n```",
    "code_skeleton": "def punkte_berechnung(spieler_punkte):\n    ## Hier Code einfügen\n\ndef max_punkte(punkte_liste):\n    ## Hier Code einfügen",
    "model_solution": "def punkte_berechnung(spieler_punkte):\n    return sum(spieler_punkte)\n\ndef max_punkte(punkte_liste):\n    if len(punkte_liste) == 1:\n        return punkte_liste[0]\n    else:\n        max_rest = max_punkte(punkte_liste[1:])\n        return punkte_liste[0] if punkte_liste[0] > max_rest else max_rest\n\nspieler_punkte = [10, 20, 15, 30, 25]\ngesamtpunkte = punkte_berechnung(spieler_punkte)\nhoechste_punktzahl = max_punkte(spieler_punkte)\nprint(\"Gesamtpunkte:\", gesamtpunkte)\nprint(\"Höchste Punktzahl:\", hoechste_punktzahl)",
    "unit_tests": "import unittest\nfrom main import punkte_berechnung, max_punkte\n\nclass TestPunkteBerechnung(unittest.TestCase):\n    def test_gesamtpunkte(self):\n        self.assertEqual(punkte_berechnung([10, 20, 15, 30, 25]), 100)\n        self.assertEqual(punkte_berechnung([0, 0, 0, 0]), 0)\n        self.assertEqual(punkte_berechnung([5, 5, 5, 5, 5]), 25)\n        self.assertEqual(punkte_berechnung([-10, 20, -15, 30, -25]), 0)\n        self.assertEqual(punkte_berechnung([100]), 100)\n\n    def test_max_punkte(self):\n        self.assertEqual(max_punkte([10, 20, 15, 30, 25]), 30)\n        self.assertEqual(max_punkte([0, 0, 0, 0]), 0)\n        self.assertEqual(max_punkte([5, 5, 5, 5, 5]), 5)\n        self.assertEqual(max_punkte([-10, 20, -15, 30, -25]), 30)\n        self.assertEqual(max_punkte([100]), 100)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 182,
    "programming_concept": "String;Listen;Funktionen als Variablen",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Positive Affirmationen\n\nPositive Affirmationen können helfen, das Selbstwertgefühl zu stärken und die psychische Gesundheit zu fördern. In dieser Aufgabe sollst du eine Funktion implementieren, die eine Liste von positiven Affirmationen verarbeitet und eine zufällige Affirmation zurückgibt.\n\n#### Aufgabe\n\nSchreibe eine Funktion `zufaellige_affirmation(affirmationen)`, die eine Liste von positiven Affirmationen als Argument erhält und eine zufällige Affirmation aus dieser Liste zurückgibt. Verwende die Funktion `random.choice` aus dem Modul `random`, um die zufällige Auswahl zu treffen.\n\n#### Beispiel\n\n```python\naffirmationen = [\n    \"Ich bin stark und fähig.\",\n    \"Ich verdiene Liebe und Respekt.\",\n    \"Ich bin genug, so wie ich bin.\",\n    \"Ich kann alles erreichen, was ich mir vornehme.\"\n]\n\nprint(zufaellige_affirmation(affirmationen))\n```\n\nDie Ausgabe könnte eine der Affirmationen aus der Liste sein, z.B. \"Ich bin stark und fähig.\"\n\n#### Hinweise\n\n- Importiere das Modul `random`, um die Funktion `random.choice` zu verwenden.\n- Die Funktion soll eine der Affirmationen aus der Liste zurückgeben.\n\nViel Erfolg!",
    "code_skeleton": "def zufaellige_affirmation(affirmationen):\n    ## Hier Code einfügen",
    "model_solution": "import random\n\ndef zufaellige_affirmation(affirmationen):\n    return random.choice(affirmationen)\n\naffirmationen = [\n    \"Ich bin stark und fähig.\",\n    \"Ich verdiene Liebe und Respekt.\",\n    \"Ich bin genug, so wie ich bin.\",\n    \"Ich kann alles erreichen, was ich mir vornehme.\"\n]\n\nprint(zufaellige_affirmation(affirmationen))",
    "unit_tests": "import unittest\nfrom main import zufaellige_affirmation\n\nclass TestZufaelligeAffirmation(unittest.TestCase):\n    def test_auswahl_aus_liste(self):\n        affirmationen = [\n            \"Ich bin stark und fähig.\",\n            \"Ich verdiene Liebe und Respekt.\",\n            \"Ich bin genug, so wie ich bin.\",\n            \"Ich kann alles erreichen, was ich mir vornehme.\"\n        ]\n        ergebnis = zufaellige_affirmation(affirmationen)\n        self.assertIn(ergebnis, affirmationen)\n\n    def test_leere_liste(self):\n        affirmationen = []\n        with self.assertRaises(IndexError):\n            zufaellige_affirmation(affirmationen)\n\n    def test_ein_element(self):\n        affirmationen = [\"Ich bin stark und fähig.\"]\n        self.assertEqual(zufaellige_affirmation(affirmationen), \"Ich bin stark und fähig.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 183,
    "programming_concept": "Tupel;Integer;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustier-Check\n\nSchreibe eine Funktion namens `haustier_check(haustier)`, die überprüft, ob das übergebene Haustier in einer vordefinierten Liste von erlaubten Haustieren enthalten ist. Die Liste der erlaubten Haustiere ist ein Tupel und enthält die folgenden Tiere: \"Hund\", \"Katze\", \"Hamster\", \"Kaninchen\", \"Papagei\".\n\nDie Funktion soll:\n1. Überprüfen, ob das übergebene Haustier in der Liste der erlaubten Haustiere enthalten ist.\n2. Wenn das Haustier erlaubt ist, soll die Funktion `True` zurückgeben.\n3. Wenn das Haustier nicht erlaubt ist, soll die Funktion `False` zurückgeben.\n\nBeispielaufrufe:\n- `haustier_check(\"Hund\")` gibt `True` zurück.\n- `haustier_check(\"Schlange\")` gibt `False` zurück.",
    "code_skeleton": "def haustier_check(haustier):\n    ## Hier Code einfügen",
    "model_solution": "def haustier_check(haustier):\n    return haustier in (\"Hund\", \"Katze\", \"Hamster\", \"Kaninchen\", \"Papagei\")\n\n# Beispielaufrufe\nprint(haustier_check(\"Hund\"))  # True\nprint(haustier_check(\"Schlange\"))  # False",
    "unit_tests": "import unittest\n\nfrom main import haustier_check\n\nclass TestHaustierCheck(unittest.TestCase):\n    def test_erlaubtes_haustier_hund(self):\n        self.assertTrue(haustier_check(\"Hund\"))\n\n    def test_erlaubtes_haustier_katze(self):\n        self.assertTrue(haustier_check(\"Katze\"))\n\n    def test_nicht_erlaubtes_haustier_schlange(self):\n        self.assertFalse(haustier_check(\"Schlange\"))\n\n    def test_nicht_erlaubtes_haustier_pferd(self):\n        self.assertFalse(haustier_check(\"Pferd\"))\n\n    def test_erlaubtes_haustier_hamster(self):\n        self.assertTrue(haustier_check(\"Hamster\"))\n\n    def test_erlaubtes_haustier_kaninchen(self):\n        self.assertTrue(haustier_check(\"Kaninchen\"))\n\n    def test_erlaubtes_haustier_papagei(self):\n        self.assertTrue(haustier_check(\"Papagei\"))\n\n    def test_leerer_string(self):\n        self.assertFalse(haustier_check(\"\"))\n\n    def test_none(self):\n        self.assertFalse(haustier_check(None))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 184,
    "programming_concept": "String;Integer;For-Schleifen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fische zählen\n\nSchreibe eine Funktion namens `zaehle_fische(fischarten)`, die eine Liste von Strings als Argument erhält. Jeder String in der Liste repräsentiert eine Fischart, die an einem Tag gefangen wurde. Die Funktion soll die Anzahl der Fische jeder Art zählen und das Ergebnis als Dictionary zurückgeben, wobei die Fischart der Schlüssel und die Anzahl der gefangenen Fische der Wert ist.\n\nBeispielaufruf:\n```python\nfischarten = [\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\"]\nprint(zaehle_fische(fischarten))\n```\n\nErwartete Ausgabe:\n```python\n{\"Hecht\": 3, \"Karpfen\": 2, \"Forelle\": 1}\n```",
    "code_skeleton": "def zaehle_fische(fischarten):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(fischarten):\n    zaehlung = {}\n    for fisch in fischarten:\n        if fisch in zaehlung:\n            zaehlung[fisch] += 1\n        else:\n            zaehlung[fisch] = 1\n    return zaehlung\n\nfischarten = [\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\"]\nprint(zaehle_fische(fischarten))",
    "unit_tests": "import unittest\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_einfacher_fall(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\"]), {\"Hecht\": 3, \"Karpfen\": 2, \"Forelle\": 1})\n\n    def test_leere_liste(self):\n        self.assertEqual(zaehle_fische([]), {})\n\n    def test_eine_fischart(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Hecht\", \"Hecht\"]), {\"Hecht\": 3})\n\n    def test_verschiedene_fischarten(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Forelle\"]), {\"Hecht\": 1, \"Karpfen\": 1, \"Forelle\": 1})\n\n    def test_gemischte_fischarten(self):\n        self.assertEqual(zaehle_fische([\"Hecht\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Karpfen\", \"Hecht\", \"Forelle\", \"Forelle\"]), {\"Hecht\": 3, \"Karpfen\": 2, \"Forelle\": 3})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 185,
    "programming_concept": "Rekursion;Float;Integer",
    "context": "Olympia",
    "task_description": "### Übungsaufgabe: Rekursive Berechnung der Medaillenpunkte\n\nIn den Olympischen Spielen werden Medaillen in Gold, Silber und Bronze vergeben. Jede Medaille hat einen bestimmten Punktwert:\n\n- Gold: 3 Punkte\n- Silber: 2 Punkte\n- Bronze: 1 Punkt\n\nSchreibe eine rekursive Funktion `berechne_medaillenpunkte(gold, silber, bronze)`, die die Gesamtpunktzahl für eine Nation basierend auf der Anzahl der gewonnenen Medaillen berechnet. Die Parameter `gold`, `silber` und `bronze` sind Ganzzahlen (Integer), die die Anzahl der jeweiligen Medaillen angeben. Die Funktion soll die Gesamtpunktzahl als Fließkommazahl (Float) zurückgeben.\n\nBeispielaufruf:\n```python\npunkte = berechne_medaillenpunkte(5, 3, 2)\nprint(punkte)  # Ausgabe: 21.0\n```\n\nImplementiere die Funktion so, dass sie rekursiv arbeitet.",
    "code_skeleton": "def berechne_medaillenpunkte(gold, silber, bronze):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_medaillenpunkte(gold, silber, bronze):\n    if gold == 0 and silber == 0 and bronze == 0:\n        return 0.0\n    if gold > 0:\n        return 3.0 + berechne_medaillenpunkte(gold - 1, silber, bronze)\n    if silber > 0:\n        return 2.0 + berechne_medaillenpunkte(gold, silber - 1, bronze)\n    return 1.0 + berechne_medaillenpunkte(gold, silber, bronze - 1)\n\npunkte = berechne_medaillenpunkte(5, 3, 2)\nprint(punkte)  # Ausgabe: 21.0",
    "unit_tests": "import unittest\nfrom main import berechne_medaillenpunkte\n\nclass TestBerechneMedaillenpunkte(unittest.TestCase):\n    def test_keine_medaillen(self):\n        self.assertEqual(berechne_medaillenpunkte(0, 0, 0), 0.0)\n\n    def test_nur_gold(self):\n        self.assertEqual(berechne_medaillenpunkte(5, 0, 0), 15.0)\n\n    def test_nur_silber(self):\n        self.assertEqual(berechne_medaillenpunkte(0, 3, 0), 6.0)\n\n    def test_nur_bronze(self):\n        self.assertEqual(berechne_medaillenpunkte(0, 0, 2), 2.0)\n\n    def test_gemischte_medaillen(self):\n        self.assertEqual(berechne_medaillenpunkte(5, 3, 2), 21.0)\n\n    def test_randbedingung(self):\n        self.assertEqual(berechne_medaillenpunkte(1, 1, 1), 6.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 186,
    "programming_concept": "If-Else-Anweisungen;While-Schleifen;Boolean und None",
    "context": "Modernes Gaming",
    "task_description": "### Übungsaufgabe: Modernes Gaming - Spielerlevel und Erfahrungspunkte\n\nSchreibe eine Funktion `level_up(spieler_level, erfahrungspunkte)`, die überprüft, ob ein Spieler basierend auf seinen Erfahrungspunkten ein Level aufsteigen kann. \n\n- Wenn der Spieler 1000 oder mehr Erfahrungspunkte hat, steigt er ein Level auf und die Funktion gibt `True` zurück.\n- Wenn der Spieler weniger als 1000 Erfahrungspunkte hat, bleibt er auf dem aktuellen Level und die Funktion gibt `False` zurück.\n- Wenn der Spieler keine Erfahrungspunkte (None) hat, gibt die Funktion ebenfalls `False` zurück.\n\nZusätzlich soll die Funktion eine While-Schleife verwenden, um die Erfahrungspunkte des Spielers zu reduzieren, bis sie unter 1000 fallen, falls der Spieler ein Level aufsteigt.\n\nBeispielaufruf:\n```python\nlevel_up(5, 1200)  # gibt True zurück und reduziert die Erfahrungspunkte auf 200\nlevel_up(3, 800)   # gibt False zurück\nlevel_up(2, None)  # gibt False zurück\n```",
    "code_skeleton": "def level_up(spieler_level, erfahrungspunkte):\n    ## Hier Code einfügen",
    "model_solution": "def level_up(spieler_level, erfahrungspunkte):\n    if erfahrungspunkte is None or erfahrungspunkte < 1000:\n        return False\n    while erfahrungspunkte >= 1000:\n        erfahrungspunkte -= 1000\n        spieler_level += 1\n    return True\n\n# Beispielaufrufe\nprint(level_up(5, 1200))  # True\nprint(level_up(3, 800))   # False\nprint(level_up(2, None))  # False",
    "unit_tests": "import unittest\n\nfrom main import level_up\n\nclass TestLevelUp(unittest.TestCase):\n    def test_level_up_with_enough_experience(self):\n        self.assertTrue(level_up(5, 1200))\n\n    def test_level_up_with_not_enough_experience(self):\n        self.assertFalse(level_up(3, 800))\n\n    def test_level_up_with_no_experience(self):\n        self.assertFalse(level_up(2, None))\n\n    def test_level_up_with_exact_experience(self):\n        self.assertTrue(level_up(1, 1000))\n\n    def test_level_up_with_multiple_levels(self):\n        self.assertTrue(level_up(1, 2500))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 187,
    "programming_concept": "Rekursion;Funktionen höherer Ordnung;Operationen mit Zahlen",
    "context": "Angeln",
    "task_description": "### Übungsaufgabe: Fische zählen\n\nDu bist ein begeisterter Angler und möchtest eine Funktion schreiben, die dir hilft, die Anzahl der Fische in einem See zu zählen. Dabei soll die Funktion rekursiv arbeiten und Funktionen höherer Ordnung verwenden.\n\nSchreibe eine Funktion `zaehle_fische(see)`, die die Anzahl der Fische in einem See zählt. Der See wird als Liste von Listen dargestellt, wobei jede innere Liste eine Gruppe von Fischen repräsentiert. Jeder Fisch wird durch eine Zahl dargestellt, die sein Gewicht in Gramm angibt.\n\nDie Funktion `zaehle_fische(see)` soll die Gesamtanzahl der Fische im See zurückgeben.\n\nBeispiel:\n\n```python\nsee = [\n    [200, 150, 300],  # Gruppe 1\n    [100, 250],       # Gruppe 2\n    [400, 500, 100]   # Gruppe 3\n]\n\nprint(zaehle_fische(see))  # Ausgabe: 8\n```\n\nIn diesem Beispiel gibt es insgesamt 8 Fische im See.",
    "code_skeleton": "def zaehle_fische(see):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_fische(see):\n    return sum(map(len, see))\n\nsee = [\n    [200, 150, 300],\n    [100, 250],\n    [400, 500, 100]\n]\n\nprint(zaehle_fische(see))",
    "unit_tests": "import unittest\n\nfrom main import zaehle_fische\n\nclass TestZaehleFische(unittest.TestCase):\n    def test_einfacher_see(self):\n        self.assertEqual(zaehle_fische([[200, 150, 300], [100, 250], [400, 500, 100]]), 8)\n\n    def test_leerer_see(self):\n        self.assertEqual(zaehle_fische([]), 0)\n\n    def test_see_mit_einer_gruppe(self):\n        self.assertEqual(zaehle_fische([[200, 150, 300]]), 3)\n\n    def test_see_mit_leerer_gruppe(self):\n        self.assertEqual(zaehle_fische([[200, 150, 300], [], [400, 500, 100]]), 6)\n\n    def test_see_mit_vielen_gruppen(self):\n        self.assertEqual(zaehle_fische([[200], [150], [300], [100], [250], [400], [500], [100]]), 8)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 188,
    "programming_concept": "Integer;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Listen",
    "context": "Basketball",
    "task_description": "### Übungsaufgabe: Basketball-Statistik\n\nSchreibe eine Funktion namens `bewerte_spieler(punkte_liste)`, die eine Liste von erzielten Punkten eines Basketballspielers in verschiedenen Spielen erhält. Die Funktion soll die Leistung des Spielers bewerten und eine entsprechende Nachricht zurückgeben.\n\n- Wenn der Spieler in einem Spiel mehr als 30 Punkte erzielt hat, soll die Nachricht \"Hervorragende Leistung!\" zurückgegeben werden.\n- Wenn der Spieler in allen Spielen mindestens 10 Punkte erzielt hat, soll die Nachricht \"Konstant gute Leistung!\" zurückgegeben werden.\n- Wenn der Spieler in keinem Spiel mehr als 5 Punkte erzielt hat, soll die Nachricht \"Schwache Leistung!\" zurückgegeben werden.\n- In allen anderen Fällen soll die Nachricht \"Durchschnittliche Leistung.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `bewerte_spieler([12, 15, 8, 22, 30])` gibt \"Durchschnittliche Leistung.\" zurück.\n- `bewerte_spieler([35, 28, 40, 22, 31])` gibt \"Hervorragende Leistung!\" zurück.\n- `bewerte_spieler([10, 12, 14, 11, 10])` gibt \"Konstant gute Leistung!\" zurück.\n- `bewerte_spieler([3, 4, 2, 5, 1])` gibt \"Schwache Leistung!\" zurück.",
    "code_skeleton": "def bewerte_spieler(punkte_liste):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_spieler(punkte_liste):\n    if any(p > 30 for p in punkte_liste):\n        return \"Hervorragende Leistung!\"\n    elif all(p >= 10 for p in punkte_liste):\n        return \"Konstant gute Leistung!\"\n    elif all(p <= 5 for p in punkte_liste):\n        return \"Schwache Leistung!\"\n    else:\n        return \"Durchschnittliche Leistung.\"\n\n# Beispielaufrufe\nprint(bewerte_spieler([12, 15, 8, 22, 30]))\nprint(bewerte_spieler([35, 28, 40, 22, 31]))\nprint(bewerte_spieler([10, 12, 14, 11, 10]))\nprint(bewerte_spieler([3, 4, 2, 5, 1]))",
    "unit_tests": "import unittest\nfrom main import bewerte_spieler\n\nclass TestBewerteSpieler(unittest.TestCase):\n    def test_hervorragende_leistung(self):\n        self.assertEqual(bewerte_spieler([35, 28, 40, 22, 31]), \"Hervorragende Leistung!\")\n\n    def test_konstant_gute_leistung(self):\n        self.assertEqual(bewerte_spieler([10, 12, 14, 11, 10]), \"Konstant gute Leistung!\")\n\n    def test_schwache_leistung(self):\n        self.assertEqual(bewerte_spieler([3, 4, 2, 5, 1]), \"Schwache Leistung!\")\n\n    def test_durchschnittliche_leistung(self):\n        self.assertEqual(bewerte_spieler([12, 15, 8, 22, 30]), \"Durchschnittliche Leistung.\")\n\n    def test_leere_liste(self):\n        self.assertEqual(bewerte_spieler([]), \"Durchschnittliche Leistung.\")\n\n    def test_grenzwert_30_punkte(self):\n        self.assertEqual(bewerte_spieler([30, 30, 30]), \"Durchschnittliche Leistung.\")\n\n    def test_grenzwert_10_punkte(self):\n        self.assertEqual(bewerte_spieler([10, 10, 10]), \"Konstant gute Leistung.\")\n\n    def test_grenzwert_5_punkte(self):\n        self.assertEqual(bewerte_spieler([5, 5, 5]), \"Schwache Leistung.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 189,
    "programming_concept": "Float;Operationen mit Zahlen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not)",
    "context": "Haustiere",
    "task_description": "### Übungsaufgabe: Haustiergewichtskontrolle\n\nSchreibe eine Funktion namens `gewichtskontrolle(gewicht)`, die das Gewicht eines Haustiers (in Kilogramm) als Float-Wert entgegennimmt und eine entsprechende Nachricht mit `return` zurückgibt. Die Funktion soll anhand des Gewichts des Haustiers entscheiden, ob das Haustier untergewichtig, normalgewichtig oder übergewichtig ist.\n\n- Wenn das Gewicht kleiner als 2.0 kg ist, soll die Nachricht \"Das Haustier ist untergewichtig.\" zurückgegeben werden.\n- Wenn das Gewicht zwischen 2.0 kg und 5.0 kg (einschließlich) liegt, soll die Nachricht \"Das Haustier hat ein normales Gewicht.\" zurückgegeben werden.\n- Wenn das Gewicht größer als 5.0 kg ist, soll die Nachricht \"Das Haustier ist übergewichtig.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `gewichtskontrolle(1.5)` gibt \"Das Haustier ist untergewichtig.\" zurück.\n- `gewichtskontrolle(3.0)` gibt \"Das Haustier hat ein normales Gewicht.\" zurück.\n- `gewichtskontrolle(6.0)` gibt \"Das Haustier ist übergewichtig.\" zurück.",
    "code_skeleton": "def gewichtskontrolle(gewicht):\n    ## Hier Code einfügen",
    "model_solution": "def gewichtskontrolle(gewicht):\n    if gewicht < 2.0:\n        return \"Das Haustier ist untergewichtig.\"\n    elif gewicht <= 5.0:\n        return \"Das Haustier hat ein normales Gewicht.\"\n    else:\n        return \"Das Haustier ist übergewichtig.\"\n\n# Beispielaufrufe\nprint(gewichtskontrolle(1.5))\nprint(gewichtskontrolle(3.0))\nprint(gewichtskontrolle(6.0))",
    "unit_tests": "import unittest\nfrom main import gewichtskontrolle\n\nclass TestGewichtskontrolle(unittest.TestCase):\n    def test_untergewichtig(self):\n        self.assertEqual(gewichtskontrolle(1.5), \"Das Haustier ist untergewichtig.\")\n\n    def test_normales_gewicht_untergrenze(self):\n        self.assertEqual(gewichtskontrolle(2.0), \"Das Haustier hat ein normales Gewicht.\")\n\n    def test_normales_gewicht_mitte(self):\n        self.assertEqual(gewichtskontrolle(3.0), \"Das Haustier hat ein normales Gewicht.\")\n\n    def test_normales_gewicht_obergrenze(self):\n        self.assertEqual(gewichtskontrolle(5.0), \"Das Haustier hat ein normales Gewicht.\")\n\n    def test_uebergewichtig(self):\n        self.assertEqual(gewichtskontrolle(6.0), \"Das Haustier ist übergewichtig.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 190,
    "programming_concept": "Integer;Listen;String",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spieler Statistik\n\nSchreibe eine Funktion namens `spieler_statistik(spieler_liste)`, die eine Liste von Spielernamen und deren erzielten Punkte in einem Rugby-Spiel erhält. Die Liste enthält Strings im Format \"Name:Punkte\", wobei \"Name\" der Name des Spielers und \"Punkte\" die erzielten Punkte als Integer sind.\n\nDie Funktion soll die folgenden Aufgaben erfüllen:\n1. Die Gesamtpunktzahl aller Spieler berechnen und zurückgeben.\n2. Den Namen des Spielers mit den meisten Punkten zurückgeben. Falls mehrere Spieler die gleiche höchste Punktzahl haben, soll der erste in der Liste zurückgegeben werden.\n\nBeispielaufruf:\n```python\nspieler_liste = [\"Max:5\", \"Anna:3\", \"Tom:7\", \"Lisa:7\"]\ngesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\nprint(gesamtpunkte)  # Ausgabe: 22\nprint(bester_spieler)  # Ausgabe: Tom\n```\n\nImplementiere die Funktion `spieler_statistik(spieler_liste)`, um die oben genannten Anforderungen zu erfüllen.",
    "code_skeleton": "def spieler_statistik(spieler_liste):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_statistik(spieler_liste):\n    gesamtpunkte = 0\n    bester_spieler = \"\"\n    max_punkte = -1\n    for eintrag in spieler_liste:\n        name, punkte = eintrag.split(\":\")\n        punkte = int(punkte)\n        gesamtpunkte += punkte\n        if punkte > max_punkte:\n            max_punkte = punkte\n            bester_spieler = name\n    return gesamtpunkte, bester_spieler\n\nspieler_liste = [\"Max:5\", \"Anna:3\", \"Tom:7\", \"Lisa:7\"]\ngesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\nprint(gesamtpunkte)  # Ausgabe: 22\nprint(bester_spieler)  # Ausgabe: Tom",
    "unit_tests": "import unittest\n\nfrom main import spieler_statistik\n\nclass TestSpielerStatistik(unittest.TestCase):\n    def test_einfacher_fall(self):\n        spieler_liste = [\"Max:5\", \"Anna:3\", \"Tom:7\", \"Lisa:7\"]\n        gesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\n        self.assertEqual(gesamtpunkte, 22)\n        self.assertEqual(bester_spieler, \"Tom\")\n\n    def test_alle_spieler_gleiche_punkte(self):\n        spieler_liste = [\"Max:5\", \"Anna:5\", \"Tom:5\", \"Lisa:5\"]\n        gesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\n        self.assertEqual(gesamtpunkte, 20)\n        self.assertEqual(bester_spieler, \"Max\")\n\n    def test_ein_spieler(self):\n        spieler_liste = [\"Max:10\"]\n        gesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\n        self.assertEqual(gesamtpunkte, 10)\n        self.assertEqual(bester_spieler, \"Max\")\n\n    def test_leere_liste(self):\n        spieler_liste = []\n        gesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\n        self.assertEqual(gesamtpunkte, 0)\n        self.assertEqual(bester_spieler, \"\")\n\n    def test_negativ_punkte(self):\n        spieler_liste = [\"Max:-5\", \"Anna:3\", \"Tom:7\", \"Lisa:7\"]\n        gesamtpunkte, bester_spieler = spieler_statistik(spieler_liste)\n        self.assertEqual(gesamtpunkte, 12)\n        self.assertEqual(bester_spieler, \"Tom\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 191,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Rekursion;Boolean und None",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spieler Klassifikation\n\nSchreibe eine Funktion `klassifiziere_spieler(gewicht, groesse)`, die einen Rugby-Spieler basierend auf seinem Gewicht (in Kilogramm) und seiner Größe (in Zentimetern) klassifiziert. Die Klassifikation erfolgt nach folgenden Regeln:\n\n- Ein Spieler wird als \"Leichtgewicht\" klassifiziert, wenn sein Gewicht weniger als 75 kg beträgt.\n- Ein Spieler wird als \"Schwergewicht\" klassifiziert, wenn sein Gewicht 75 kg oder mehr beträgt.\n- Ein Spieler wird als \"Groß\" klassifiziert, wenn seine Größe 185 cm oder mehr beträgt.\n- Ein Spieler wird als \"Klein\" klassifiziert, wenn seine Größe weniger als 185 cm beträgt.\n\nDie Funktion soll eine Nachricht zurückgeben, die die Klassifikation des Spielers beschreibt. Beispiel:\n\n- `klassifiziere_spieler(70, 190)` gibt \"Leichtgewicht und Groß\" zurück.\n- `klassifiziere_spieler(80, 180)` gibt \"Schwergewicht und Klein\" zurück.\n\nZusätzlich soll eine rekursive Funktion `ist_gross(gewicht, groesse)` implementiert werden, die überprüft, ob ein Spieler als \"Groß\" klassifiziert wird. Diese Funktion soll `True` zurückgeben, wenn die Größe des Spielers 185 cm oder mehr beträgt, und `False` sonst.\n\nBeispielaufrufe:\n- `klassifiziere_spieler(70, 190)`\n- `klassifiziere_spieler(80, 180)`\n- `ist_gross(70, 190)`\n- `ist_gross(80, 180)`",
    "code_skeleton": "def klassifiziere_spieler(gewicht, groesse):\n    ## Hier Code einfügen\n\ndef ist_gross(gewicht, groesse):\n    ## Hier Code einfügen",
    "model_solution": "def klassifiziere_spieler(gewicht, groesse):\n    gewicht_klassifikation = \"Leichtgewicht\" if gewicht < 75 else \"Schwergewicht\"\n    groesse_klassifikation = \"Groß\" if groesse >= 185 else \"Klein\"\n    print(f\"{gewicht_klassifikation} und {groesse_klassifikation}\")\n\ndef ist_gross(gewicht, groesse):\n    if groesse >= 185:\n        return True\n    return False\n\nklassifiziere_spieler(70, 190)\nklassifiziere_spieler(80, 180)\nprint(ist_gross(70, 190))\nprint(ist_gross(80, 180))",
    "unit_tests": "import unittest\nfrom main import klassifiziere_spieler, ist_gross\n\nclass TestKlassifiziereSpieler(unittest.TestCase):\n    def test_leichtgewicht_gross(self):\n        self.assertEqual(klassifiziere_spieler(70, 190), \"Leichtgewicht und Groß\")\n\n    def test_schwergewicht_klein(self):\n        self.assertEqual(klassifiziere_spieler(80, 180), \"Schwergewicht und Klein\")\n\n    def test_leichtgewicht_klein(self):\n        self.assertEqual(klassifiziere_spieler(70, 180), \"Leichtgewicht und Klein\")\n\n    def test_schwergewicht_gross(self):\n        self.assertEqual(klassifiziere_spieler(80, 190), \"Schwergewicht und Groß\")\n\nclass TestIstGross(unittest.TestCase):\n    def test_gross(self):\n        self.assertTrue(ist_gross(70, 190))\n\n    def test_nicht_gross(self):\n        self.assertFalse(ist_gross(80, 180))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 192,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);For-Schleifen;Tupel",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Spieler-Statistiken\n\nSchreibe eine Funktion `spieler_statistiken(spieler_liste)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel repräsentiert einen Rugby-Spieler und enthält folgende Informationen in dieser Reihenfolge: Name (String), Alter (Integer), Anzahl der Versuche (Integer).\n\nDie Funktion soll die folgenden Aufgaben erfüllen:\n1. Alle Spieler, die älter als 30 Jahre sind und mehr als 5 Versuche erzielt haben, in einer neuen Liste speichern.\n2. Die Anzahl der Spieler, die diese Kriterien erfüllen, zurückgeben.\n3. Die Namen dieser Spieler in der Konsole ausgeben.\n\nBeispielaufruf:\n```python\nspieler_liste = [(\"Max\", 32, 6), (\"Tom\", 28, 4), (\"John\", 35, 7), (\"Alex\", 22, 3)]\nanzahl_spieler = spieler_statistiken(spieler_liste)\nprint(anzahl_spieler)  # Ausgabe: 2\n```\n\nIn diesem Beispiel sind \"Max\" und \"John\" die Spieler, die älter als 30 Jahre sind und mehr als 5 Versuche erzielt haben.",
    "code_skeleton": "def spieler_statistiken(spieler_liste):\n    ## Hier Code einfügen",
    "model_solution": "def spieler_statistiken(spieler_liste):\n    result = [spieler[0] for spieler in spieler_liste if spieler[1] > 30 and spieler[2] > 5]\n    for name in result:\n        print(name)\n    return len(result)\n\nspieler_liste = [(\"Max\", 32, 6), (\"Tom\", 28, 4), (\"John\", 35, 7), (\"Alex\", 22, 3)]\nanzahl_spieler = spieler_statistiken(spieler_liste)\nprint(anzahl_spieler)",
    "unit_tests": "import unittest\nfrom main import spieler_statistiken\n\nclass TestSpielerStatistiken(unittest.TestCase):\n    def test_mehrere_spieler(self):\n        spieler_liste = [(\"Max\", 32, 6), (\"Tom\", 28, 4), (\"John\", 35, 7), (\"Alex\", 22, 3)]\n        self.assertEqual(spieler_statistiken(spieler_liste), 2)\n\n    def test_keine_spieler(self):\n        spieler_liste = [(\"Tom\", 28, 4), (\"Alex\", 22, 3)]\n        self.assertEqual(spieler_statistiken(spieler_liste), 0)\n\n    def test_alle_spieler(self):\n        spieler_liste = [(\"Max\", 32, 6), (\"John\", 35, 7)]\n        self.assertEqual(spieler_statistiken(spieler_liste), 2)\n\n    def test_grenzwert_spieler(self):\n        spieler_liste = [(\"Max\", 30, 6), (\"John\", 31, 5)]\n        self.assertEqual(spieler_statistiken(spieler_liste), 0)\n\n    def test_leere_liste(self):\n        spieler_liste = []\n        self.assertEqual(spieler_statistiken(spieler_liste), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 193,
    "programming_concept": "For-Schleifen;Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);If-Else-Anweisungen",
    "context": "Kochen",
    "task_description": "### Übungsaufgabe: Zutatenprüfung für ein Rezept\n\nSchreibe eine Funktion namens `pruefe_zutaten(zutaten_liste)`, die eine Liste von Zutaten als Argument erhält. Die Funktion soll überprüfen, ob alle notwendigen Zutaten für ein bestimmtes Rezept vorhanden sind. Das Rezept benötigt die folgenden Zutaten: \"Mehl\", \"Eier\", \"Milch\", \"Zucker\" und \"Butter\".\n\nDie Funktion soll:\n1. Überprüfen, ob jede der benötigten Zutaten in der übergebenen Liste enthalten ist.\n2. Eine Nachricht zurückgeben, die angibt, ob alle Zutaten vorhanden sind oder welche Zutaten fehlen.\n\nBeispielaufruf:\n```python\npruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\", \"Zucker\", \"Butter\"])\n```\nsollte zurückgeben:\n```python\n\"Alle Zutaten sind vorhanden.\"\n```\n\nEin anderer Beispielaufruf:\n```python\npruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\"])\n```\nsollte zurückgeben:\n```python\n\"Es fehlen die folgenden Zutaten: Zucker, Butter\"\n```",
    "code_skeleton": "def pruefe_zutaten(zutaten_liste):\n    ## Hier Code einfügen",
    "model_solution": "def pruefe_zutaten(zutaten_liste):\n    rezept_zutaten = {\"Mehl\", \"Eier\", \"Milch\", \"Zucker\", \"Butter\"}\n    fehlende_zutaten = rezept_zutaten - set(zutaten_liste)\n    if fehlende_zutaten:\n        print(f\"Es fehlen die folgenden Zutaten: {', '.join(fehlende_zutaten)}\")\n    else:\n        print(\"Alle Zutaten sind vorhanden.\")\n\npruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\", \"Zucker\", \"Butter\"])\npruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\"])",
    "unit_tests": "import unittest\n\nfrom main import pruefe_zutaten\n\nclass TestPruefeZutaten(unittest.TestCase):\n    def test_alle_zutaten_vorhanden(self):\n        self.assertEqual(pruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\", \"Zucker\", \"Butter\"]), \"Alle Zutaten sind vorhanden.\")\n\n    def test_einige_zutaten_fehlen(self):\n        self.assertEqual(pruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\"]), \"Es fehlen die folgenden Zutaten: Zucker, Butter\")\n\n    def test_alle_zutaten_fehlen(self):\n        self.assertEqual(pruefe_zutaten([]), \"Es fehlen die folgenden Zutaten: Mehl, Eier, Milch, Zucker, Butter\")\n\n    def test_eine_zutat_fehlt(self):\n        self.assertEqual(pruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\", \"Zucker\"]), \"Es fehlt die folgende Zutat: Butter\")\n\n    def test_doppelte_zutaten(self):\n        self.assertEqual(pruefe_zutaten([\"Mehl\", \"Eier\", \"Milch\", \"Zucker\", \"Butter\", \"Butter\"]), \"Alle Zutaten sind vorhanden.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 194,
    "programming_concept": "Boolean und None;String;Operationen mit Zahlen",
    "context": "Sport",
    "task_description": "### Übungsaufgabe: Sportliche Leistungen bewerten\n\nSchreibe eine Funktion namens `bewerte_leistung(punkte)`, die eine Punktzahl als Argument erhält und eine entsprechende Bewertung als String zurückgibt. Die Bewertung erfolgt nach folgenden Kriterien:\n\n- Wenn die Punktzahl größer oder gleich 90 ist, soll die Funktion \"Hervorragend\" zurückgeben.\n- Wenn die Punktzahl zwischen 70 und 89 liegt (einschließlich), soll die Funktion \"Gut\" zurückgeben.\n- Wenn die Punktzahl zwischen 50 und 69 liegt (einschließlich), soll die Funktion \"Befriedigend\" zurückgeben.\n- Wenn die Punktzahl zwischen 30 und 49 liegt (einschließlich), soll die Funktion \"Ausreichend\" zurückgeben.\n- Wenn die Punktzahl kleiner als 30 ist, soll die Funktion \"Ungenügend\" zurückgeben.\n- Wenn die Punktzahl `None` ist, soll die Funktion \"Keine Bewertung möglich\" zurückgeben.\n\nBeispielaufrufe:\n- `bewerte_leistung(95)` gibt \"Hervorragend\" zurück.\n- `bewerte_leistung(75)` gibt \"Gut\" zurück.\n- `bewerte_leistung(None)` gibt \"Keine Bewertung möglich\" zurück.",
    "code_skeleton": "def bewerte_leistung(punkte):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_leistung(punkte):\n    if punkte is None:\n        return \"Keine Bewertung möglich\"\n    if punkte >= 90:\n        return \"Hervorragend\"\n    if punkte >= 70:\n        return \"Gut\"\n    if punkte >= 50:\n        return \"Befriedigend\"\n    if punkte >= 30:\n        return \"Ausreichend\"\n    return \"Ungenügend\"\n\n# Beispielaufrufe\nprint(bewerte_leistung(95))  # Hervorragend\nprint(bewerte_leistung(75))  # Gut\nprint(bewerte_leistung(None))  # Keine Bewertung möglich",
    "unit_tests": "import unittest\nfrom main import bewerte_leistung\n\nclass TestBewerteLeistung(unittest.TestCase):\n    def test_hervorragend(self):\n        self.assertEqual(bewerte_leistung(95), \"Hervorragend\")\n        self.assertEqual(bewerte_leistung(90), \"Hervorragend\")\n\n    def test_gut(self):\n        self.assertEqual(bewerte_leistung(75), \"Gut\")\n        self.assertEqual(bewerte_leistung(70), \"Gut\")\n\n    def test_befriedigend(self):\n        self.assertEqual(bewerte_leistung(60), \"Befriedigend\")\n        self.assertEqual(bewerte_leistung(50), \"Befriedigend\")\n\n    def test_ausreichend(self):\n        self.assertEqual(bewerte_leistung(40), \"Ausreichend\")\n        self.assertEqual(bewerte_leistung(30), \"Ausreichend\")\n\n    def test_ungenuegend(self):\n        self.assertEqual(bewerte_leistung(20), \"Ungenügend\")\n        self.assertEqual(bewerte_leistung(0), \"Ungenügend\")\n\n    def test_keine_bewertung(self):\n        self.assertEqual(bewerte_leistung(None), \"Keine Bewertung möglich\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 195,
    "programming_concept": "If-Else-Anweisungen;Boolean und None;Funktionen als Variablen",
    "context": "Restaurant",
    "task_description": "### Übungsaufgabe: Restaurant-Bestellung\n\nSchreibe eine Funktion namens `bestellung_aufnehmen(bestellung)`, die eine Bestellung in einem Restaurant entgegennimmt und eine entsprechende Nachricht zurückgibt. Die Funktion soll folgende Bedingungen prüfen:\n\n1. Wenn die Bestellung \"Pizza\" ist, soll die Nachricht \"Ihre Pizza wird zubereitet.\" zurückgegeben werden.\n2. Wenn die Bestellung \"Pasta\" ist, soll die Nachricht \"Ihre Pasta wird zubereitet.\" zurückgegeben werden.\n3. Wenn die Bestellung \"Salat\" ist, soll die Nachricht \"Ihr Salat wird zubereitet.\" zurückgegeben werden.\n4. Für alle anderen Bestellungen soll die Nachricht \"Diese Bestellung ist leider nicht verfügbar.\" zurückgegeben werden.\n\nBeispielaufrufe:\n- `bestellung_aufnehmen(\"Pizza\")` gibt \"Ihre Pizza wird zubereitet.\" zurück.\n- `bestellung_aufnehmen(\"Burger\")` gibt \"Diese Bestellung ist leider nicht verfügbar.\" zurück.",
    "code_skeleton": "def bestellung_aufnehmen(bestellung):\n    ## Hier Code einfügen",
    "model_solution": "def bestellung_aufnehmen(bestellung):\n    if bestellung == \"Pizza\":\n        return \"Ihre Pizza wird zubereitet.\"\n    elif bestellung == \"Pasta\":\n        return \"Ihre Pasta wird zubereitet.\"\n    elif bestellung == \"Salat\":\n        return \"Ihr Salat wird zubereitet.\"\n    else:\n        return \"Diese Bestellung ist leider nicht verfügbar.\"\n\n# Beispielaufrufe\nprint(bestellung_aufnehmen(\"Pizza\"))\nprint(bestellung_aufnehmen(\"Burger\"))",
    "unit_tests": "import unittest\nfrom main import bestellung_aufnehmen\n\nclass TestBestellungAufnehmen(unittest.TestCase):\n    def test_pizza_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(\"Pizza\"), \"Ihre Pizza wird zubereitet.\")\n\n    def test_pasta_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(\"Pasta\"), \"Ihre Pasta wird zubereitet.\")\n\n    def test_salat_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(\"Salat\"), \"Ihr Salat wird zubereitet.\")\n\n    def test_unverfuegbare_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(\"Burger\"), \"Diese Bestellung ist leider nicht verfügbar.\")\n\n    def test_leere_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(\"\"), \"Diese Bestellung ist leider nicht verfügbar.\")\n\n    def test_null_bestellung(self):\n        self.assertEqual(bestellung_aufnehmen(None), \"Diese Bestellung ist leider nicht verfügbar.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 196,
    "programming_concept": "Operationen mit Zahlen;Rekursion;Float",
    "context": "Rugby",
    "task_description": "### Übungsaufgabe: Rugby-Punktestand berechnen\n\nIn einem Rugby-Spiel können Punkte auf verschiedene Arten erzielt werden: \n- Ein Versuch (Try) bringt 5 Punkte.\n- Eine Erhöhung (Conversion) bringt 2 Punkte.\n- Ein Straftritt (Penalty) oder ein Dropgoal bringt jeweils 3 Punkte.\n\nSchreibe eine Funktion `berechne_punkte(versuche, erhoehungen, straftritte, dropgoals)`, die die Gesamtpunktzahl eines Rugby-Teams berechnet. Die Funktion soll die Anzahl der Versuche, Erhöhungen, Straftritte und Dropgoals als Argumente entgegennehmen und die Gesamtpunktzahl als `float` zurückgeben.\n\nBeispielaufruf:\n```python\npunkte = berechne_punkte(3, 2, 1, 1)\nprint(punkte)  # Ausgabe: 22.0\n```\n\n### Erweiterung: Rekursive Berechnung\n\nErweitere die Funktion `berechne_punkte_rekursiv(versuche, erhoehungen, straftritte, dropgoals)`, die die gleiche Funktionalität wie `berechne_punkte` hat, aber die Berechnung der Gesamtpunktzahl rekursiv durchführt.\n\nBeispielaufruf:\n```python\npunkte = berechne_punkte_rekursiv(3, 2, 1, 1)\nprint(punkte)  # Ausgabe: 22.0\n```",
    "code_skeleton": "def berechne_punkte(versuche, erhoehungen, straftritte, dropgoals):\n    ## Hier Code einfügen\n\ndef berechne_punkte_rekursiv(versuche, erhoehungen, straftritte, dropgoals):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_punkte(versuche, erhoehungen, straftritte, dropgoals):\n    return versuche * 5 + erhoehungen * 2 + straftritte * 3 + dropgoals * 3\n\ndef berechne_punkte_rekursiv(versuche, erhoehungen, straftritte, dropgoals):\n    if versuche == 0 and erhoehungen == 0 and straftritte == 0 and dropgoals == 0:\n        return 0\n    if versuche > 0:\n        return 5 + berechne_punkte_rekursiv(versuche - 1, erhoehungen, straftritte, dropgoals)\n    if erhoehungen > 0:\n        return 2 + berechne_punkte_rekursiv(versuche, erhoehungen - 1, straftritte, dropgoals)\n    if straftritte > 0:\n        return 3 + berechne_punkte_rekursiv(versuche, erhoehungen, straftritte - 1, dropgoals)\n    if dropgoals > 0:\n        return 3 + berechne_punkte_rekursiv(versuche, erhoehungen, straftritte, dropgoals - 1)\n\npunkte = berechne_punkte(3, 2, 1, 1)\nprint(punkte)  # Ausgabe: 22.0\n\npunkte_rekursiv = berechne_punkte_rekursiv(3, 2, 1, 1)\nprint(punkte_rekursiv)  # Ausgabe: 22.0",
    "unit_tests": "import unittest\nfrom main import berechne_punkte, berechne_punkte_rekursiv\n\nclass TestBerechnePunkte(unittest.TestCase):\n    def test_alle_null(self):\n        self.assertEqual(berechne_punkte(0, 0, 0, 0), 0.0)\n    \n    def test_nur_versuche(self):\n        self.assertEqual(berechne_punkte(3, 0, 0, 0), 15.0)\n    \n    def test_nur_erhoehungen(self):\n        self.assertEqual(berechne_punkte(0, 2, 0, 0), 4.0)\n    \n    def test_nur_straftritte(self):\n        self.assertEqual(berechne_punkte(0, 0, 1, 0), 3.0)\n    \n    def test_nur_dropgoals(self):\n        self.assertEqual(berechne_punkte(0, 0, 0, 1), 3.0)\n    \n    def test_gemischt(self):\n        self.assertEqual(berechne_punkte(3, 2, 1, 1), 22.0)\n\nclass TestBerechnePunkteRekursiv(unittest.TestCase):\n    def test_alle_null(self):\n        self.assertEqual(berechne_punkte_rekursiv(0, 0, 0, 0), 0.0)\n    \n    def test_nur_versuche(self):\n        self.assertEqual(berechne_punkte_rekursiv(3, 0, 0, 0), 15.0)\n    \n    def test_nur_erhoehungen(self):\n        self.assertEqual(berechne_punkte_rekursiv(0, 2, 0, 0), 4.0)\n    \n    def test_nur_straftritte(self):\n        self.assertEqual(berechne_punkte_rekursiv(0, 0, 1, 0), 3.0)\n    \n    def test_nur_dropgoals(self):\n        self.assertEqual(berechne_punkte_rekursiv(0, 0, 0, 1), 3.0)\n    \n    def test_gemischt(self):\n        self.assertEqual(berechne_punkte_rekursiv(3, 2, 1, 1), 22.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 197,
    "programming_concept": "Float;If-Else-Anweisungen;Funktionen höherer Ordnung",
    "context": "Soziale Medien",
    "task_description": "### Übungsaufgabe: Soziale Medien - Engagement Rate Berechnung\n\nSchreibe eine Funktion namens `berechne_engagement_rate(likes, kommentare, follower)`, die die Engagement Rate eines Social Media Posts berechnet. Die Engagement Rate wird als Prozentsatz der Interaktionen (Likes und Kommentare) im Verhältnis zur Anzahl der Follower berechnet.\n\nDie Funktion soll die folgenden Schritte ausführen:\n1. Die Gesamtanzahl der Interaktionen berechnen (Likes + Kommentare).\n2. Die Engagement Rate als Prozentsatz der Interaktionen im Verhältnis zur Anzahl der Follower berechnen.\n3. Die Engagement Rate zurückgeben.\n\nZusätzlich soll die Funktion eine Nachricht ausgeben, die die Engagement Rate bewertet:\n- Wenn die Engagement Rate größer oder gleich 10% ist, soll die Nachricht \"Hohe Engagement Rate!\" ausgegeben werden.\n- Wenn die Engagement Rate zwischen 5% und 10% liegt, soll die Nachricht \"Durchschnittliche Engagement Rate\" ausgegeben werden.\n- Wenn die Engagement Rate unter 5% liegt, soll die Nachricht \"Niedrige Engagement Rate\" ausgegeben werden.\n\nBeispielaufruf:\n```python\nberechne_engagement_rate(150, 30, 2000)\n```\n\nErwartete Ausgabe:\n```\nDurchschnittliche Engagement Rate\n```\n\nErwarteter Rückgabewert:\n```python\n9.0\n```",
    "code_skeleton": "def berechne_engagement_rate(likes, kommentare, follower):\n    ## Hier Code einfügen",
    "model_solution": "def berechne_engagement_rate(likes, kommentare, follower):\n    interaktionen = likes + kommentare\n    engagement_rate = (interaktionen / follower) * 100\n    if engagement_rate >= 10:\n        print(\"Hohe Engagement Rate!\")\n    elif engagement_rate >= 5:\n        print(\"Durchschnittliche Engagement Rate\")\n    else:\n        print(\"Niedrige Engagement Rate\")\n    return engagement_rate\n\n# Beispielaufruf\nprint(berechne_engagement_rate(150, 30, 2000))",
    "unit_tests": "import unittest\nfrom main import berechne_engagement_rate\n\nclass TestBerechneEngagementRate(unittest.TestCase):\n    def test_hohe_engagement_rate(self):\n        self.assertEqual(berechne_engagement_rate(200, 100, 2000), 15.0)\n\n    def test_durchschnittliche_engagement_rate(self):\n        self.assertEqual(berechne_engagement_rate(150, 30, 2000), 9.0)\n\n    def test_niedrige_engagement_rate(self):\n        self.assertEqual(berechne_engagement_rate(50, 20, 2000), 3.5)\n\n    def test_null_follower(self):\n        with self.assertRaises(ZeroDivisionError):\n            berechne_engagement_rate(100, 50, 0)\n\n    def test_keine_interaktionen(self):\n        self.assertEqual(berechne_engagement_rate(0, 0, 2000), 0.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 198,
    "programming_concept": "Kontrollstrukturen (==, !=, <, >, <=, >=, or, and, not);Tupel;For-Schleifen",
    "context": "Psychische Gesundheit",
    "task_description": "### Übungsaufgabe: Psychische Gesundheit und Aktivitätslevel\n\nSchreibe eine Funktion namens `bewerte_aktivitaet(tage)`, die ein Tupel von 7 Ganzzahlen (jeweils zwischen 0 und 24) als Eingabe erhält. Jede Zahl im Tupel repräsentiert die Anzahl der Stunden, die eine Person an einem bestimmten Tag der Woche aktiv war. Die Funktion soll die Aktivitätslevel der Person bewerten und eine entsprechende Nachricht zurückgeben.\n\n- Wenn die Person an mindestens 5 Tagen der Woche mehr als 1 Stunde aktiv war, soll die Nachricht \"Gut gemacht! Du bist sehr aktiv.\" zurückgegeben werden.\n- Wenn die Person an mindestens 3 Tagen der Woche mehr als 1 Stunde aktiv war, soll die Nachricht \"Nicht schlecht, aber es gibt Raum für Verbesserung.\" zurückgegeben werden.\n- Andernfalls soll die Nachricht \"Versuche, aktiver zu sein, um deine psychische Gesundheit zu verbessern.\" zurückgegeben werden.\n\nBeispielaufruf:\n```python\nbewerte_aktivitaet((1, 2, 0, 3, 4, 0, 1))\n```\n\nErwartete Ausgabe:\n```\nNicht schlecht, aber es gibt Raum für Verbesserung.\n```",
    "code_skeleton": "def bewerte_aktivitaet(tage):\n    ## Hier Code einfügen",
    "model_solution": "def bewerte_aktivitaet(tage):\n    aktiv = sum(1 for stunden in tage wenn stunden > 1)\n    wenn aktiv >= 5:\n        print(\"Gut gemacht! Du bist sehr aktiv.\")\n    elif aktiv >= 3:\n        print(\"Nicht schlecht, aber es gibt Raum für Verbesserung.\")\n    sonst:\n        print(\"Versuche, aktiver zu sein, um deine psychische Gesundheit zu verbessern.\")\n\nbewerte_aktivitaet((1, 2, 0, 3, 4, 0, 1))",
    "unit_tests": "import unittest\nfrom main import bewerte_aktivitaet\n\nclass TestBewerteAktivitaet(unittest.TestCase):\n    def test_sehr_aktiv(self):\n        self.assertEqual(bewerte_aktivitaet((2, 3, 4, 5, 6, 1, 0)), \"Gut gemacht! Du bist sehr aktiv.\")\n\n    def test_mittelmaessig_aktiv(self):\n        self.assertEqual(bewerte_aktivitaet((1, 2, 0, 3, 4, 0, 1)), \"Nicht schlecht, aber es gibt Raum für Verbesserung.\")\n\n    def test_wenig_aktiv(self):\n        self.assertEqual(bewerte_aktivitaet((0, 1, 0, 1, 0, 0, 0)), \"Versuche, aktiver zu sein, um deine psychische Gesundheit zu verbessern.\")\n\n    def test_grenze_aktiv(self):\n        self.assertEqual(bewerte_aktivitaet((1, 2, 1, 2, 1, 2, 1)), \"Nicht schlecht, aber es gibt Raum für Verbesserung.\")\n\n    def test_grenze_sehr_aktiv(self):\n        self.assertEqual(bewerte_aktivitaet((2, 2, 2, 2, 2, 0, 0)), \"Gut gemacht! Du bist sehr aktiv.\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 199,
    "programming_concept": "While-Schleifen;String;Tupel",
    "context": "Film",
    "task_description": "### Übungsaufgabe: Filmzitate zählen\n\nSchreibe eine Funktion namens `zaehle_zitate(filmzitate)`, die eine Liste von Filmzitaten als Tupel erhält. Jedes Tupel enthält den Namen des Films und das Zitat. Die Funktion soll die Anzahl der Zitate für jeden Film zählen und das Ergebnis als Dictionary zurückgeben. Verwende eine While-Schleife, um durch die Liste der Filmzitate zu iterieren.\n\n#### Beispiel:\n```python\nfilmzitate = [\n    (\"Der Pate\", \"Ich werde ihm ein Angebot machen, das er nicht ablehnen kann.\"),\n    (\"Star Wars\", \"Möge die Macht mit dir sein.\"),\n    (\"Der Pate\", \"Lass die Waffe. Nimm die Cannoli.\"),\n    (\"Star Wars\", \"Ich bin dein Vater.\"),\n    (\"Der Pate\", \"Es war Barzini die ganze Zeit.\"),\n]\n\nergebnis = zaehle_zitate(filmzitate)\nprint(ergebnis)  # Ausgabe: {'Der Pate': 3, 'Star Wars': 2}\n```\n\nImplementiere die Funktion `zaehle_zitate(filmzitate)`, die das oben beschriebene Verhalten aufweist.",
    "code_skeleton": "def zaehle_zitate(filmzitate):\n    ## Hier Code einfügen",
    "model_solution": "def zaehle_zitate(filmzitate):\n    ergebnis = {}\n    i = 0\n    while i < len(filmzitate):\n        film, _ = filmzitate[i]\n        if film in ergebnis:\n            ergebnis[film] += 1\n        else:\n            ergebnis[film] = 1\n        i += 1\n    return ergebnis\n\nfilmzitate = [\n    (\"Der Pate\", \"Ich werde ihm ein Angebot machen, das er nicht ablehnen kann.\"),\n    (\"Star Wars\", \"Möge die Macht mit dir sein.\"),\n    (\"Der Pate\", \"Lass die Waffe. Nimm die Cannoli.\"),\n    (\"Star Wars\", \"Ich bin dein Vater.\"),\n    (\"Der Pate\", \"Es war Barzini die ganze Zeit.\"),\n]\n\nergebnis = zaehle_zitate(filmzitate)\nprint(ergebnis)  # Ausgabe: {'Der Pate': 3, 'Star Wars': 2}",
    "unit_tests": "import unittest\n\nfrom main import zaehle_zitate\n\nclass TestZaehleZitate(unittest.TestCase):\n    def test_mehrere_filme(self):\n        filmzitate = [\n            (\"Der Pate\", \"Ich werde ihm ein Angebot machen, das er nicht ablehnen kann.\"),\n            (\"Star Wars\", \"Möge die Macht mit dir sein.\"),\n            (\"Der Pate\", \"Lass die Waffe. Nimm die Cannoli.\"),\n            (\"Star Wars\", \"Ich bin dein Vater.\"),\n            (\"Der Pate\", \"Es war Barzini die ganze Zeit.\"),\n        ]\n        self.assertEqual(zaehle_zitate(filmzitate), {'Der Pate': 3, 'Star Wars': 2})\n\n    def test_ein_film(self):\n        filmzitate = [\n            (\"Inception\", \"Du musst tiefer gehen.\"),\n            (\"Inception\", \"Ein Gedanke ist wie ein Virus.\"),\n        ]\n        self.assertEqual(zaehle_zitate(filmzitate), {'Inception': 2})\n\n    def test_keine_zitate(self):\n        filmzitate = []\n        self.assertEqual(zaehle_zitate(filmzitate), {})\n\n    def test_ein_zitat(self):\n        filmzitate = [(\"Matrix\", \"Es gibt keinen Löffel.\")]\n        self.assertEqual(zaehle_zitate(filmzitate), {'Matrix': 1})\n\n    def test_verschiedene_filme(self):\n        filmzitate = [\n            (\"Matrix\", \"Es gibt keinen Löffel.\"),\n            (\"Inception\", \"Du musst tiefer gehen.\"),\n            (\"Star Wars\", \"Möge die Macht mit dir sein.\"),\n        ]\n        self.assertEqual(zaehle_zitate(filmzitate), {'Matrix': 1, 'Inception': 1, 'Star Wars': 1})\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  {
    "id": 200,
    "programming_concept": "Listen;Operationen mit Zahlen;If-Else-Anweisungen",
    "context": "Beziehungen",
    "task_description": "### Übungsaufgabe: Beziehungen und Altersunterschiede\n\nSchreibe eine Funktion namens `altersunterschiede(beziehungen)`, die eine Liste von Tupeln als Argument erhält. Jedes Tupel enthält zwei Namen und deren jeweiliges Alter. Die Funktion soll für jedes Paar den Altersunterschied berechnen und eine entsprechende Nachricht zurückgeben.\n\nDie Nachrichten sollen wie folgt aussehen:\n- Wenn der Altersunterschied weniger als 5 Jahre beträgt: \"`[Name1] und [Name2] sind fast gleich alt.`\"\n- Wenn der Altersunterschied zwischen 5 und 10 Jahren liegt: \"`[Name1] ist etwas älter/jünger als [Name2].`\"\n- Wenn der Altersunterschied mehr als 10 Jahre beträgt: \"`[Name1] und [Name2] haben einen großen Altersunterschied.`\"\n\nBeispielaufruf:\n```python\nbeziehungen = [(\"Anna\", 25, \"Ben\", 30), (\"Clara\", 40, \"David\", 50), (\"Eva\", 20, \"Frank\", 35)]\naltersunterschiede(beziehungen)\n```\n\nErwartete Ausgabe:\n```\nAnna und Ben sind fast gleich alt.\nClara ist etwas älter als David.\nEva und Frank haben einen großen Altersunterschied.\n```",
    "code_skeleton": "def altersunterschiede(beziehungen):\n    ## Hier Code einfügen",
    "model_solution": "def altersunterschiede(beziehungen):\n    for b in beziehungen:\n        name1, age1, name2, age2 = b\n        diff = abs(age1 - age2)\n        if diff < 5:\n            print(f\"{name1} und {name2} sind fast gleich alt.\")\n        elif 5 <= diff <= 10:\n            if age1 > age2:\n                print(f\"{name1} ist etwas älter als {name2}.\")\n            else:\n                print(f\"{name1} ist etwas jünger als {name2}.\")\n        else:\n            print(f\"{name1} und {name2} haben einen großen Altersunterschied.\")\n\nbeziehungen = [(\"Anna\", 25, \"Ben\", 30), (\"Clara\", 40, \"David\", 50), (\"Eva\", 20, \"Frank\", 35)]\naltersunterschiede(beziehungen)",
    "unit_tests": "import unittest\nfrom main import altersunterschiede\n\nclass TestAltersunterschiede(unittest.TestCase):\n    def test_fast_gleich_alt(self):\n        beziehungen = [(\"Anna\", 25, \"Ben\", 27)]\n        expected_output = \"Anna und Ben sind fast gleich alt.\\n\"\n        with self.assertLogs(level='INFO') as log:\n            altersunterschiede(beziehungen)\n            self.assertIn(expected_output.strip(), log.output[0])\n\n    def test_etwas_aelter(self):\n        beziehungen = [(\"Clara\", 40, \"David\", 45)]\n        expected_output = \"Clara ist etwas älter als David.\\n\"\n        with self.assertLogs(level='INFO') as log:\n            altersunterschiede(beziehungen)\n            self.assertIn(expected_output.strip(), log.output[0])\n\n    def test_grosser_altersunterschied(self):\n        beziehungen = [(\"Eva\", 20, \"Frank\", 35)]\n        expected_output = \"Eva und Frank haben einen großen Altersunterschied.\\n\"\n        with self.assertLogs(level='INFO') as log:\n            altersunterschiede(beziehungen)\n            self.assertIn(expected_output.strip(), log.output[0])\n\n    def test_etwas_juenger(self):\n        beziehungen = [(\"Gina\", 30, \"Hank\", 35)]\n        expected_output = \"Gina ist etwas jünger als Hank.\\n\"\n        with self.assertLogs(level='INFO') as log:\n            altersunterschiede(beziehungen)\n            self.assertIn(expected_output.strip(), log.output[0])\n\n    def test_randbedingungen(self):\n        beziehungen = [(\"Ivy\", 18, \"Jack\", 18), (\"Kate\", 20, \"Leo\", 30), (\"Mia\", 25, \"Nate\", 35)]\n        expected_outputs = [\n            \"Ivy und Jack sind fast gleich alt.\\n\",\n            \"Kate und Leo haben einen großen Altersunterschied.\\n\",\n            \"Mia und Nate haben einen großen Altersunterschied.\\n\"\n        ]\n        with self.assertLogs(level='INFO') as log:\n            altersunterschiede(beziehungen)\n            for expected_output in expected_outputs:\n                self.assertIn(expected_output.strip(), log.output)\n\nif __name__ == '__main__':\n    unittest.main()"
  }
]